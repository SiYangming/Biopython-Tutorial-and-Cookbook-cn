Bio.PDB 是一个 Biopython 模块，专注于处理生物大分子的晶体结构。除其他事项外，Bio.PDB 包含一个 PDBParser 类，它生成一个 Structure 对象，可用于以方便的方式访问文件中的原子数据。对解析 PDB 标头中包含的信息的支持有限。PDB 文件格式不再被修改或扩展以支持新内容，PDBx/mmCIF 在 2014 年成为标准的 PDB 存档格式。所有全球蛋白质数据库 (wwPDB) 站点都使用大分子晶体信息文件 (mmCIF) 数据字典来描述PDB条目的信息内容。mmCIF使用灵活且可扩展的键值对格式来表示大分子结构数据，并且对原子数没有限制，

# 11.1 读写晶体结构文件

## 11.1.1 读取 mmCIF 文件

首先创建一个MMCIFParser对象：

```
>>> 从 Bio.PDB.MMCIFParser 导入 MMCIFParser
>>> 解析器 = MMCIFParser()
```

然后使用此解析器从 mmCIF 文件创建结构对象：

```
>>> structure = parser.get_structure("1fat", "1fat.cif")
```

要对 mmCIF 文件进行更底层的访问，您可以使用该类`MMCIF2Dict`创建一个 Python 字典，将 mmCIF 文件中的所有 mmCIF 标签映射到它们的值。无论是有多个值（如 tag 的情况`_atom_site.Cartn_y`，它保存所有原子的*y*坐标）还是单个值（如初始沉积日期），标签都会映射到一个值列表。字典是从 mmCIF 文件创建的，如下所示：

```
>>> 从 Bio.PDB.MMCIF2Dict 导入 MMCIF2Dict
>>> mmcif_dict = MMCIF2Dict("1FAT.cif")
```

示例：从 mmCIF 文件中获取溶剂含量：

```
>>> sc = mmcif_dict["_exptl_crystal.density_percent_sol"]
```

示例：获取所有原子的*y*坐标列表

```
>>> y_list = mmcif_dict["_atom_site.Cartn_y"]
```

## 11.1.2 读取MMTF格式文件

您可以使用直接 MMTFParser 从文件中读取结构：

```
>>> 从 Bio.PDB.mmtf 导入 MMTFParser
>>> 结构 = MMTFParser.get_structure("PDB/4CUP.mmtf")
```

或者您可以使用相同的类通过其 PDB ID 获取结构：

```
>>> 结构 = MMTFParser.get_structure_from_url("4CUP")
```

这为您提供了一个 Structure 对象，就像从 PDB 或 mmCIF 文件中读取的一样。

您还可以使用 Biopython 在内部使用的外部 MMTF 库访问底层数据：

```
>>> 从 mmtf 导入获取
>>> decoded_data = fetch("4CUP")
```

例如，您可以只访问 X 坐标。

```
>>> 打印（解码数据.x_坐标列表）
```

## 11.1.3 读取 PDB 文件

首先我们创建一个PDBParser对象：

```
>>> 从 Bio.PDB.PDBParser 导入 PDBParser
>>> 解析器 = PDBParser(PERMISSIVE=1)
```

PERMISSIVE标志表示将忽略与 PDB 文件相关的许多常见问题（请参阅[11.7.1 ）（但请注意，某些原子和/或残基将丢失）。](https://biopython-org.translate.goog/DIST/docs/tutorial/Tutorial.html?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN&_x_tr_pto=wapp&_x_tr_sch=http#sec%3Aproblem_structures)如果该标志不存在，则在解析操作期间检测到任何问题时将生成PDBConstructionException 。

然后通过让PDBParser对象解析 PDB 文件来生成 Structure 对象（本例中的 PDB 文件称为`pdb1fat.ent`，`1fat`是结构的用户定义名称）：

```
>>> structure_id = "1fat"
>>> 文件名 = "pdb1fat.ent"
>>> structure = parser.get_structure(structure_id, 文件名)
```

您可以使用get_header和get_trailer方法从 PDBParser 对象中提取 PDB 文件的标头和尾部（简单的字符串列表）。但是请注意，许多 PDB 文件包含带有不完整或错误信息的标头。许多错误已在等效的 mmCIF 文件中得到修复。*因此，如果您对标头信息感兴趣，最好使用* *上述**MMCIF2Dict工具从 mmCIF 文件中提取信息，而不是解析 PDB 标头。*

现在已经澄清了，让我们返回到解析 PDB 标头。结构对象有一个名为header的属性，它是一个 Python 字典，将标题记录映射到它们的值。

例子：

```
>>> 分辨率 = structure.header["分辨率"]
>>> 关键字 = structure.header["关键字"]
```

可用的键是`name`, `head`, `deposition_date`, `release_date`, `structure_method`, `resolution`, `structure_reference`（映射到参考列表），`journal_reference`, `author`, `compound`（映射到包含有关结晶化合物的各种信息的字典），`has_missing_residues`, `missing_residues`, 和`astral`（映射到包含有关结晶化合物的附加信息的字典域（如果存在）。

`has_missing_residues`如果至少`REMARK 465`找到一个非空标题行，则映射到一个为 True 的布尔值。在这种情况下，您应该假设实验中使用的分子有一些无法确定原子坐标的残基。`missing_residues`映射到包含有关缺失残基信息的字典列表。*如果 PDB 标头不遵循 PDB 规范中的模板，则缺失残基列表将为空或不完整。*

也可以在不创建Structure对象的情况下创建字典，即。直接从 PDB 文件：

```
>>> 从 Bio.PDB 导入 parse_pdb_header
>>> 以 open(filename, "r") 作为句柄：
... header_dict = parse_pdb_header(句柄)
...
```

## 11.1.4 读取 PQR 文件

为了解析 PQR 文件，以与 PDB 文件类似的方式进行：

使用is_pqr标志创建PDBParser对象：

```
>>> 从 Bio.PDB.PDBParser 导入 PDBParser
>>> pqr_parser = PDBParser(PERMISSIVE=1, is_pqr=True)
```

is_pqr标志设置为True表示要解析的文件是 PQR 文件，解析器应该读取每个原子条目的原子电荷和半径字段。按照与 PQR 文件相同的过程，然后生成一个结构对象，并解析 PQR 文件。

```
>>> structure_id = "1fat"
>>> 文件名 = "pdb1fat.ent"
>>> structure = parser.get_structure(structure_id, 文件名, is_pqr=True)
```

## 11.1.5 读取 PDB XML 格式的文件

这还不支持，但我们肯定计划在未来支持它（这不是很多工作）。如果您需要，请通过邮件列表联系 Biopython 开发人员。

## 11.1.6 写入 mmCIF 文件

MMCIFIO类可用于将结构写入 mmCIF 文件格式：

```
>>> io = MMCIFIO()
>>> io.set_structure(s)
>>> io.save("out.cif")
```

Select类的使用方式与下面的PDBIO类似。使用MMCIF2Dict读取的mmCIF字典也可以这样写：

```
>>> io = MMCIFIO()
>>> io.set_dict(d)
>>> io.save("out.cif")
```

## 11.1.7 写入 PDB 文件

为此使用PDBIO类。当然，写出结构的特定部分也很容易。

示例：保存结构

```
>>> io = PDBIO()
>>> io.set_structure(s)
>>> io.save("out.pdb")
```

如果您想写出结构的一部分，请使用Select类（也在PDBIO中）。Select 有四种方法：

- `accept_model(model)`
- `accept_chain(chain)`
- `accept_residue(residue)`
- `accept_atom(atom)`

默认情况下，每个方法都返回 1（这意味着模型/链/残基/原子包含在输出中）。通过继承Select并在适当时返回 0，您可以从输出中排除模型、链等。也许很麻烦，但非常强大。以下代码仅写出甘氨酸残基：

```
>>> 类 GlySelect（选择）：
... def accept_residue(self, residue):
...如果 residue.get_name() == "GLY":
...返回真
... 别的：
...返回假
...
>>> io = PDBIO()
>>> io.set_structure(s)
>>> io.save("gly_only.pdb", GlySelect())
```

如果这对您来说太复杂了，Dice模块包含一个方便的提取函数，可以写出起始和结束残基之间的链中的所有残基。

## 11.1.8 写入 PQR 文件

像使用 PDB 文件一样使用PDBIO类，使用标志is_pqr=True。PDBIO 方法也可用于 PQR 文件。

示例：编写 PQR 文件

```
>>> io = PDBIO(is_pqr=True)
>>> io.set_structure(s)
>>> io.save("out.pdb")
```

## 11.1.9 编写 MMTF 文件

要将结构写入 MMTF 文件格式：

```
>>> 从 Bio.PDB.mmtf 导入 MMTFIO
>>> io = MMTFIO()
>>> io.set_structure(s)
>>> io.save("out.mmtf")
```

Select类可以像上面那样使用。请注意，标准 MMTF 文件中包含的键合信息、二级结构分配和其他一些信息并未写出，因为它们不容易从结构对象中确定。此外，在标准 MMTF 文件中归入同一实体的分子被MMTFIO视为单独的实体。

# 11.2 结构表示

Structure对象的整体布局遵循所谓的 SMCRA（Structure/Model/Chain/Residue/Atom）架构：

- 结构由模型组成
- 模型由链组成
- 一条链由残基组成
- 残基由原子组成

这是许多结构生物学家/生物信息学家思考结构的方式，并提供了一种简单但有效的处理结构的方法。额外的东西基本上是在需要的时候添加的。[图11.1显示了](https://biopython-org.translate.goog/DIST/docs/tutorial/Tutorial.html?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN&_x_tr_pto=wapp&_x_tr_sch=http#fig%3Asmcra)Structure对象的 UML 图（暂时忘掉Disordered类）. 这样的数据结构不一定最适合表示结构的大分子内容，但对于描述结构的文件（通常是 PDB 或 MMCIF 文件）中存在的数据的良好解释是绝对必要的。如果此层次结构不能表示结构文件的内容，则可以肯定该文件包含错误或至少没有明确描述结构。如果无法生成 SMCRA 数据结构，则有理由怀疑存在问题。因此，解析 PDB 文件可用于检测可能的问题。[我们将在11.7.1](https://biopython-org.translate.goog/DIST/docs/tutorial/Tutorial.html?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN&_x_tr_pto=wapp&_x_tr_sch=http#sec%3Aproblem_structures)节中给出几个例子。

> ------
>
> 
>
> 图 11.1：用于表示大分子结构的Structure类的 SMCRA 体系结构的 UML 图。带菱形的实线表示聚合，带箭头的实线表示引用，带三角形的实线表示继承，带三角形的虚线表示接口实现。
>
> 
>
> ------

Structure、Model、Chain 和 Residue 都是 Entity 基类的子类。Atom 类仅（部分）实现了 Entity 接口（因为 Atom 没有子级）。

对于每个 Entity 子类，您可以通过使用该子类的唯一 ID 作为键来提取子类（例如，您可以通过使用原子名称字符串作为键从 Residue 对象中提取 Atom 对象，您可以从中提取 Chain 对象通过使用其链标识符作为键的模型对象）。

无序原子和残基由 DisorderedAtom 和 DisorderedResidue 类表示，它们都是 DisorderedEntityWrapper 基类的子类。它们隐藏了与无序相关的复杂性，并且表现得与 Atom 和 Residue 对象完全一样。

通常，子实体对象（即 Atom、Residue、Chain、Model）可以通过使用 id 作为键从其父实体（即分别为 Residue、Chain、Model、Structure）中提取出来。

```
>>> child_entity = parent_entity[child_id]
```

您还可以获得父实体对象的所有子实体的列表。请注意，此列表以特定方式排序（例如，根据模型对象中 Chain 对象的链标识符）。

```
>>> child_list = parent_entity.get_list()
```

您还可以从孩子那里获得父母：

```
>>> parent_entity = child_entity.get_parent()
```

在 SMCRA 层次结构的所有级别，您还可以提取*完整的 id*。完整的 id 是一个元组，包含从顶部对象（结构）开始到当前对象的所有 id。Residue 对象的完整 ID 例如：

```
>>> full_id = residue.get_full_id()
>>> 打印（完整 ID）
("1abc", 0, "A", ("", 10, "A"))
```

这对应于：

- 带id的结构`"1abc"`
- 带有 id 的模型`0`
- 带id的链`"A"`
- 带id的残差`("", 10, "A")`

Residue id 表示该残基不是异质残基（也不是水），因为它有一个空白的异质字段，它的序列标识符是 10 并且它的插入代码是`"A"`。

要获取实体的 ID，请使用以下`get_id`方法：

```
>>> 实体.get_id()
```

您可以使用以下方法检查实体是否具有具有给定 id 的子项`has_id`：

```
>>> entity.has_id(entity_id)
```

一个实体的长度等于它的孩子的数量：

```
>>> nr_children = len(实体)
```

可以从父实体删除、重命名、添加等子实体，但这不包括任何健全性检查（例如，可以将具有相同 ID 的两个残基添加到一个链中）。这确实应该通过一个包含完整性检查的漂亮装饰器类来完成，但如果您想使用原始接口，您可以查看代码 (Entity.py)。

## 11.2.1 结构

Structure 对象位于层次结构的顶部。它的 id 是用户给定的字符串。该结构包含许多模型子项。大多数晶体结构（但不是全部）包含单一模型，而 NMR 结构通常包含多个模型。大部分分子的晶体结构无序也可以产生多种模型。

## 11.2.2 型号

Model对象的id是一个整数，由模型在解析文件中的位置得出（自动从0开始编号）。晶体结构通常只有一个模型（id 为 0），而 NMR 文件通常有多个模型。许多 PDB 解析器假定只有一种模型，而设计`Structure`中的类`Bio.PDB`可以轻松处理具有多个模型的 PDB 文件。

例如，要从 Structure 对象获取第一个模型，请使用

```
>>> first_model = 结构[0]
```

模型对象存储链子列表。

## 11.2.3 链

Chain 对象的 id 源自 PDB/mmCIF 文件中的链标识符，并且是单个字符（通常是字母）。Model 对象中的每个 Chain 都有一个唯一的 ID。例如，要从模型对象中获取标识符为“A”的 Chain 对象，请使用

```
>>> chain_A = 模型["A"]
```

Chain 对象存储一个 Residue 子项列表。

## 11.2.4 残留物

残差 id 是一个包含三个元素的元组：

- 异域（ 

  hetfield

  ）：这是

  - `'W'`在水分子的情况下；
  - `'H_'`后面是其他杂残基的残基名称（例如，`'H_GLC'`在葡萄糖分子的情况下）；
  - 标准氨基酸和核酸空白。

  

  由于第 11.4.1

  节中所述的原因，采用该方案。

- **序列标识符**（resseq），一个描述链中残基位置的整数（例如，100）；

- 插入**代码**（icode）；一个字符串，例如'A'。插入代码有时用于保留某种理想的残基编号方案。Ser 80 插入突变体（插入例如 Thr 80 和 Asn 81 残基之间）可以例如具有如下序列标识符和插入代码：Thr 80 A、Ser 80 B、Asn 81。这样，残基编号方案保持一致与野生型结构。

因此，上述葡萄糖残基的 ID 为('H_GLC', 100, 'A')。如果 hetero-flag 和插入代码为空，则可以单独使用序列标识符：

```
# 完整ID
>>> 残基 = 链 [(" ", 100, " ")]
# 快捷方式标识
>>> 残基 = 链[100]
```

hetero-flag 的原因是许多 PDB 文件使用相同的氨基酸序列标识符和 hetero-residue 或水，如果不使用 hetero-flag 会产生明显的问题。

不出所料，一个 Residue 对象存储了一组 Atom 子对象。它还包含一个字符串，指定残基名称（例如“ASN”）和残基的片段标识符（X-PLOR 用户众所周知，但未用于构建 SMCRA 数据结构）。

让我们看一些例子。带有空白插入代码的 Asn 10 将具有残基 ID (' ', 10, ' ')。水 10 的残留物 ID 为('W', 10, ' ')。具有序列标识符 10 的葡萄糖分子（具有残基名称 GLC 的异质残基）将具有残基 ID ('H_GLC', 10, ' ')。这样，三个残基（具有相同的插入代码和序列标识符）可以是同一链的一部分，因为它们的残基 ID 是不同的。

在大多数情况下，hetflag 和插入代码字段将为空白，例如(' ', 10, ' ')。在这些情况下，序列标识符可以用作完整 ID 的快捷方式：

```
# 使用完整的 id
>>> res10 = 链[(" ", 10, " ")]
# 使用快捷方式
>>> res10 =链[10]
```

Chain 对象中的每个 Residue 对象都应该有一个唯一的 id。然而，无序残基以特殊方式处理，如第[11.3.3](https://biopython-org.translate.goog/DIST/docs/tutorial/Tutorial.html?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN&_x_tr_pto=wapp&_x_tr_sch=http#sec%3Apoint_mutations)节所述。

Residue 对象有许多额外的方法：

```
>>> residue.get_resname() # 返回残基名称，例如“ASN”
>>> residue.is_disordered() # 如果残基有无序原子则返回 1
>>> residue.get_segid() # 返回 SEGID，例如“CHN1”
>>> residue.has_id(name) # 测试一个残基是否有某个原子
```

您可以使用is_aa(residue)来测试 Residue 对象是否为氨基酸。

## 11.2.5 原子

Atom 对象存储与原子关联的数据，并且没有子对象。原子的 id 是它的原子名称（例如，“OG”表示 Ser 残基的侧链氧）。Atom id 在 Residue 中需要是唯一的。[同样，如第 11.3.2](https://biopython-org.translate.goog/DIST/docs/tutorial/Tutorial.html?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN&_x_tr_pto=wapp&_x_tr_sch=http#sec%3Adisordered_atoms)节所述，无序原子例外。

原子 id 只是原子名称（例如'CA'）。实际上，原子名称是通过从 PDB 文件中的原子名称中去除所有空格来创建的。

但是，在 PDB 文件中，空格可以是原子名称的一部分。通常，钙原子被称为“CA..”以区别于 Cα 原子（称为“.CA.”）。如果剥离空格会产生问题（即在同一残基中称为“CA”的两个原子），则保留空格。

在 PDB 文件中，原子名称由 4 个字符组成，通常带有前导和尾随空格。通常可以删除这些空格以便于使用（例如，氨基酸 C α 原子在 PDB 文件中标记为“.CA.”，其中点代表空格）。为了生成原子名称（以及原子 ID），空格被删除，除非这会导致 Residue 中的名称冲突（即具有相同原子名称和 ID 的两个 Atom 对象）。在后一种情况下，尝试使用包含空格的原子名称。例如，当一个残基包含名称为“.CA”的原子时，就会发生这种情况。和“CA..”，尽管这不太可能。

存储的原子数据包括原子名称、原子坐标（包括标准偏差，如果存在）、B 因子（包括各向异性 B 因子和标准偏差，如果存在）、altloc 说明符和包括空格的完整原子名称。不存储较少使用的项目，如原子元素编号或有时在 PDB 文件中指定的原子电荷。

要操作原子坐标，请使用Atom对象的transform方法。使用set_coord方法直接指定原子坐标。

Atom 对象具有以下附加方法：

```
>>> a.get_name() # 原子名（去掉空格，例如“CA”）
>>> a.get_id() # id（等于原子名称）
>>> a.get_coord() # 原子坐标
>>> a.get_vector() # 原子坐标作为 Vector 对象
>>> a.get_bfactor() # 各向同性 B 因子
>>> a.get_occupancy() # 占用率
>>> a.get_altloc() # 替代位置说明符
>>> a.get_sigatm() #原子参数的标准差
>>> a.get_siguij() #各向异性B因子的标准差
>>> a.get_anisou() # 各向异性 B 因子
>>> a.get_fullname() # 原子名称（带空格，例如“.CA.”）
```

为了表示原子坐标，使用了 siguij、各向异性 B 因子和 sigatm Numpy 数组。

get_vector方法返回Atom对象坐标的 Vector 对象表示，允许您对原子坐标进行矢量操作。Vector实现了全套 3D 矢量运算、矩阵乘法（左和右）以及一些与旋转相关的高级运算。

作为 Bio.PDB 的Vector模块功能的示例，假设您想要找到 Gly 残基的 Cβ 原子的位置（如果有的话）。将 Gly 残基的 N 原子沿 Cα-C 键旋转超过 -120 度，大致将其置于虚拟 Cβ 原子的位置。以下是使用Vector模块的rotaxis方法（可用于构造围绕特定轴的旋转）的方法：

```
# 获取原子坐标作为向量
>>> n = 残基["N"].get_vector()
>>> c = 残基["C"].get_vector()
>>> ca = 残基["CA"].get_vector()
# 原点中心
>>> n = n - 钙
>>> c = c - ca
# 找到旋转n的旋转矩阵
# 沿 ca-c 向量 -120 度
>>> rot = rotaxis(-pi * 120.0 / 180.0, c)
# 对 ca-n 向量应用旋转
>>> cb_at_origin = n.left_multiply(旋转)
# 放在 ca 原子之上
>>> cb = cb_at_origin + ca
```

此示例表明可以对原子数据执行一些非常重要的向量操作，这可能非常有用。除了所有常用的向量运算（交叉（使用* *）和点（使用*）乘积、角度、范数等）和上面提到的rotaxis函数之外，Vector模块还具有旋转（rotmat）或在另一个向量之上反射 ( refmat ) 一个向量。

## 11.2.6从结构中提取特定的原子/残基/链/模型

这些是一些例子：

```
>>> 模型 = 结构[0]
>>>链=模型[“A”]
>>> 残基 = 链[100]
>>> 原子 = 残基["CA"]
```

请注意，您可以使用快捷方式：

```
>>> atom = structure[0]["A"][100]["CA"]
```

# 11.3 混乱

Bio.PDB 可以处理无序原子和点突变（即同一位置的 Gly 和 Ala 残基）。

## 11.3.1 一般方法



无序应该从两个角度来处理：原子的角度和残留的角度。总的来说，我们试图封装所有由无序引起的复杂性。如果你只是想遍历所有的 Cα 原子，你不关心一些残基有一个无序的侧链。另一方面，也应该可以在数据结构中完全表示无序。因此，无序的原子或残基被存储在特殊的物体中，这些物体的行为就像没有无序一样。这是通过仅表示无序原子或残基的子集来完成的。用户可以指定选择哪个子集（例如，使用 Ser 残基的两个无序 OG 侧链原子位置中的哪一个）。

## 11.3.2 无序原子



无序原子由普通的Atom对象表示，但表示同一物理原子的所有Atom对象都存储在DisorderedAtom对象中（见图[11.1）](https://biopython-org.translate.goog/DIST/docs/tutorial/Tutorial.html?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN&_x_tr_pto=wapp&_x_tr_sch=http#fig%3Asmcra)。DisorderedAtom对象中的每个Atom对象都可以使用其 altloc 说明符进行唯一索引。DisorderedAtom对象将所有未捕获的方法调用转发给选定的 Atom 对象，默认情况下代表具有最高占用率的原子。用户当然可以更改所选的Atom对象，利用其 altloc 说明符。以这种方式正确地表示原子无序，而没有太多额外的复杂性。换句话说，如果你对原子无序不感兴趣，你就不会被它困扰。

每个无序原子都有一个特有的 altloc 标识符。您可以指定DisorderedAtom对象的行为应该类似于与特定 altloc 标识符关联的Atom对象：

```
>>> atom.disordered_select("A") # 选择 altloc A 原子
>>> 打印（atom.get_altloc（））
“A”
>>> atom.disordered_select("B") # 选择 altloc B 原子
>>> 打印（atom.get_altloc（））
“乙”
```

## 11.3.3 无序残基

#### 常见案例

最常见的情况是含有一个或多个无序原子的残基。这显然可以通过使用 DisorderedAtom 对象来表示无序原子，并将 DisorderedAtom 对象存储在 Residue 对象中，就像普通的 Atom 对象一样解决。DisorderedAtom 将通过将所有未捕获的方法调用转发到它包含的 Atom 对象之一（选定的 Atom 对象）来表现得与普通原子（实际上是占用率最高的原子）完全一样。

#### 点突变



当无序是由点突变引起时，即当晶体中存在多肽的两个或多个点突变体时，会出现一种特殊情况。在 PDB 结构 1EN2 中可以找到这方面的示例。

由于这些残基属于不同的残基类型（例如，Ser 60 和 Cys 60），它们不应像常见情况那样存储在单个Residue对象中。在这种情况下，每个残基都由一个Residue对象表示，并且两个Residue对象都存储在一个DisorderedResidue对象中（见图[11.1）](https://biopython-org.translate.goog/DIST/docs/tutorial/Tutorial.html?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN&_x_tr_pto=wapp&_x_tr_sch=http#fig%3Asmcra)。

DisorderedResidue对象将所有未捕获的方法转发给选定的Residue对象（默认情况下是最后添加的Residue对象），因此表现得像一个普通的 residue。DisorderedResidue对象中的每个Residue对象都可以通过其残基名称唯一标识。在上面的示例中，残基 Ser 60 在DisorderedResidue对象中的 ID 为“SER” ，而残基 Cys 60 的 ID 为“CYS”。用户可以通过此 id 在DisorderedResidue对象中选择活动的Residue对象。

示例：假设一条链在第 10 位发生点突变，由一个 Ser 和一个 Cys 残基组成。确保此链的第 10 位残基与 Cys 残基相同。

```
>>> 残基 = 链[10]
>>> residue.disordered_select("CYS")
```

此外，您可以使用(Disordered)Residue对象的get_unpacked_list方法获取所有Atom对象的列表（即所有DisorderedAtom对象都“解包”为它们各自的Atom对象）。

# 11.4 杂残基

## 11.4.1 相关问题



异质残基的一个常见问题是同一条链中存在的几个异质和非杂质残基共享相同的序列标识符（和插入代码）。因此，为了为每个异质残基生成唯一的 ID，水和其他异质残基将以不同的方式处理。

请记住，Residue 对象将元组 (hetfield、resseq、icode) 作为 id。氨基酸和核酸的 hetfield 为空白（“”），水域和其他异质残基为字符串。hetfield 的内容解释如下。

## 11.4.2 水残留物

水残留物的 hetfield 字符串由字母“W”组成。因此，水的典型残留物 ID 是（“W”，1，“”）。

## 11.4.3 其他杂残基

其他异质残基的 hetfield 字符串以“H_”开头，后跟残基名称。例如，具有残基名称“GLC”的葡萄糖分子将具有 hetfield“H_GLC”。它的残基 ID 可以是，例如（“H_GLC”，1，“”）。

# 11.5 在结构对象中导航

### 解析一个 PDB 文件，并提取一些 Model、Chain、Residue 和 Atom 对象

```
>>> 从 Bio.PDB.PDBParser 导入 PDBParser
>>> 解析器 = PDBParser()
>>> structure = parser.get_structure("test", "1fat.pdb")
>>> 模型 = 结构[0]
>>>链=模型[“A”]
>>> 残基 = 链 [1]
>>> 原子 = 残基["CA"]
```

### 遍历结构的所有原子

```
>>> p = PDBParser()
>>> structure = p.get_structure("X", "pdb1fat.ent")
>>> 对于结构模型：
...对于模型中的链：
...对于链中的残留物：
...对于残留物中的原子：
...打印（原子）
...
```

如果你想遍历结构中的所有原子，有一个捷径：

```
>>> 原子 = structure.get_atoms()
>>> 对于原子中的原子：
...打印（原子）
...
```

同样，要遍历链中的所有原子，请使用

```
>>> 原子 = chain.get_atoms()
>>> 对于原子中的原子：
...打印（原子）
...
```

### 遍历模型的所有残差

或者，如果您想遍历模型中的所有残基：

```
>>> 残基 = model.get_residues()
>>> 残留物中的残留物：
... 打印（残差）
...
```

您还可以使用该`Selection.unfold_entities`函数从结构中获取所有残基：

```
>>> res_list = Selection.unfold_entities(结构, "R")
```

或者从链中获取所有原子：

```
>>> atom_list = Selection.unfold_entities(chain, "A")
```

显然，`A=atom, R=residue, C=chain, M=model, S=structure`。您可以使用它在层次结构中上升，例如从以下列表中获取（唯一）列表`Residue`或父列表：`Chain``Atoms`

```
>>> residue_list = Selection.unfold_entities(atom_list, "R")
>>> chain_list = Selection.unfold_entities(atom_list, "C")
```

有关详细信息，请参阅 API 文档。

### 从链中提取异质残基（例如具有 resseq 10 的葡萄糖 (GLC) 部分）

```
>>> residue_id = ("H_GLC", 10, " ")
>>> 残基 = 链[残基_id]
```

### 打印链中的所有异质残基

```
>>> 对于 chain.get_list() 中的残基：
... residue_id = residue.get_id()
... hetfield = residue_id[0]
... 如果 hetfield[0] == "H":
...打印（residue_id）
...
```

### 打印出 B 因子大于 50 的结构中所有 CA 原子的坐标

```
>>> 对于 structure.get_list() 中的模型：
... 对于 model.get_list() 中的链：
...对于 chain.get_list() 中的残留物：
...如果 residue.has_id("CA"):
... ca = 残基["CA"]
... 如果 ca.get_bfactor() > 50.0：
...打印（ca.get_coord（））
...
```

### 打印出所有含有无序原子的残基

```
>>> 对于 structure.get_list() 中的模型：
... 对于 model.get_list() 中的链：
...对于 chain.get_list() 中的残留物：
...如果 residue.is_disordered():
... resseq = residue.get_id()[1]
... 重新命名 = residue.get_resname()
... model_id = model.get_id()
... chain_id = chain.get_id()
...打印（model_id，chain_id，resname，resseq）
...
```

### 遍历所有无序原子，并使用 altloc A 选择所有原子（如果存在）

这将确保 SMCRA 数据结构的行为就像只有具有 altloc A 的原子存在一样。

```
>>> 对于 structure.get_list() 中的模型：
... 对于 model.get_list() 中的链：
...对于 chain.get_list() 中的残留物：
...如果 residue.is_disordered():
...对于 residue.get_list() 中的原子：
... 如果 atom.is_disordered():
...如果 atom.disordered_has_id("A"):
... atom.disordered_select("A")
...
```

### 从Structure对象中提取多肽

要从结构中提取多肽，请使用PolypeptideBuilder从Structure对象构造一个Polypeptide对象列表，如下所示：

```
>>> 模型编号 = 1
>>> polypeptide_list = build_peptides(结构, model_nr)
>>> 对于 polypeptide_list 中的多肽：
...打印（多肽）
...
```

Polypeptide 对象只是 Residue 对象的 UserList，并且总是从单个模型（在本例中为模型 1）创建。您可以使用生成的Polypeptide对象将序列作为Seq对象获取或获取 Cα 原子列表。可以使用 CN 或 Cα-Cα 距离标准构建多肽。

例子：

```
# 使用 CN
>>> ppb = PPBuilder()
>>> 对于 ppb.build_peptides（结构）中的 pp：
...打印（pp.get_sequence（））
...
# 使用 CA-CA
>>> ppb = CaPPBuilder()
>>> 对于 ppb.build_peptides（结构）中的 pp：
...打印（pp.get_sequence（））
...
```

请注意，在上述情况下， PolypeptideBuilder仅考虑结构的模型 0 。但是，也可以使用PolypeptideBuilder从Model和Chain对象构建Polypeptide对象。

### 获取结构的序列

首先要做的是从结构中提取所有多肽（如上所述）。然后可以很容易地从Polypeptide对象中获得每个多肽的序列。该序列表示为 Biopython Seq对象。

例子：

```
>>> seq = 多肽.get_sequence()
>>> 序号
Seq('SNDIYFNFQRFNETNLILQRDASVSSSGQLRLTNLN')
```

# 11.6 分析结构

## 11.6.1 测量距离

原子的减号运算符已被重载以返回两个原子之间的距离。

```
# 获取一些原子
>>> ca1 = residue1["CA"]
>>> ca2 = residue2["CA"]
# 简单地减去原子得到它们的距离
>>> 距离 = ca1 - ca2
```

## 11.6.2 测量角度

使用原子坐标的矢量表示和Vector模块中的calc_angle函数：

```
>>> vector1 = atom1.get_vector()
>>> vector2 = atom2.get_vector()
>>> vector3 = atom3.get_vector()
>>> 角度 = calc_angle(vector1, vector2, vector3)
```

## 11.6.3 测量扭转角

使用原子坐标的矢量表示，以及Vector模块中的calc_dihedral函数：

```
>>> vector1 = atom1.get_vector()
>>> vector2 = atom2.get_vector()
>>> vector3 = atom3.get_vector()
>>> vector4 = atom4.get_vector()
>>> 角度 = calc_dihedral(vector1, vector2, vector3, vector4)
```

## 11.6.4 内部坐标模块 - 距离、角度、扭转角、距离图等



蛋白质结构通常以相对于固定原点的 3D XYZ 坐标提供，如在 PDB 或 mmCIF 文件中。internal_coords模块有助于将该系统转换为键长、键角和二面角。除了支持蛋白质结构的标准*psi、phi、chi*等计算外，这种表示对于平移和旋转是不变的，并且该实现为结构分析提供了多种好处。

首先在这里加载一些模块以供后面的示例使用：

```
>>> 从 Bio.PDB.PDBParser 导入 PDBParser
>>> 从 Bio.PDB.Chain 导入链
>>> 从 Bio.PDB.internal_coords 导入 *
>>> 从 Bio.PDB.PICIO 导入 write_PIC、read_PIC、read_PIC_seq
>>> 从 Bio.PDB.ic_rebuild 导入 write_PDB、IC_duplicate、structure_rebuild_test
>>> 从 Bio.PDB.SCADIO 导入 write_SCAD
>>> 从 Bio.Seq 导入 Seq
>>> 从 Bio.SeqRecord 导入 SeqRecord
>>> 从 Bio.PDB.PDBIO 导入 PDBIO
>>> 将 numpy 导入为 np
```

### 11.6.4.1 访问二面角、角度和键长

我们从计算结构内部坐标的简单情况开始：

```
>>> # 正常加载结构，获取第一个链
>>> 解析器 = PDBParser()
>>> myProtein = parser.get_structure("1a8o", "1A8O.pdb")
>>> myChain = myProtein[0]["A"]
>>> # 计算键长、键角、二面角
>>> myChain.atom_to_internal_coordinates(verbose=True)
由于超过 MaxPeptideBond（1.4 埃），链在 THR 186 处断裂
由于超过 MaxPeptideBond（1.4 埃），在 THR 216 发生断链
```

通过删除上面的verbose=True选项，可以抑制 1A8O 的断链警告。为避免创建中断并允许不切实际的长 NC 键，请覆盖类变量MaxPeptideBond，例如：

```
>>> IC_Chain.MaxPeptideBond = 4.0
>>> myChain.internal_coord = None # 强制重新加载具有新截止点的结构数据
>>> myChain.atom_to_internal_coordinates(verbose=True)
```

此时，链和残基级别的值都可用。1A8O 的第一个残基是 HETATM MSE（硒代甲硫氨酸），因此我们使用规范名称或原子说明符研究下面的残基 2。在这里，我们通过名称和原子序列获得*chi1*二面角和*tau*角，并通过指定原子对获得 Cα-Cβ 距离：

```
>>> r2 = myChain.child_list[1]
>>> r2
<残差ASP het=resseq=152 icode=>
>>> r2ic = r2.internal_coord
>>> 打印（r2ic，“：”，r2ic.pretty_str（），“：”，r2ic.rbase，“：”，r2ic.lc）
('1a8o', 0, 'A', (' ', 152, ' ')) : ASP 152 : (152, None, 'D') : D

>>> r2chi1 = r2ic.get_angle("chi1")
>>> 打印（圆（r2chi1，2））
-144.86
>>> r2ic.get_angle("chi1") == r2ic.get_angle("N:CA:CB:CG")
真的
>>> print(round(r2ic.get_angle("tau"), 2))
113.45
>>> r2ic.get_angle("tau") == r2ic.get_angle("N:CA:C")
真的
>>> print(round(r2ic.get_length("CA:CB"), 2))
1.53
```

Chain.internal_coord对象包含 hedra（3个键合原子）和 dihedra（4 个键合原子）对象的数组和字典。字典由AtomKey对象的元组索引；AtomKey对象捕获残基位置、插入代码、1 个或 3 个字符的残基名称、原子名称、altloc 和占用率。

下面我们通过直接索引Chain数组获得与上面相同的*chi1*和*tau*角度，使用AtomKey s 索引Chain数组：

```
>>> myCic = myChain.internal_coord

>>> r2chi1_object = r2ic.pick_angle("chi1")
>>> # 或相同的东西（与上面的 get_angle() 一样）：
>>> r2chi1_object == r2ic.pick_angle("N:CA:CB:CG")
真的
>>> r2chi1_key = r2chi1_object.atomkeys
>>> r2chi1_key # r2chi1_key 是 AtomKeys 的元组
(152_D_N, 152_D_CA, 152_D_CB, 152_D_CG)

>>> r2chi1_index = myCic.dihedraNdx[r2chi1_key]
>>> # 或同样的事情：
>>> r2chi1_index == r2chi1_object.ndx
真的
>>> 打印(圆(myCic.dihedraAngle[r2chi1_index], 2))
-144.86
>>> # 还有：
>>> r2chi1_object == myCic.dihedra[r2chi1_key]
真的

>>> # hedra 角度相似：
>>> r2tau = r2ic.pick_angle("tau")
>>> 打印(圆(myCic.hedraAngle[r2tau.ndx], 2))
113.45
```

在Chain级别获取键长数据更加复杂（不推荐）。如此处所示，多个 hedra 将在不同位置共享一个键：

```
>>> r2CaCb = r2ic.pick_length("CA:CB") # 返回包含键的面体列表
>>> r2CaCb[0][0].atomkeys
(152_D_CB, 152_D_CA, 152_D_C)
>>> print(round(myCic.hedraL12[r2CaCb[0][0].ndx], 2)) # 位置 1-2
1.53
>>> r2CaCb[0][1].atomkeys
(152_D_N, 152_D_CA, 152_D_CB)
>>> print(round(myCic.hedraL23[r2CaCb[0][1].ndx], 2)) # 位置 2-3
1.53
>>> r2CaCb[0][2].atomkeys
(152_D_CA, 152_D_CB, 152_D_CG)
>>> print(round(myCic.hedraL12[r2CaCb[0][2].ndx], 2)) # 位置 1-2
1.53
```

请改用Residue level set_length函数。

### 11.6.4.2 完整性测试结构

重建结构时，缺少原子和其他问题可能会导致问题。使用structure_rebuild_test快速确定结构是否有足够的数据进行干净重建。添加verbose=True和/或检查结果字典以获取更多详细信息：

```
>>> # 检查 myChain 是否有意义（可以获取角度并重建相同的结构）
>>> resultDict = structure_rebuild_test(myChain)
>>> resultDict[“通过”]
真的
```

### 11.6.4.3 修改和重建结构

最好使用剩余级别的set_angle和set_length工具来修改内部坐标，而不是直接访问Chain结构。虽然直接修改面体角度是安全的，但如上所述，键长出现在多个重叠的面体中，这由set_length处理。当应用于二面角时，set_angle会将结果包裹到 +/-180 并旋转相邻的二面角（例如异亮氨酸*chi1*角的两个键 - 这可能是您想要的）。

```
>>> # 将残差 2 chi1 的角度旋转 -120 度
>>> r2ic.set_angle("chi1", r2chi1 - 120.0)
>>> 打印（圆（r2ic.get_angle（“chi1”），2））
95.14
>>> r2ic.set_length("CA:CB", 1.49)
>>> print(round(myCic.hedraL12[r2CaCb[0][0].ndx], 2)) # Cb-Ca-C 位置 1-2
1.49
```

从内部坐标重建结构是对internal_to_atom_coordinates的简单调用：

```
>>> myChain.internal_to_atom_coordinates()

>>> # 只是为了证明：
>>> myChain.internal_coord = None # 删除所有内部坐标数据，只剩下原子
>>> myChain.atom_to_internal_coordinates() # 重新生成内部坐标
>>> r2ic = myChain.child_list[1].internal_coord
>>> print(round(r2ic.get_angle("chi1"), 2)) # 显示测量值与上面设置的相匹配
95.14
>>> print(round(myCic.hedraL23[r2CaCb[0][1].ndx], 2)) # N-Ca-Cb 位置 2-3
1.49
```

生成的结构可以像往常一样用 PDBIO 写入：

```
write_PDB(myProtein, "myChain.pdb")
# 或者只是没有标题的 ATOM 记录：
io = PDBIO()
io.set_structure（我的蛋白质）
io.save("myChain2.pdb")
```

### 11.6.4.4 蛋白质内坐标 (.pic) 文件和默认值

PICIO模块中定义了一种文件格式，用于将蛋白质链描述为相对于初始坐标的面角和二面角。文件中除残基序列信息（eg ('1A8O', 0, 'A', (' ', 153, ' ')) ILE ）之外的所有部分都是可选的，如果不指定将使用默认值填充并且使用defaults=True选项调用read_PIC。默认值是从 2019 年 9 月 Dunbrack cullpdb_pc20_res2.2_R1.0 开始计算的。

在这里，我们将“myChain”写为内部坐标规范的.pic文件，然后将其作为“myProtein2”读回。

```
# 将链写入“蛋白质内部坐标”（.pic）文件
write_PIC(myProtein, "myChain.pic")
# 读取.pic文件
myProtein2 = read_PIC("myChain.pic")
```

由于所有内部坐标值都可以用默认值替换，因此PICIO.read_PIC_seq作为实用函数提供，用于从输入序列创建有效（主要是螺旋）默认结构：

```
# 通过读取 .pic 文件为随机序列创建默认结构
myProtein3 = read_PIC_seq(
    序列记录(
        Seq("GAVLIMFPSTCNQYWDEHKR"),
        id="1RND",
        description="我的随机序列",
    )
)
myProtein3.internal_to_atom_coordinates()
write_PDB(myProtein3, "myRandom.pdb")
```

当从内部坐标生成结构时，探索*欧米茄*角 (180.0)、面体角和/或键长等方面所需的精度可能很有趣。write_PIC的 picFlags 选项启用此功能，允许选择要写入 .pic 文件的数据，而不是未指定的数据以获取默认值。

各种组合都是可能的，并且提供了一些预设，例如经典将只写入*psi、phi、tau*、脯氨酸*omega*和侧链*chi*角度到 .pic 文件：

```
write_PIC(myProtein, "myChain.pic", picFlags=IC_Residue.pic_flags.classic)
myProtein2 = read_PIC("myChain.pic", defaults=True)
```

### 11.6.4.5 访问全原子 AtomArray

Biopython Atom对象中的所有 3D XYZ 坐标都被移动到Chain类中的单个大数组，并在atom_to_internal_coordinates的早期步骤中被 Numpy 'views' 替换到这个数组中。访问 Biopython Atom坐标的软件不受影响，但新阵列可能会提高未来工作的效率。

与Atom XYZ 坐标不同，AtomArray坐标是齐次的，这意味着它们是类似于[ xyz 1.0] 的数组，其中 1.0 作为第四个元素。这有助于在整个internal_coords模块中使用组合的平移和旋转矩阵进行有效转换。有一个相应的AtomArrayIndex字典，将AtomKeys映射到它们的坐标。

在这里，我们演示了从数组中读取特定 Cβ 原子的坐标，然后显示修改数组值会同时修改Atom对象：

```
>>> # 访问链中所有原子的数组，例如上面的 r2 是残基 152 C-beta
>>> r2_cBeta_index = myChain.internal_coord.atomArrayIndex[AtomKey("152_D_CB")]
>>> r2_cBeta_coords = myChain.internal_coord.atomArray[r2_cBeta_index]
>>> 打印（np.round（r2_cBeta_coords，2））
[-0.75 -1.18 -0.51 1.]

>>> # Biopython Atom 坐标数组现在是 atomArray 的一个视图，所以
>>> 断言 r2_cBeta_coords[1] == r2["CB"].coord[1]
>>> r2_cBeta_coords[1] += 1.0 # 改变 Y 坐标 1 埃
>>> 断言 r2_cBeta_coords[1] == r2["CB"].coord[1]
>>> # 它们总是相同的（它们共享相同的内存）
>>> r2_cBeta_coords[1] -= 1.0 # 恢复
```

请注意，很容易“断开”Atom 坐标数组和链 atomArray 之间的视图链接。直接修改 Atom 坐标时，使用逐个元素复制的语法来避免这种情况：

```
# 使用这些：
myAtom1.coord[:] = myAtom2.coord
myAtom1.coord[...] = myAtom2.coord
myAtom1.coord[:] = [1, 2, 3]
对于我在范围内（3）：
    myAtom1.coord[i] = myAtom2.coord[i]

＃ 不使用：
myAtom1.coord = myAtom2.coord
myAtom1.coord = [1, 2, 3]
```

使用atomArrayIndex和AtomKey类的知识使我们能够创建 Numpy“选择器”，如下所示，以提取仅包含 Cα 原子坐标的数组：

```
>>> # 创建一个选择器来过滤所有原子数组中的 C-alpha 原子
>>> atmNameNdx = AtomKey.fields.atm
>>> aaI = myChain.internal_coord.atomArrayIndex
>>> CaSelect = [aaI.get(k) for k in aaI.keys() if k.akl[atmNameNdx] == "CA"]
>>> # 现在 C-alpha 原子坐标的有序数组是：
>>> CA_coords = myChain.internal_coord.atomArray[CaSelect]
>>> # 注意这使用了 Numpy 花式索引，所以 CA_coords 是一个新副本
>>> #（如果你修改它，原来的atomArray不受影响）
```

### 11.6.4.6 距离图

atomArray的一个好处是从它生成距离图是一行Numpy代码：

```
numpy.linalg.norm(atomArray[:, None, :] - atomArray[None, :, :], axis=-1)
```

尽管它很简短，但成语 cam be hard to remember 并且在上面的表格中生成全原子距离而不是可能需要的经典 Cα 图。distance_plot方法将上面的行换行并接受一个可选的选择器，如上一节中定义的CaSelect 。参见图[‍11.2](https://biopython-org.translate.goog/DIST/docs/tutorial/Tutorial.html?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN&_x_tr_pto=wapp&_x_tr_sch=http#fig%3Adistanceplot)。

> ------
>
> ```
> # 创建一个 C-alpha 距离图
> caDistances = myChain.internal_coord.distance_plot(CaSelect)
> # 使用 MatPlotLib 等显示：
> 将 matplotlib.pyplot 导入为 plt
> 
> plt.imshow(caDistances, cmap="hot", interpolation="nearest")
> plt.show()
> ```
>
> ![img](https://translate.google.com/website?sl=auto&tl=zh-CN&hl=zh-CN&client=webapp&u=http://biopython.org/DIST/docs/tutorial/images/1a8o-ca-plot.png)
>
> 图 11.2：PDB 文件 1A8O 的 Cα 距离图（HIV 衣壳 C 末端域）
>
> 
>
> ------

### 11.6.4.7 从距离图构建结构

全原子距离图是蛋白质结构的另一种表示，也不受平移和旋转的影响，但缺乏手性信息（镜像结构将生成相同的距离图）。通过将距离矩阵与每个二面角的符号相结合，可以重新生成内部坐标。

这项工作使用由 Blue（Hedronometer）开发的方程式，在[https://math.stackexchange.com/a/49340/409](https://translate.google.com/website?sl=auto&tl=zh-CN&hl=zh-CN&client=webapp&u=https://math.stackexchange.com/a/49340/409)和[http://daylateanddollarshort.com/mathdocs/Heron-like-Results-for-Tetrahedral中进一步讨论-Volume.pdf](https://translate.google.com/website?sl=auto&tl=zh-CN&hl=zh-CN&client=webapp&u=http://daylateanddollarshort.com/mathdocs/Heron-like-Results-for-Tetrahedral-Volume.pdf)。

首先，我们从“myChain”中提取距离和手性值：

```
>>> # 从距离图构建结构：

>>> ## 创建全原子距离图
>>> 距离 = myCic.distance_plot()
>>> ## 获取二面角的符号
>>> 手性 = myCic.dihedral_signs()
```

我们需要一个匹配“myChain”的有效数据结构来正确重建它；在一般情况下使用上面的read_PIC_seq是可行的，但此处使用的 1A8O 示例具有一些 ALTLOC 复杂性，单独使用序列不会生成。为了演示，最简单的方法是简单地复制“myChain”结构，但我们将所有原子和内部坐标链数组设置为 0（仅用于演示），以确保没有数据来自原始结构：

```
>>> ## 获取新的空数据结构：从 myChain 复制数据结构
>>> myChain2 = IC_duplicate(myChain)[0]["A"]
>>> cic2 = myChain2.internal_coord

>>> ## 清除新的 atomArray 和 di/hedra 值数组，只是为了证明
>>> cic2.atomArray = np.zeros((cic2.AAsiz, 4), dtype=np.float64)
>>> cic2.dihedraAngle[:] = 0.0
>>> cic2.hedraAngle[:] = 0.0
>>> cic2.hedraL12[:] = 0.0
>>> cic2.hedraL23[:] = 0.0
```

方法是从距离图数据重新生成内部坐标，然后从内部坐标生成原子坐标，如上所示。为了将最终生成的结构放置在与起始结构相同的坐标空间中，我们仅将前三个 N-Cα-C 原子的坐标从“myChain”的链起点复制到“myChain2”结构（这只是需要的最后证明等价）：

```
>>> ## 只复制第一个 N-Ca-C 坐标，这样结构就会叠加：
>>> cic2.copy_initNCaCs(myChain.internal_coord)
```

distance_to_internal_coordinates例程需要目标结构的每个二面体的六个原子间距离的数组。便利例程distplot_to_dh_arrays根据需要从先前生成的距离矩阵中提取这些值，并且可以由用户方法替换以将这些数据写入 Chain.internal_coords 对象中的数组。

```
>>> ## 将距离复制到链数组：
>>> cic2.distplot_to_dh_arrays（距离，手性）
>>> ## 根据距离计算角度和二面角：
>>> cic2.distance_to_internal_coordinates()
```

下面的步骤从新生成的“myChain2”内部坐标生成原子坐标，然后使用 Numpy allclose例程确认所有值都比 PDB 文件分辨率匹配：

```
>>> ## 从内部坐标生成 XYZ 坐标：
>>> myChain2.internal_to_atom_coordinates()
>>> ## 确认结果 atomArray 匹配原始结构：
>>> np.allclose(cic2.atomArray, myCic.atomArray)
真的
```

请注意，此过程不使用整个距离矩阵，而仅使用每个二面角的四个原子之间的六个局部距离。

### 11.6.4.8 叠加残差及其邻域

internal_coords模块依赖于在不同坐标空间之间转换原子坐标来计算扭转角和重建结构。每个二面体都有一个坐标空间变换，将其第一个原子放在 XZ 平面上，第二个原子放在原点，第三个原子放在 +Z 轴上，以及一个相应的反向变换，将其返回到原始结构中的坐标。这些变换矩阵可供使用，如下所示。通过明智地选择参考二面体，可以跨多个蛋白质结构研究和可视化成对和高阶残基相互作用，例如图[11.3](https://biopython-org.translate.goog/DIST/docs/tutorial/Tutorial.html?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN&_x_tr_pto=wapp&_x_tr_sch=http#fig%3Aphepairs)。

> ![img](https://translate.google.com/website?sl=auto&tl=zh-CN&hl=zh-CN&client=webapp&u=http://biopython.org/DIST/docs/tutorial/images/phe-pairs-3pbl.png)
>
> 图 11.3：PDB 文件 3PBL（人类多巴胺 D3 受体）中的相邻苯丙氨酸侧链

此示例将链中的每个 PHE 残基叠加在其 N-Cα-Cβ 原子上，并将链中的所有 PHE 呈现在各自的坐标空间中作为简单演示。对成对侧链交互的更现实的探索将检查结构数据集并筛选交互类，如相关文献中所述。

```
# 叠加所有 phe-phe 对 - 快速破解只是为了演示概念
# 用于分析成对残基相互作用。生成 PDB ATOM 记录
# 将每个 PHE 放在原点并显示环境中的所有其他 PHE

## 关键变量的简写：
cic = myChain.internal_coord
resNameNdx = AtomKey.fields.resname
aaNdx = cic.atomArrayIndex

## 只选择 PHE 原子：
pheAtomSelect = [aaNdx.get(k) for k in aaNdx.keys() if k.akl[resNameNdx] == "F"]
aaF = cic.atomArray[pheAtomSelect] # numpy 花式索引使 COPY 无法查看

对于 cic.ordered_aa_ic_list 中的 ric：# get_residues() 的 internal_coords 版本
    if ric.lc == "F": # 如果是 PHE，获取 chi1 二面角的变换矩阵
        chi1 = ric.pick_angle("chi1") # N:CA:CB:CG 空间原点有 C-alpha
        cst = np.transpose(chi1.cst) # 变换到chi1空间
        # rcst = np.transpose(chi1.rcst) # 从 chi1 空间变换（这里不需要）
        cic.atomArray[pheAtomSelect] = aaF.dot(cst) # 只转换 PHE
        for res in myChain.get_residues(): # 在新的坐标空间中打印 PHE
            如果 res.resname 在 ["PHE"] 中：
                打印（res.internal_coord.pdb_residue_string（））
        cic.atomArray[pheAtomSelect] = aaF # 从副本恢复坐标空间
```

### 11.6.4.9 3D 打印蛋白质结构

OpenSCAD ( [https://openscad.org](https://translate.google.com/website?sl=auto&tl=zh-CN&hl=zh-CN&client=webapp&u=https://openscad.org) ) 是一种用于创建实体 3D CAD 对象的语言。从内部坐标构建蛋白质结构的算法在 OpenSCAD 中提供，带有描述结构的数据，因此可以生成适合 3D 打印的模型。虽然其他软件可以生成 STL 数据作为 3D 打印的渲染选项（例如 Chimera，[https://www.cgl.ucsf.edu/chimera/](https://translate.google.com/website?sl=auto&tl=zh-CN&hl=zh-CN&client=webapp&u=https://www.cgl.ucsf.edu/chimera/)），但这种方法生成球体和圆柱体作为输出，因此更适合相关修改到 3D 打印蛋白质结构。可以在 OpenSCAD 代码中选择单个残基和键进行特殊处理，例如按大小突出显示或在特定位置添加可旋转键（参见[https://www.thingiverse.com/thing:3957471](https://translate.google.com/website?sl=auto&tl=zh-CN&hl=zh-CN&client=webapp&u=https://www.thingiverse.com/thing:3957471)举个例子）。

```
# 编写球体和圆柱体的 OpenSCAD 程序以 3d 打印 myChain 主干
## 设置原子加载过滤器只接受主干：
IC_Residue.accept_atoms = IC_Residue.accept_backbone
## 将断链截止值设置得非常高，以用长键桥接缺失的残基
IC_Chain.MaxPeptideBond = 4.0
## 删除现有数据以强制重新读取具有上述属性设置的所有原子：
myChain.internal_coord = 无
write_SCAD(myChain, "myChain.scad", scale=10.0)
```

### 11.6.4.10  internal_coords控制属性

internal_coords类中有一些控制属性可用于在计算内部坐标时修改或过滤数据。这些列于表[‍11.1](https://biopython-org.translate.goog/DIST/docs/tutorial/Tutorial.html?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN&_x_tr_pto=wapp&_x_tr_sch=http#table%3Aic-attribs)：

> ------
>
> | 班级      | 属性            | 默认          | 影响                                                         |
> | --------- | --------------- | ------------- | ------------------------------------------------------------ |
> | 原子键    | d2h             | 错误的        | 如果为真，则将 D 原子转换为 H                                |
> | IC_链     | 最大肽键        | 1.4           | 最大 CN 长度 w/o 断链；变大以链接 3D 模型的缺失残基          |
> | IC_残留物 | 接受原子        | 主链，氢原子  | 覆盖以删除部分或所有侧链、H、D                               |
> |           | accept_resnames | CYG、YCM、UNK | HETATM 要处理的 3 个字母的名称，除非添加到 ic_data.py 中，否则仅用于主干 |
> |           | gly_Cbeta       | 错误的        | 覆盖以根据数据库平均值生成 Gly Cβ 原子                       |
> |           |                 |               |                                                              |
>
> 表 11.1：Bio.PDB.internal_coords 中的控制属性。
>
> 
>
> ------

## 11.6.5 确定原子-原子接触

使用NeighborSearch执行邻居查找。邻居查找是使用用 C 编写的 KD 树模块完成的（请参阅模块Bio.PDB.kdtrees中的KDTree类），使其速度非常快。它还包括一种快速查找彼此一定距离内的所有点对的方法。

## 11.6.6 叠加两个结构

使用Superimposer对象叠加两个坐标集。该对象计算旋转和平移矩阵，该矩阵以最小化 RMSD 的方式旋转两个原子列表。当然，这两个列表需要包含相同数量的原子。Superimposer对象还可以将旋转/平移应用于原子列表。旋转和平移作为元组存储在Superimposer对象的rotran属性中（注意旋转是右乘！）。RMSD 存储在rmsd属性中。

Superimposer使用的算法来自 [ [19](https://biopython-org.translate.goog/DIST/docs/tutorial/Tutorial.html?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN&_x_tr_pto=wapp&_x_tr_sch=http#golub1989) , Golub & Van Loan] 并利用奇异值分解（这是在通用Bio.SVDSuperimposer模块中实现的）。

例子：

```
>>> sup = 叠加器()
# 指定原子列表
# 'fixed' 和 'moving' 是 Atom 对象的列表
# 移动的原子将放在固定的原子上
>>> sup.set_atoms（固定，移动）
# 打印旋转/平移/rmsd
>>> 打印（sup.rotran）
>>> 打印（sup.rms）
# 对移动的原子应用旋转/平移
>>> sup.apply（移动）
```

要根据活性位点叠加两个结构，请使用活性位点原子计算旋转/平移矩阵（如上所述），并将这些应用于整个分子。

## 11.6.7 将两个相关结构的残基相互映射

首先，创建一个 FASTA 格式的比对文件，然后使用StructureAlignment类。此类也可用于具有两个以上结构的比对。

## 11.6.8 计算半球曝光

半球曝光 (HSE) 是一种新的二维溶剂曝光测量 [ [22](https://biopython-org.translate.goog/DIST/docs/tutorial/Tutorial.html?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN&_x_tr_pto=wapp&_x_tr_sch=http#hamelryck2005) ]。基本上，它计算残基周围沿其侧链方向以及相反方向（13 Å 半径内）的 Cα 原子数。尽管它很简单，但它优于许多其他溶剂暴露措施。

HSE 有两种类型：HSEα 和 HSEβ。前者仅使用Cα原子位置，而后者使用Cα和Cβ原子位置。HSE 度量由HSExposure类计算，该类还可以计算联系电话号码。后一类具有返回字典的方法，这些字典将Residue对象映射到其相应的 HSEα、HSEβ 和联系号码值。

例子：

```
>>> 模型 = 结构[0]
>>> hse = HSExposure()
# 计算 HSEalpha
>>> exp_ca = hse.calc_hs_exposure（模型，选项=“CA3”）
# 计算 HSEbeta
>>> exp_cb = hse.calc_hs_exposure(模型, option="CB")
# 计算经典配位数
>>> exp_fs = hse.calc_fs_exposure(模型)
# 为残基打印 HSEalpha
>>> 打印（exp_ca[some_residue]）
```

## 11.6.9 确定二级结构

对于此功能，您需要安装 DSSP（并获得它的许可证——学术用途免费，请参阅[https://swift.cmbi.umcn.nl/gv/dssp/](https://translate.google.com/website?sl=auto&tl=zh-CN&hl=zh-CN&client=webapp&u=https://swift.cmbi.umcn.nl/gv/dssp/)）。然后使用DSSP类，它将Residue对象映射到它们的二级结构（和可访问的表面积）。表[11.2](https://biopython-org.translate.goog/DIST/docs/tutorial/Tutorial.html?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN&_x_tr_pto=wapp&_x_tr_sch=http#table%3ADSSP-codes)。请注意，DSSP（程序，因此是类）不能处理多个模型！

> ------
>
> | 代码 | 二级结构        |
> | ---- | --------------- |
> | H    | α-螺旋          |
> | 乙   | 分离的 β 桥残基 |
> | 乙   | 钢绞线          |
> | G    | 3-10螺旋        |
> | 我   | Π-螺旋          |
> | 吨   | 转动            |
> | 小号 | 弯曲            |
> | -    | 其他            |
>
> 表 11.2：Bio.PDB 中的 DSSP 代码。
>
> 
>
> ------

DSSP类也可用于计算残留物的可及表面积。但另见第[11.6.10](https://biopython-org.translate.goog/DIST/docs/tutorial/Tutorial.html?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN&_x_tr_pto=wapp&_x_tr_sch=http#sec%3Aresidue_depth)节。

## 11.6.10 计算残留深度



残留深度是残留原子与溶剂可及表面的平均距离。这是一种相当新颖且非常强大的溶剂可及性参数化。对于此功能，您需要安装 Michel Sanner 的 MSMS 程序 ( [https://www.scripps.edu/sanner/html/msms_home.html](https://translate.google.com/website?sl=auto&tl=zh-CN&hl=zh-CN&client=webapp&u=https://www.scripps.edu/sanner/html/msms_home.html) )。然后使用ResidueDepth类。这个类的行为就像一个字典，它将残差对象映射到相应的（残差深度，Cα深度）元组。Cα 深度是残基的 Cα 原子到溶剂可及表面的距离。

例子：

```
>>> 模型 = 结构[0]
>>> rd = ResidueDepth（模型，pdb_file）
>>> residue_depth, ca_depth = rd[some_residue]
```

您还可以访问分子表面本身（通过get_surface函数），以带有表面点的 Python 数值数组的形式。

# 11.7 PDB文件中的常见问题

众所周知，许多 PDB 文件包含语义错误（不是结构本身，而是它们在 PDB 文件中的表示）。Bio.PDB 尝试以两种方式处理这个问题。PDBParser 对象可以以两种方式运行：限制方式和允许方式，这是默认方式。

例子：

```
# 许可解析器
>>> 解析器 = PDBParser(PERMISSIVE=1)
>>> parser = PDBParser() # 相同（默认）
# 严格解析器
>>> strict_parser = PDBParser(PERMISSIVE=0)
```

在允许状态（DEFAULT）下，明显包含错误的 PDB 文件被“更正”（即一些残基或原子被排除在外）。这些错误包括：

- 具有相同标识符的多个残基
- 具有相同标识符的多个原子（考虑到 altloc 标识符）

这些错误表明 PDB 文件中存在真正的问题（有关详细信息，请参阅 [ [20](https://biopython-org.translate.goog/DIST/docs/tutorial/Tutorial.html?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN&_x_tr_pto=wapp&_x_tr_sch=http#hamelryck2003a)，Hamelryck 和 Manderick，2003 年]）。在限制状态下，有错误的PDB文件会导致异常发生。这对于查找 PDB 文件中的错误很有用。

但是，某些错误会自动更正。通常每个无序原子都应该有一个非空的 altloc 标识符。然而，有许多结构不遵循此约定，并且具有用于同一原子的两个无序位置的空白和非空白标识符。这会以正确的方式自动解释。

有时，一个结构包含一系列属于 A 链的残基，然后是属于 B 链的残基，然后又是属于 A 链的残基，即这些链是“断裂的”。这也被正确解释。

## 11.7.1 例子



PDBParser/Structure 类在大约 800 个结构上进行了测试（每个结构都属于一个独特的 SCOP 超家族）。这大约需要 20 分钟，或者每个结构平均需要 1.5 秒。解析包含大约 64000 个原子的大核糖体亚基 (1FKK) 的结构，在 1000 MHz PC 上需要 10 秒。

在无法构建明确的数据结构的情况下会生成三个异常。在所有这三种情况下，可能的原因是应该更正 PDB 文件中的错误。在这些情况下生成异常比冒着错误描述数据结构中结构的机会要好得多。

### 11.7.1.1 重复残基

一种结构在一条链中包含两个氨基酸残基，具有相同的序列标识符 (resseq 3) 和 icode。经检查，发现该链包含残基 Thr A3、…、Gly A202、Leu A3、Glu A204。显然，Leu A3 应该是 Leu A203。对于结构 1FFK（例如包含 Gly B64、Met B65、Glu B65、Thr B67，即残基 Glu B65 应该是 Glu B66）存在一些类似的情况。

### 11.7.1.2 重复原子

结构 1EJG 在链 A 的第 22 位包含一个 Ser/Pro 点突变。反过来，Ser 22 包含一些无序原子。正如预期的那样，属于 Ser 22 的所有原子都有一个非空白的 altloc 说明符（B 或 C）。Pro 22 的所有原子都有 altloc A，除了 N 原子有一个空白的 altloc。这会产生一个异常，因为在一个点突变处属于两个残基的所有原子都应该有非空白的 altloc。事实证明，这个原子可能由 Ser 和 Pro 22 共享，因为 Ser 22 缺少 N 原子。同样，这指出了文件中的一个问题：N 原子应该出现在 Ser 和 Pro 残基中，在这两种情况下都与合适的 altloc 标识符相关联。

## 11.7.2 自动校正

有些错误很常见，可以很容易地纠正，而不会有很大的错误解释风险。下面列出了这些案例。

### 11.7.2.1 无序原子的空白 altloc

通常每个无序原子都应该有一个非空的 altloc 标识符。然而，有许多结构不遵循此约定，并且具有用于同一原子的两个无序位置的空白和非空白标识符。这会以正确的方式自动解释。

### 11.7.2.2 断链

有时，一个结构包含一系列属于 A 链的残基，然后是属于 B 链的残基，然后又是属于 A 链的残基，即链是“断裂的”。这是正确的解释。

## 11.7.3 致命错误

有时无法明确解释 PDB 文件。与其猜测和冒犯错的风险，不如生成一个异常，并且期望用户更正 PDB 文件。下面列出了这些案例。

### 11.7.3.1 重复残基

一条链中的所有残基都应该有一个唯一的 ID。此 ID 是基于以下内容生成的：

- 序列标识符 (resseq)。
- 插入代码 (icode)。
- hetfield 字符串（“W”代表水域，“H_”后跟其他异质残基的残基名称）
- 点突变情况下残基的残基名称（将 Residue 对象存储在 DisorderedResidue 对象中）。

如果这不会导致唯一的 id，则很可能是错误的，并且会生成异常。

### 11.7.3.2 重复原子

残基中的所有原子都应该有一个唯一的 ID。此 ID 是基于以下内容生成的：

- 原子名称（没有空格，如果出现问题则有空格）。
- altloc 说明符。

如果这不会导致唯一的 id，则很可能是错误的，并且会生成异常。

# 11.8 访问蛋白质数据库

## 11.8.1 从蛋白质数据库下载结构

通过在PDBList对象上使用retrieve_pdb_file方法，可以从 PDB（蛋白质数据库）下载结构。此方法的参数是结构的 PDB 标识符。

```
>>> pdbl = PDBList()
>>> pdbl.retrieve_pdb_file("1FAT")
```

PDBList类也可以用作命令行工具：

```
python PDBList.py 1fat
```

下载的文件将称为pdb1fat.ent并存储在当前工作目录中。请注意，retrieve_pdb_file方法还有一个可选参数pdir，它指定用于存储下载的 PDB 文件的特定目录。

retrieve_pdb_file方法也有一些选项来指定用于下载的压缩格式，以及用于本地解压缩的程序（默认.Z格式和gunzip）。此外，可以在创建PDBList对象时指定 PDB ftp 站点。默认情况下，使用Worldwide Protein Data Bank ( [ftp://ftp.wwpdb.org/pub/pdb/data/structures/divided/pdb/](https://translate.google.com/website?sl=auto&tl=zh-CN&hl=zh-CN&client=webapp&u=ftp://ftp.wwpdb.org/pub/pdb/data/structures/divided/pdb/) )的服务器。有关详细信息，请参阅 API 文档。再次感谢 Kristian Rother 捐赠此模块。

## 11.8.2 下载整个 PDB

以下命令会将所有 PDB 文件存储在/data/pdb目录中：

```
python PDBList.py 所有/数据/pdb

python PDBList.py all /data/pdb -d
```

此 API 方法称为download_entire_pdb。添加-d选项会将所有文件存储在同一目录中。否则，将根据它们的 PDB ID 将它们分类到 PDB 样式的子目录中。根据流量，完整下载需要 2-4 天。

## 11.8.3 使 PDB 的本地副本保持最新

这也可以使用PDBList对象来完成。只需创建一个PDBList对象（指定 PDB 的本地副本所在的目录）并调用update_pdb方法：

```
>>> pl = PDBList(pdb="/data/pdb")
>>> pl.update_pdb()
```

人们当然可以从中创建一个每周一次的cronjob，以保持本地副本自动更新。也可以指定 PDB ftp 站点（请参阅 API 文档）。

PDBList有一些额外的方法可以使用。get_all_obsolete方法可用于获取所有过时 PDB 条目的列表。changed_this_week方法可用于获取本周添加、修改或废弃的条目。有关PDBList的可能性的更多信息，请参阅 API 文档。

# 11.9 一般问题

## 11.9.1 Bio.PDB 的测试情况如何？

很好，实际上。Bio.PDB 已经对来自 PDB 的近 5500 个结构进行了广泛测试——所有结构似乎都被正确解析。可以在 Bio.PDB 生物信息学文章中找到更多详细信息。Bio.PDB 已经/正在许多研究项目中作为可靠的工具使用。事实上，我几乎每天都在使用 Bio.PDB 进行研究，并继续致力于改进它并添加新功能。

## 11.9.2 有多快？

PDBParser性能在大约 800 个结构上进行了测试（每个结构都属于一个独特的 SCOP 超家族）。这大约需要 20 分钟，或者每个结构平均需要 1.5 秒。解析包含大约 64000 个原子的大核糖体亚基 (1FKK) 的结构，在 1000 MHz PC 上需要 10 秒。简而言之：它对于许多应用来说已经足够快了。

## 11.9.3 是否支持分子图形？

不是直接的，主要是因为已经有相当多的基于 Python/Python 的解决方案，它们可以与 Bio.PDB 一起使用。我的选择是 Pymol，顺便说一句（我已经在 Bio.PDB 中成功地使用了它，并且可能很快/有一天在 Bio.PDB 中会有特定的 PyMol 模块）。基于 Python/感知的分子图形解决方案包括：

- PyMol： https: [//pymol.org/](https://translate.google.com/website?sl=auto&tl=zh-CN&hl=zh-CN&client=webapp&u=https://pymol.org/)
- 嵌合体：https: [//www.cgl.ucsf.edu/chimera/](https://translate.google.com/website?sl=auto&tl=zh-CN&hl=zh-CN&client=webapp&u=https://www.cgl.ucsf.edu/chimera/)
- PMV： http: [//www.scripps.edu/~sanner/python/](https://translate.google.com/website?sl=auto&tl=zh-CN&hl=zh-CN&client=webapp&u=http://www.scripps.edu/~sanner/python/)
- 库特：[https://www2.mrc-lmb.cam.ac.uk/personal/pemsley/coot/](https://translate.google.com/website?sl=auto&tl=zh-CN&hl=zh-CN&client=webapp&u=https://www2.mrc-lmb.cam.ac.uk/personal/pemsley/coot/)
- CCP4mg：[http://www.ccp4.ac.uk/MG/](https://translate.google.com/website?sl=auto&tl=zh-CN&hl=zh-CN&client=webapp&u=http://www.ccp4.ac.uk/MG/)
- mmLib： http: [//pymmlib.sourceforge.net/](https://translate.google.com/website?sl=auto&tl=zh-CN&hl=zh-CN&client=webapp&u=http://pymmlib.sourceforge.net/)
- VMD： https: [//www.ks.uiuc.edu/Research/vmd/](https://translate.google.com/website?sl=auto&tl=zh-CN&hl=zh-CN&client=webapp&u=https://www.ks.uiuc.edu/Research/vmd/)
- MMTK： http: [//dirac.cnrs-orleans.fr/MMTK/](https://translate.google.com/website?sl=auto&tl=zh-CN&hl=zh-CN&client=webapp&u=http://dirac.cnrs-orleans.fr/MMTK/)

## 11.9.4 谁在使用 Bio.PDB？

Bio.PDB 用于构建 DISEMBL，这是一种预测蛋白质无序区域的网络服务器 ( [http://dis.embl.de/](https://translate.google.com/website?sl=auto&tl=zh-CN&hl=zh-CN&client=webapp&u=http://dis.embl.de/) )。Bio.PDB 还被用于对 PDB 中蛋白质结构之间的活性位点相似性进行大规模搜索 [ [21](https://biopython-org.translate.goog/DIST/docs/tutorial/Tutorial.html?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN&_x_tr_pto=wapp&_x_tr_sch=http#hamelryck2003b)，Hamelryck，2003]，并开发一种识别线性二级结构元素的新算法 [ [33](https://biopython-org.translate.goog/DIST/docs/tutorial/Tutorial.html?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN&_x_tr_pto=wapp&_x_tr_sch=http#majumdar2005)，Majumdar*等人。*, 2005].

从对功能和信息的要求来看，Bio.PDB 也被多家 LPC（大型制药公司 :-）使用。