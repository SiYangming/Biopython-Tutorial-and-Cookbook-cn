Bio.Phylo模块是在Biopython 1.54中引入的。继SeqIO和AlignIO之后，它的目的是提供一种通用的方法来处理系统发育树，而不受源数据格式的影响，并为I/O操作提供一个一致的API。

Bio.Phylo在一篇公开发表的期刊文章[[9](http://biopython.org/DIST/docs/tutorial/Tutorial.html#talevich2012)，Talevich等人，2012]中进行了描述，你可能也会觉得有帮助。

# 13.1 演示：树上有什么？

为了熟悉这个模块，让我们从一个已经构建好的树开始，用几种不同的方式来检查它。然后我们将对树枝进行着色，以使用一个特殊的phyloXML功能，最后保存它。

用你最喜欢的文本编辑器创建一个名为simple.dnd的简单Newick文件，或者使用Biopython源代码中提供的[simple.dnd](https://translate.google.com/website?sl=auto&tl=zh-CN&hl=zh-CN&client=webapp&u=https://raw.githubusercontent.com/biopython/biopython/master/Doc/examples/simple.dnd)：

```python
(((A,B),(C,D)),(E,F,G));
```

这棵树没有分支长度，只有一个拓扑结构和标记的终端。(如果你有一个真正的树文件，你可以用它来代替这个演示。)

启动您选择的 Python 解释器：

```bash
$ ipython -pylab
```

对于交互式工作，用`-pylab`标志启动IPython解释器，可以实现**matplotlib**的集成，所以图形会自动弹出。我们将在这个演示中使用它。

现在，在 Python 中，读取树文件，给出文件名和格式名称。

```python
>>> from Bio import Phylo
>>> tree = Phylo.read("simple.dnd", "newick")
```

将树形对象打印成字符串，我们就可以看到整个对象的层次结构。

```python
>>> print(tree)
Tree(rooted=False, weight=1.0)
    Clade()
        Clade()
            Clade()
                Clade(name='A')
                Clade(name='B')
            Clade()
                Clade(name='C')
                Clade(name='D')
        Clade()
            Clade(name='E')
            Clade(name='F')
            Clade(name='G')
```

Tree对象包含关于树的全局信息，比如它是有根的还是无根的。它有一个根系，在根系之下，是一直到树梢的嵌套的树系列表。

函数`draw_ascii`创建了一个简单的ASCII-art（纯文本）树状图。在没有更好的图形工具的情况下，这是一个方便的可视化互动探索。

```python
>>> from Bio import Phylo
>>> tree = Phylo.read("simple.dnd", "newick")
>>> Phylo.draw_ascii(tree)
                                                    ________________________ A
                           ________________________|
                          |                        |________________________ B
  ________________________|
 |                        |                         ________________________ C
 |                        |________________________|
_|                                                 |________________________ D
 |
 |                         ________________________ E
 |                        |
 |________________________|________________________ F
                          |
                          |________________________ G
<BLANKLINE>
```

如果你安装了**matplotlib**或**pylab**，你可以使用`draw`函数创建一个图形（见[图13.1](http://biopython.org/DIST/docs/tutorial/Tutorial.html#fig%3Aphylo-simple-draw)）：

```python
>>> tree.rooted = True
>>> Phylo.draw(tree)
```

![img](http://biopython.org/DIST/docs/tutorial/images/phylo-simple-draw.png)

## 13.1.1 为树中的分支着色

函数`draw`支持在树中显示不同的颜色和分支宽度。从Biopython 1.59开始，`color`和`width`属性在基本的Clade对象上是可用的，使用它们没有任何额外的要求。这两个属性指的是引领给定的支系的分支，并且是递归的，所以所有的后代分支在显示时也会继承分配的宽度和颜色值。

在Biopython的早期版本中，这些是PhyloXML树的特殊功能，使用这些属性需要首先将树转换为`Bio.Phylo.PhyloXML`模块中的基本树对象的子类，即Phylogeny。

在早期版本的 Biopython 中，这些是 PhyloXML 树的特殊功能，使用属性需要首先将树转换为基本树对象的子类，称为 Phylogeny，来自 Bio.Phylo.PhyloXML 模块。

在 Biopython 1.55 及更高版本中，这是一个方便的树方法：

```python
>>> tree = tree.as_phyloxml()
```

在 Biopython 1.54 中，您可以通过一个额外的导入来完成同样的事情：

```python
>>> from Bio.Phylo.PhyloXML import Phylogeny
>>> tree = Phylogeny.from_tree(tree)
```

请注意，文件格式Newick和Nexus不支持分支的颜色和宽度，所以如果你在Bio.Phylo中使用这些属性，你将只能以PhyloXML格式保存这些值。(你仍然可以把树保存为Newick或Nexus格式，但是颜色和宽度值在输出文件中会被跳过）。

现在我们可以开始分配颜色了。首先，我们要把根部支系染成灰色。我们可以把24位的颜色值指定为RGB三色，HTML风格的十六进制字符串，或者预定义颜色的名称。

```python
>>> tree.root.color = (128, 128, 128)
```

或者：

```python
>>> tree.root.color = "#808080"
```

或者：

```python
>>> tree.root.color = "gray"
```

一个支系的颜色是通过整个支系逐级向下处理的，所以当我们在这里给根部着色时，会把整个树变成灰色。我们可以通过在树的下端指定不同的颜色来覆盖这一点。

让我们以名为 "E "和 "F "的节点的最近共同祖先（MRCA）为目标。`common_ancestor`方法返回原始树中该支系的引用，所以当我们给该支系涂上 "鲑鱼 "的颜色时，该颜色将显示在原始树中。

```python
>>> mrca = tree.common_ancestor({"name": "E"}, {"name": "F"})
>>> mrca.color = "salmon"
```

如果我们碰巧知道某个支系在树上的确切位置，以嵌套的列表条目来说，我们可以通过索引直接跳到树上的那个位置。这里，索引`[0,1]`指的是根的第一个树枝的第二个树枝。

```python
>>> tree.clade[0, 1].color = "blue"
```

最后，展示我们的工作（见[图13.1.1](http://biopython.org/DIST/docs/tutorial/Tutorial.html#fig%3Aphylo-color-draw)）：

```python
>>> Phylo.draw(tree)
```

![img](http://biopython.org/DIST/docs/tutorial/images/phylo-color-draw.png)

请注意，一个支系的颜色包括导致该支系的分支，以及其后代。E和F的共同祖先原来就在树根下，通过这种着色，我们可以准确地看到树根在哪里。

天哪，我们已经完成了很多事情！我们在这里休息一下。让我们在这里休息一下，保存我们的工作。用一个文件名或句柄调用写函数--这里我们用标准输出，看看会写什么--和格式phyloxml。PhyloXML保存了我们指定的颜色，所以你可以在另一个树状视图中打开这个phyloXML文件，比如Archaeopteryx，颜色也会显示出来。

```python
>>> import sys
>>> n = Phylo.write(tree, sys.stdout, "phyloxml")  # doctest:+ELLIPSIS
<phyloxml ...>
  <phylogeny rooted="true">
    <clade>
      <color>
        <red>128</red>
        <green>128</green>
        <blue>128</blue>
      </color>
      <clade>
        <clade>
          <clade>
            <name>A</name>
          </clade>
          <clade>
            <name>B</name>
          </clade>
        </clade>
        <clade>
          <color>
            <red>0</red>
            <green>0</green>
            <blue>255</blue>
          </color>
          <clade>
            <name>C</name>
          </clade>
          ...
    </clade>
  </phylogeny>
</phyloxml>
>>> n
1
```

本章的其余部分将更详细地介绍Bio.Phylo的核心功能。关于使用Bio.Phylo的更多例子，请参见Biopython.org上的cookbook页面：

http://biopython.org/wiki/Phylo_cookbook

# 13.2 输入输出函数

像SeqIO和AlignIO一样，Phylo通过四个函数处理文件的输入和输出：`parse`、`read`、`write`和`convert`，所有这些函数都支持树形文件格式Newick、NEXUS、phyloXML和NeXML，以及比较数据分析本体（CDAO）。

`read`函数解析了给定文件中的一棵树，并将其返回。小心；如果文件中包含多于一棵树，或者没有树，它将引发一个错误。

```python
>>> from Bio import Phylo
>>> tree = Phylo.read("Tests/Nexus/int_node_labels.nwk", "newick")
>>> print(tree)  # doctest:+ELLIPSIS
Tree(rooted=False, weight=1.0)
    Clade(branch_length=75.0, name='gymnosperm')
        Clade(branch_length=25.0, name='Coniferales')
            Clade(branch_length=25.0)
                Clade(branch_length=10.0, name='Tax+nonSci')
                    Clade(branch_length=90.0, name='Taxaceae')
                        Clade(branch_length=125.0, name='Cephalotaxus')
                        ...
```

（例子文件可以在Biopython发行版的Tests/Nexus/和Tests/PhyloXML/目录中找到。）

要处理多个（或未知数量的）树，使用`parse`函数遍历给定文件中的每个树：

```python
>>> trees = Phylo.parse("Tests/PhyloXML/phyloxml_examples.xml", "phyloxml")
>>> for tree in trees:
...     print(tree)  # doctest:+ELLIPSIS
...
Phylogeny(description='phyloXML allows to use either a "branch_length" attribute...', name='example from Prof. Joe Felsenstein's book "Inferring Phyl...', rooted=True)
    Clade()
        Clade(branch_length=0.06)
            Clade(branch_length=0.102, name='A')
            ...
```

用`write`函数将一棵树或树的可迭代性写回文件：

```python
>>> trees = Phylo.parse("Tests/PhyloXML/phyloxml_examples.xml", "phyloxml")
>>> tree1 = next(trees)
>>> Phylo.write(tree1, "tree1.nwk", "newick")
1
>>> Phylo.write(trees, "other_trees.xml", "phyloxml")  # write the remaining trees
12
```

用`convert`功能在任何支持的格式之间转换文件：

```python
>>> Phylo.convert("tree1.nwk", "newick", "tree1.xml", "nexml")
1
>>> Phylo.convert("other_trees.xml", "phyloxml", "other_trees.nex", "nexus")
12
```

要使用字符串作为输入或输出，而不是实际的文件，就像使用SeqIO和AlignIO那样，使用`StringIO`：

```python
>>> from Bio import Phylo
>>> from io import StringIO
>>> handle = StringIO("(((A,B),(C,D)),(E,F,G));")
>>> tree = Phylo.read(handle, "newick")
```

# 13.3 查看和导出树

要想了解一个`Tree`对象的概况，最简单的方法是`print`它：

```python
>>> from Bio import Phylo
>>> tree = Phylo.read("PhyloXML/example.xml", "phyloxml")
>>> print(tree)
Phylogeny(description='phyloXML allows to use either a "branch_length" attribute...', name='example from Prof. Joe Felsenstein's book "Inferring Phyl...', rooted=True)
    Clade()
        Clade(branch_length=0.06)
            Clade(branch_length=0.102, name='A')
            Clade(branch_length=0.23, name='B')
        Clade(branch_length=0.4, name='C')
```

这基本上是Biopython用来表示树的对象层次结构的一个轮廓。但更有可能的是，你想看到一个树的图画。有三个函数可以做到这一点。

正如我们在演示中看到的，`draw_ascii`将树的ascii图（一个有根的系统图）打印到标准输出，或者如果给定一个开放的文件句柄。并非所有关于树的信息都被显示出来，但它提供了一种快速查看树的方法，而不需要依赖任何外部的依赖。

```python
>>> tree = Phylo.read("PhyloXML/example.xml", "phyloxml")
>>> Phylo.draw_ascii(tree)
             __________________ A
  __________|
_|          |___________________________________________ B
 |
 |___________________________________________________________________________ C
<BLANKLINE>
```

`draw`函数使用matplotlib库绘制了一个更有吸引力的图像。关于它接受的自定义输出的参数的细节，请参见API文档。

```python
>>> Phylo.draw(tree, branch_labels=lambda c: c.branch_length)
```

![img](http://biopython.org/DIST/docs/tutorial/images/phylo-draw-example.png)

关于`draw_ascii`、`draw_graphviz`和`to_networkx`中更高级的功能描述和例子，请参见Biopython wiki上的Phylo页面（http://biopython.org/wiki/Phylo）。

# 13.4 使用树和进化枝对象

由`parse`和`read`产生的`Tree`对象是递归子树的容器，连接到`root`属性的Tree对象上（无论系统发育树是否真的被认为是有根的）。一棵树有全局应用的系统发育信息，比如根系，以及对一个单一的`Clade`的引用；一个`Clade`有节点和clade的具体信息，比如分支长度，以及它自己的后裔Clade实例的列表，附在`clades`属性处。

因此，tree和tree.root之间是有区别的。不过，在实践中，你很少需要担心这个问题。为了消除这种区别，`Tree`和`Clade`都继承自`TreeMixin`，`TreeMixin`包含了通常用来搜索、检查或修改一棵树或其任何支系的方法的实现。这意味着几乎所有`tree`支持的方法都可以在`tree.root`和它下面的任何一个`clade`上使用。(`Clade`也有一个`root`属性，它返回clade对象本身。)

## 13.4.1 搜索和遍历方法

为了方便起见，我们提供了几个简化的方法，直接以列表形式返回所有外部或内部节点：

- **获取终端机**

  做出一个这个树的所有终端（叶）节点的列表。

- **get_nonterminals**

  做出一个此树的所有非终端（内部）节点的列表。

它们都包装了一个可以完全控制树遍历的方法，`find_clades`. 另外两个遍历方法`find_elements`和`find_any`依赖于相同的核心功能并接受相同的参数，由于缺乏更好的描述，我们将其称为“目标规范”。这些指定树中的哪些对象将在迭代期间匹配和返回。第一个参数可以是以下任何类型：

- 一个**TreeElement 实例**，其中的树元素将通过身份匹配——因此以一个 Clade 实例作为目标进行搜索将在树中找到该进化枝；

- 一个**string**，它匹配树元素的字符串表示——特别是一个进化枝的`name` *（在 Biopython 1.56 中添加）*；

- 一个**类**或**类型**，其中相同类型（或子类型）的每个树元素都将被匹配；

- 一个

  字典

  ，其中键是树元素属性，值与每个树元素的相应属性相匹配。这个变得更加复杂：

  - 如果给出一个int ，它匹配数值相等的属性，例如 1 将匹配 1 或 1.0
  - 如果给出了布尔值（True 或 False），相应的属性值将被评估为布尔值并检查是否相同
  - 无匹配无
  - 如果给定一个字符串，则该值被视为正则表达式（必须匹配相应元素属性中的整个字符串，而不仅仅是前缀）。没有特殊正则表达式字符的给定字符串将完全匹配字符串属性，因此如果您不使用正则表达式，请不要担心。例如，在进化枝名称为 Foo1、Foo2 和 Foo3 的树中，`tree.find_clades({"name": "Foo1"})`匹配 Foo1，`{"name": "Foo.*"}`匹配所有三个进化枝，但`{"name": "Foo"}`不匹配任何内容。

  由于浮点运算会产生一些奇怪的行为，我们不支持直接匹配float。相反，使用布尔值True来匹配指定属性中具有非零值的每个元素，然后使用不等式（或精确数字，如果你喜欢危险的生活）手动过滤该属性。

  如果字典包含多个条目，则匹配元素必须匹配每个给定的属性值——想想“and”，而不是“or”。

- **采用**单个参数（它将应用于树中的每个元素）的函数，返回 True 或 False 。为方便起见，LookupError、AttributeError 和 ValueError 被静音，因此这提供了另一种安全的方法来搜索树中的浮点值或一些更复杂的特征。

在目标之后，有两个可选的关键字参数：

- **终端**

  — 用于选择或反对终端进化枝（又名叶节点）的布尔值：True 仅搜索终端进化枝，False 搜索非终端（内部）进化枝，默认值 None 搜索终端和非终端进化枝，如以及缺少该`is_terminal`方法的任何树元素。

- **命令**

  — 树遍历顺序：“preorder”（默认）是深度优先搜索，“postorder”是子节点在父节点之前的 DFS，“level”是广度优先搜索。

最后，这些方法接受任意关键字参数，它们的处理方式与字典目标规范相同：键表示要搜索的元素属性的名称，参数值（字符串、整数、无或布尔值）与值进行比较找到的每个属性。如果没有给出关键字参数，则匹配任何 TreeElement 类型。这样做的代码通常比将字典作为目标规范传递更短：`tree.find_clades({"name": "Foo1"})`可以缩短为`tree.find_clades(name="Foo1")`.

（在 Biopython 1.56 或更高版本中，这可能更短`tree.find_clades("Foo1")`：）

现在我们已经掌握了目标规范，下面是用于遍历树的方法：

- **查找进化枝**

  查找包含匹配元素的每个进化枝。也就是说，查找每个元素与`find_elements`，但返回相应的进化枝对象。（这通常是您想要的。）结果是遍历所有匹配对象的可迭代对象，默认情况下搜索深度优先。这不一定与元素在 Newick、Nexus 或 XML 源文件中出现的顺序相同！

- **查找元素**

  查找与给定属性匹配的所有树元素，并返回匹配元素本身。简单的 Newick 树没有复杂的子元素，因此其行为与`find_clades`它们相同。PhyloXML 树通常确实具有附加到进化枝的复杂对象，因此此方法对于提取这些对象很有用。

- **查找任何**

  返回找到的第一个元素`find_elements()`，或 None。这对于检查树中是否存在任何匹配元素也很有用，并且可以在条件中使用。

还有两种方法有助于在树中的节点之间导航：

- **获取路径**

  直接列出树根（或当前进化枝）和给定目标之间的进化枝。返回此路径上所有进化枝对象的列表，以给定目标结束，但不包括根进化枝。

- **痕迹**

  此树中两个目标之间的所有进化枝对象的列表。不包括开始，包括结束。

## 13.4.2 信息方法

这些方法提供有关整棵树（或任何进化枝）的信息。

- **共同祖先**

  查找所有给定目标的最近共同祖先。（这将是一个进化枝对象）。如果没有给出目标，则返回当前进化枝的根（从中调用此方法的那个）；如果给出 1 个目标，则返回目标本身。但是，如果在当前树（或进化枝）中找不到任何指定的目标，则会引发异常。

- **计数终端**

  计算树中终端（叶）节点的数量。

- **深处**

  创建树进化枝到深度的映射。结果是一个字典，其中键是树中所有的进化枝实例，值是从根到每个进化枝（包括终端）的距离。默认情况下，距离是通往进化枝的累积分支长度，但使用该`unit_branch_lengths=True`选项时，仅计算分支数（树中的级别）。

- **距离**

  计算两个目标之间的分支长度之和。如果只指定了一个目标，那么另一个就是这棵树的根。

- **total_branch_length**

  计算这棵树中所有分支长度的总和。这在系统发育学中通常被称为树的“长度”，但我们使用更明确的名称以避免与 Python 术语混淆。

这些方法的其余部分是布尔检查：

- **is_bifurcating**

  如果树是严格分叉的，则为真；即所有节点都有 2 个或 0 个子节点（分别为内部或外部）。根可能有 3 个后代，但仍被视为分叉树的一部分。

- **is_monophyletic**

  测试所有给定的目标是否包含一个完整的子进化枝——即，是否存在一个进化枝，其终端与给定的目标是同一组。目标应该是树的终端。为方便起见，如果目标是单系的（而不是 value ）`True`，则此方法返回目标的共同祖先 (MCRA)，`False`否则返回。

- **is_parent_of**

  如果目标是这棵树的后代，则为真——不需要是直接后代。要检查进化枝的直接后代，只需使用列表成员测试：`if subclade in clade: ...`

- **is_preterminal**

  如果所有直系后代都是终端，则为真；如果任何直系后代不是终端，则为 False。

## 13.4.3 修改方法

这些方法就地修改树。如果你想保持原始树完好无损，首先使用 Python 的复制模块制作树的完整副本：

```
tree = Phylo.read("example.xml", "phyloxml")
导入副本

newtree = copy.deepcopy(树)
```

- **坍塌**

  从树中删除目标，将其子项重新链接到其父项。

- **全部收缩**

  折叠这棵树的所有后代，只留下终端。保留分支长度，即到每个终端的距离保持不变。使用目标规范（见上文），仅折叠符合规范的内部节点。

- **阶梯化**

  根据终端节点的数量对进化枝进行就地排序。默认情况下，最深的进化枝放在最后。用于`reverse=True`从最深到最浅对进化枝进行排序。

- **修剪**

  从树上修剪一个终端进化枝。如果分类单元来自分叉，则连接节点将折叠，其分支长度将添加到剩余的终端节点。这可能不再是一个有意义的值。

- **root_with_outgroup**

  用包含给定目标的外群进化枝重新生成这棵树，即外群的共同祖先。此方法仅适用于 Tree 对象，不适用于 Clades。如果外群与 self.root 相同，则不会发生任何变化。如果外群进化枝是末端的（例如，单个终端节点被指定为外群），则创建一个新的分叉根进化枝，其分支为给定外群的长度为 0。否则，外群底部的内部节点将成为整棵树的三叉根。如果原来的根是分叉的，它就会从树上掉下来。在所有情况下，树的总分支长度保持不变。

- **root_at_midpoint**

  在树的两个最远的尖端之间的计算中点处重新生成这棵树。（这`root_with_outgroup`在引擎盖下使用。）

- **分裂**

  生成*n*（默认 2）个新后代。在物种树中，这是一个物种形成事件。新的进化枝具有`branch_length`与该进化枝的根相同的给定名称加上一个整数后缀（从 0 开始计数）——例如，拆分名为“A”的进化枝会产生子进化枝“A0”和“A1”。

有关使用可用方法的更多示例，请参阅 Biopython wiki ( [http://biopython.org/wiki/Phylo ) 上的 Phylo 页面。](https://biopython-org.translate.goog/wiki/Phylo?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN&_x_tr_pto=wapp&_x_tr_sch=http)

## 13.4.4 PhyloXML树的特征



phyloXML 文件格式包括用于使用其他数据类型和视觉提示注释树的字段。

[请参阅 Biopython wiki ( http://biopython.org/wiki/PhyloXML](https://biopython-org.translate.goog/wiki/PhyloXML?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN&_x_tr_pto=wapp&_x_tr_sch=http) )上的 PhyloXML 页面，了解使用 PhyloXML 提供的附加注释功能的说明和示例。

# 13.5 运行外部应用程序



虽然 Bio.Phylo 本身不从排列推断树，但有第三方程序可以这样做。这些可以通过使用模块从 python 中访问`subprocess`。

下面是一个关于如何使用 python 脚本与 PhyML 交互的示例 ( [http://www.atgc-montpellier.fr/phyml/](https://translate.google.com/website?sl=auto&tl=zh-CN&hl=zh-CN&client=webapp&u=http://www.atgc-montpellier.fr/phyml/) )。该程序接受phylip-relaxed格式的输入比对（即 Phylip 格式，但没有分类单元名称的 10 个字符限制）和各种选项。

```
>>> 导入子流程
>>> cmd = "phyml -i Tests/Phylip/random.phy"
>>> 结果 = subprocess.run(cmd, shell=True, stdout=subprocess.PIPE, text=True)
```

'stdout = subprocess.PIPE' 参数使程序的输出可以通过 'results.stdout' 访问以进行调试（对于 'stderr' 也可以这样做），'text=True' 使返回的信息成为python 字符串，而不是“字节”对象。

这将生成一个树文件和一个名为 [ *input‍filename* ]`_phyml_tree.txt`和 [ *input‍filename* ]的统计文件`_phyml_stats.txt`。树文件采用 Newick 格式：

```
>>> 从 Bio 导入 Phylo
>>> tree = Phylo.read("Tests/Phylip/random.phy_phyml_tree.txt", "newick")
>>> Phylo.draw_ascii（树）
  __________________ F
 |
 | 我
 |
_| ________ C
 | ________|
 | | | , J
 | | |________|
 | | | ， H
 |____________| |__________|
             | |__________ 乙
             |
             ， G
             |
             | , 乙
             |________________|
                              | ___________________________ A
                              |________________|
                                               |__________乙
<空白>
```

该`subprocess`模块还可用于与提供命令行界面的任何其他程序进行交互，例如 RAxML ( [https://sco.h-its.org/exelixis/software.html](https://translate.google.com/website?sl=auto&tl=zh-CN&hl=zh-CN&client=webapp&u=https://sco.h-its.org/exelixis/software.html) )、FastTree ( [http://www.microbesonline .org/fasttree/](https://translate.google.com/website?sl=auto&tl=zh-CN&hl=zh-CN&client=webapp&u=http://www.microbesonline.org/fasttree/) )、dnaml和protml。

# 13.6 PAML 集成



Biopython 1.58 带来了对 PAML ( [http://abacus.gene.ucl.ac.uk/software/paml.html](https://translate.google.com/website?sl=auto&tl=zh-CN&hl=zh-CN&client=webapp&u=http://abacus.gene.ucl.ac.uk/software/paml.html) ) 的支持，这是一套通过最大似然法进行系统发育分析的程序。目前已实现程序codeml、baseml 和yn00。由于 PAML 使用控制文件而不是命令行参数来控制运行时选项，因此此包装器的使用偏离了 Biopython 中其他应用程序包装器的格式。

一个典型的工作流程是初始化一个 PAML 对象，指定一个比对文件、一个树文件、一个输出文件和一个工作目录。接下来，通过set_options()方法或通过读取现有控制文件来设置运行时选项。最后，程序通过run()方法运行，输出文件自动解析为结果字典。

以下是 codeml 的典型用法示例：

```
>>> 从 Bio.Phylo.PAML 导入 codeml
>>> cml = codeml.Codeml()
>>> cml.alignment = "Tests/PAML/Alignments/alignment.phylip"
>>> cml.tree = "Tests/PAML/Trees/species.tree"
>>> cml.out_file = "results.out"
>>> cml.working_dir = "./scratch"
>>> cml.set_options(
...序列类型=1，
...详细=0，
...嘈杂=0，
...速率祖先=0，
...模型=0，
... NSsites=[0, 1, 2],
...密码子频率=2，
...清洁数据=1，
... fix_alpha=1,
...卡帕 = 4.54006，
...）
>>> 结果 = cml.run()
>>> ns_sites = results.get("NSsites")
>>> m0 = ns_sites.get(0)
>>> m0_params = m0.get("参数")
>>> 打印（m0_params.get（“欧米茄”））
```

现有的输出文件也可以使用模块的read()函数进行解析：

```
>>> results = codeml.read("Tests/PAML/Results/codeml/codeml_NSsites_all.out")
>>> print(results.get("lnL max"))
```

这个新模块的详细文档目前位于 Biopython wiki 上：[http ://biopython.org/wiki/PAML](https://biopython-org.translate.goog/wiki/PAML?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN&_x_tr_pto=wapp&_x_tr_sch=http)

# 13.7 未来计划



Bio.Phylo 正在积极开发中。以下是我们可能会在未来版本中添加的一些功能：

- **新方法**

  通常用于操作 Tree 或 Clade 对象的有用函数首先出现在 Biopython wiki 上，以便临时用户可以测试它们并在我们将它们添加到 Bio.Phylo 之前决定它们是否有用：[http://biopython.org/wiki/Phylo_cookbook](https://biopython-org.translate.goog/wiki/Phylo_cookbook?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN&_x_tr_pto=wapp&_x_tr_sch=http)

- **Bio.Nexus 端口**

  这个模块的大部分是在 NESCent 的赞助下，在 2009 年谷歌代码之夏期间编写的，作为一个项目来实现对 phyloXML 数据格式的 Python 支持（参见[13.4.4](https://biopython-org.translate.goog/DIST/docs/tutorial/Tutorial.html?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN&_x_tr_pto=wapp&_x_tr_sch=http#sec%3APhyloXML)）。通过将现有 Bio.Nexus 模块的一部分移植到 Bio.Phylo 使用的新类，添加了对 Newick 和 Nexus 格式的支持。目前，Bio.Nexus 包含一些尚未移植到 Bio.Phylo 类的有用功能——特别是计算共识树。如果您发现 Bio.Phylo 缺少某些功能，请尝试浏览 Bio.Nexus 以查看它是否存在。

我们乐于接受任何改进此模块的功能和可用性的建议；请在邮件列表或我们的错误数据库中告诉我们。

最后，如果您需要 Phylo 模块中尚未包含的其他功能，请检查它是否在另一个用于系统发育学的高质量 Python 库中可用，例如 DendroPy ( [https://dendropy.org/](https://translate.google.com/website?sl=auto&tl=zh-CN&hl=zh-CN&client=webapp&u=https://dendropy.org/) ) 或 PyCogent ( [http:// pycogent.org/](https://translate.google.com/website?sl=auto&tl=zh-CN&hl=zh-CN&client=webapp&u=http://pycogent.org/)）。由于这些库还支持系统发育树的标准文件格式，因此您可以通过写入临时文件或 StringIO 对象轻松地在库之间传输数据。