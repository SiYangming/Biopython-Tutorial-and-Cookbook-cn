Biopython 现在有两个“cookbook”示例集合——本章（已包含在本教程中多年并逐渐增长）和[http://biopython.org/wiki/Category:Cookbook](https://biopython-org.translate.goog/wiki/Category:Cookbook?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN&_x_tr_pto=wapp&_x_tr_sch=http)这是一个用户贡献的集合在我们的维基上。

我们正在努力鼓励 Biopython 用户向 wiki 贡献他们自己的例子。除了帮助社区之外，分享这样的示例的一个直接好处是您还可以获得其他 Biopython 用户和开发人员对代码的一些反馈——这可以帮助您改进所有 Python 代码。

从长远来看，我们最终可能会将本章中的所有示例移至 wiki 或教程中的其他位置。

# 20.1 使用序列文件



本节显示更多序列输入/输出示例，使用`Bio.SeqIO`第[5](https://biopython-org.translate.goog/DIST/docs/tutorial/Tutorial.html?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN&_x_tr_pto=wapp&_x_tr_sch=http#chapter%3Aseqio)。

## 20.1.1 过滤序列文件

通常你会有一个包含许多序列的大文件（例如 FASTA 文件或基因，或者 FASTQ 或 SFF 读段文件），一个单独的较短的感兴趣序列子集的 ID 列表，并且想要制作一个该子集的新序列文件。

假设 ID 列表在一个简单的文本文件中，作为每行的第一个单词。这可能是一个表格文件，其中第一列是 ID。尝试这样的事情：

```
从 Bio 导入 SeqIO

input_file = "big_file.sff"
id_file = "short_list.txt"
output_file = "short_list.sff"

以 open(id_file) 作为 id_handle：
    wanted = set(line.rstrip("\n").split(None, 1)[0] for line in id_handle)
print("在 %s 中找到 %i 个唯一标识符" % (len(wanted), id_file))

records = (r for r in SeqIO.parse(input_file, "sff") if r.id in wanted)
count = SeqIO.write（记录，输出文件，“sff”）
print("从 %s 到 %s 保存了 %i 条记录" % (count, input_file, output_file))
如果计数 < len（通缉）：
    print("警告 %i IDs 未在 %s 中找到" % (len(wanted) - count, input_file))
```

请注意，我们使用 Python`set`而不是`list`，这使得测试成员资格更快。

如第[5.6](https://biopython-org.translate.goog/DIST/docs/tutorial/Tutorial.html?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN&_x_tr_pto=wapp&_x_tr_sch=http#sec%3Alow-level-fasta-fastq)，对于大型 FASTA 或 FASTQ 文件，为了提高速度，最好不要使用高级`SeqIO`接口，而是直接使用字符串。下一个示例展示了如何使用 FASTQ 文件执行此操作——它更复杂：

```
从 Bio.SeqIO.QualityIO 导入 FastqGeneralIterator

input_file = "big_file.fastq"
id_file = "short_list.txt"
output_file = "short_list.fastq"

以 open(id_file) 作为 id_handle：
    # 将每行的第一个词作为标识符
    wanted = set(line.rstrip("\n").split(None, 1)[0] for line in id_handle)
print("在 %s 中找到 %i 个唯一标识符" % (len(wanted), id_file))

以 open(input_file) 作为 in_handle：
    以 open(output_file, "w") 作为 out_handle:
        对于 FastqGeneralIterator(in_handle) 中的标题、序列、质量：
            # ID 是标题行中的第一个词（@ 符号之后）：
            如果 title.split(None, 1)[0] 想要：
                # 这会产生一个标准的 4 行 FASTQ 条目：
                out_handle.write("@%s\n%s\n+\n%s\n" % (title, seq, qual))
                计数 += 1
print("从 %s 到 %s 保存了 %i 条记录" % (count, input_file, output_file))
如果计数 < len（通缉）：
    print("警告 %i IDs 未在 %s 中找到" % (len(wanted) - count, input_file))
```

## 20.1.2 产生随机基因组

假设您正在查看基因组序列，寻找某些序列特征——可能是极端的局部 GC% 偏差，或者可能是限制性消化位点。一旦你的 Python 代码在真实的基因组上工作，尝试在同一基因组的随机版本上运行相同的搜索以进行统计分析可能是明智的（毕竟，你发现的任何“特征”可能就在那里偶然地）。

*在本次讨论中，我们将使用来自鼠疫耶尔森氏菌 biovar Microtus 的*pPCP1 质粒的 GenBank 文件。该文件包含在 GenBank 文件夹下的 Biopython 单元测试中，或者您可以从我们的网站[NC_005816.gb](https://translate.google.com/website?sl=auto&tl=zh-CN&hl=zh-CN&client=webapp&u=https://raw.githubusercontent.com/biopython/biopython/master/Tests/GenBank/NC_005816.gb)获取它。该文件包含一条记录，因此我们可以`SeqRecord`使用以下`Bio.SeqIO.read()`函数将其读入：

```
>>> 从 Bio 导入 SeqIO
>>> original_rec = SeqIO.read("NC_005816.gb", "genbank")
```

那么，我们怎样才能生成原始序列的打乱版本呢？`random`为此，我会使用内置的 Python模块，尤其是函数`random.shuffle`——但这适用于 Python 列表。我们的序列是一个`Seq`对象，所以为了打乱它，我们需要把它变成一个列表：

```
>>> 随机导入
>>> nuc_list = 列表(original_rec.seq)
>>> random.shuffle(nuc_list) # 原地行动！
```

现在，为了用于`Bio.SeqIO`输出打乱后的序列，我们需要使用这个打乱后的列表构造一个新对象`SeqRecord`。`Seq`为此，我们需要将核苷酸列表（单字母字符串）转换为长字符串——标准的 Python 方法是使用字符串对象的 join 方法。

```
>>> 从 Bio.Seq 导入 Seq
>>> 从 Bio.SeqRecord 导入 SeqRecord
>>> shuffled_rec = SeqRecord(
... Seq("".join(nuc_list)), id="Shuffled", description="Based on %s" % original_rec.id
...）
```

让我们将所有这些部分放在一起来制作一个完整的 Python 脚本，该脚本生成一个包含原始序列的 30 个随机打乱版本的 FASTA 文件。

第一个版本只是使用了一个大的 for 循环并一条一条地写出记录（使用`SeqRecord`第[5.5.4](https://biopython-org.translate.goog/DIST/docs/tutorial/Tutorial.html?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN&_x_tr_pto=wapp&_x_tr_sch=http#sec%3ABio.SeqIO-and-StringIO)）：

```
随机导入
从 Bio.Seq 导入 Seq
从 Bio.SeqRecord 导入 SeqRecord
从 Bio 导入 SeqIO

original_rec = SeqIO.read("NC_005816.gb", "genbank")

以 open("shuffled.fasta", "w") 作为 output_handle:
    对于范围内的我（30）：
        nuc_list = 列表(original_rec.seq)
        random.shuffle（nuc_list）
        shuffled_rec = SeqRecord(
            Seq("".join(nuc_list)),
            id="Shuffled%i" % (i + 1),
            description="基于 %s" % original_rec.id,
        )
        output_handle.write(shuffled_rec.format("fasta"))
```

就我个人而言，我更喜欢以下版本，它使用一个函数来打乱记录和一个生成器表达式而不是 for 循环：

```
随机导入
从 Bio.Seq 导入 Seq
从 Bio.SeqRecord 导入 SeqRecord
从 Bio 导入 SeqIO


def make_shuffle_record（记录，new_id）：
    nuc_list = 列表（记录序列）
    random.shuffle（nuc_list）
    返回序列记录(
        Seq("".join(nuc_list)),
        id=new_id,
        description="基于 %s" % original_rec.id,
    )


original_rec = SeqIO.read("NC_005816.gb", "genbank")
shuffled_recs = (
    make_shuffle_record(original_rec, “Shuffled%i” % (i + 1)) for i in range(30)
)

SeqIO.write(shuffled_recs, "shuffled.fasta", "fasta")
```

## 20.1.3 翻译 CDS 条目的 FASTA 文件

假设您有一些生物体的 CDS 条目输入文件，并且您想要生成一个包含其蛋白质序列的新 FASTA 文件。即从原始文件中取出每个核苷酸序列，并翻译它。回到第[3.8](https://biopython-org.translate.goog/DIST/docs/tutorial/Tutorial.html?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN&_x_tr_pto=wapp&_x_tr_sch=http#sec%3Atranslation)我们看到了如何使用`Seq`对象的`translate method`, 和可选`cds`参数来正确翻译替代起始密码子。

我们可以将它与`Bio.SeqIO`第[5.5.3](https://biopython-org.translate.goog/DIST/docs/tutorial/Tutorial.html?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN&_x_tr_pto=wapp&_x_tr_sch=http#sec%3ASeqIO-reverse-complement)结合起来。关键是对于每个核苷酸`SeqRecord`，我们需要创建一个蛋白质`SeqRecord`——并注意命名它。

您可以编写自己的函数来执行此操作，为您的序列选择合适的蛋白质标识符，以及合适的遗传密码。在此示例中，我们仅使用默认表并为标识符添加前缀：

```
从 Bio.SeqRecord 导入 SeqRecord


def make_protein_record（nuc_record）：
    """返回一个带有翻译后序列的新 SeqRecord（默认表）。"""
    返回序列记录(
        seq=nuc_record.seq.translate(cds=True),
        id="trans_" + nuc_record.id,
        description="CDS的翻译，使用默认表"，
    )
```

然后我们可以使用此函数将输入的核苷酸记录转换为准备输出的蛋白质记录。一种优雅的方式和内存高效的方式来做到这一点是使用生成器表达式：

```
从 Bio 导入 SeqIO

蛋白质 = (
    make_protein_record（nuc_rec）
    对于 SeqIO.parse 中的 nuc_rec("coding_sequences.fasta", "fasta")
)
SeqIO.write（蛋白质，“translations.fasta”，“fasta”）
```

这应该适用于任何完整编码序列的 FASTA 文件。`nuc_record.seq.translate(to_stop=True)`如果您正在处理部分编码序列，您可能更喜欢在上面的示例中使用，因为这不会检查有效的起始密码子等。

## 20.1.4 使 FASTA 文件中的序列大写

通常您会从合作者那里获得 FASTA 文件形式的数据，有时序列可能是大小写混合的。在某些情况下，这是故意的（例如，质量差的区域使用小写字母），但通常这并不重要。您可能想要编辑文件以使所有内容保持一致（例如全部大写），您可以使用对象`upper()`的方法`SeqRecord`（在 Biopython 1.55 中添加）轻松地做到这一点：

```
从 Bio 导入 SeqIO

records = (rec.upper() for rec in SeqIO.parse("mixed.fas", "fasta"))
count = SeqIO.write（记录，“upper.fas”，“fasta”）
print("已将 %i 条记录转换为大写" % count)
```

这是如何运作的？第一行只是导入`Bio.SeqIO`模块。第二行是有趣的一点——这是一个 Python 生成器表达式，它给出了从输入文件 ( mixed.fas )解析的每条记录的大写版本。在第三行中，我们将此生成器表达式提供给函数`Bio.SeqIO.write()`，并将新的大写记录保存到我们的输出文件 ( upper.fas )。

我们使用生成器表达式（而不是列表或列表理解）的原因是这意味着一次只有一条记录保存在内存中。如果您要处理包含数百万个条目的大文件，这可能非常重要。

## 20.1.5 排序序列文件



假设您想按长度对序列文件进行排序（例如，来自一个程序集的一组重叠群），并且您正在使用一种文件格式，如 FASTA 或 FASTQ，它们可以读取、写入（和索引）`Bio.SeqIO`。

如果文件足够小，您可以将其作为`SeqRecord`对象列表一次全部加载到内存中，对列表进行排序，然后保存：

```
从 Bio 导入 SeqIO

records = list(SeqIO.parse("ls_orchid.fasta", "fasta"))
records.sort(key=lambda r: len(r))
SeqIO.write（记录，“sorted_orchids.fasta”，“fasta”）
```

唯一聪明的一点是指定一种比较方法来对记录进行排序（这里我们按长度对它们进行排序）。如果您首先想要最长的记录，则可以翻转比较或使用反向参数：

```
从 Bio 导入 SeqIO

records = list(SeqIO.parse("ls_orchid.fasta", "fasta"))
records.sort(key=lambda r: -len(r))
SeqIO.write（记录，“sorted_orchids.fasta”，“fasta”）
```

现在这很简单——但是如果你有一个非常大的文件并且你不能像这样将它全部加载到内存中会发生什么？例如，您可能有一些下一代测序读数按长度排序。这可以使用函数解决`Bio.SeqIO.index()`。

```
从 Bio 导入 SeqIO

# 获取长度和id，并按长度排序
len_and_ids =排序（
    (len(rec), rec.id) for rec in SeqIO.parse("ls_orchid.fasta", "fasta")
)
ids = reversed([id for (length, id) in len_and_ids])
del len_and_ids # 释放内存
record_index = SeqIO.index("ls_orchid.fasta", "fasta")
records = (record_index[id] for id in ids)
SeqIO.write（记录，“sorted.fasta”，“fasta”）
```

首先，我们使用 扫描文件一次`Bio.SeqIO.parse()`，将记录标识符及其长度记录在元组列表中。然后我们对这个列表进行排序以按长度顺序获取它们，并丢弃长度。使用这个经过排序的标识符列表，`Bio.SeqIO.index()`我们可以一条一条地检索记录，然后将它们传递给`Bio.SeqIO.write()`输出。

这些示例都用于`Bio.SeqIO`将记录解析为`SeqRecord`使用 输出的对象`Bio.SeqIO.write()`。如果您想对不支持的文件格式进行排序`Bio.SeqIO.write()`，例如纯文本 SwissProt 格式，该怎么办？`get_raw()`这是使用添加到`Bio.SeqIO.index()`Biopython 1.54 中[的](https://biopython-org.translate.goog/DIST/docs/tutorial/Tutorial.html?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN&_x_tr_pto=wapp&_x_tr_sch=http#sec%3Aseqio-index-getraw)方法的替代解决方案（参见第 ‍5.4.2.2 节）。

```
从 Bio 导入 SeqIO

# 获取长度和id，并按长度排序
len_and_ids =排序（
    (len(rec), rec.id) for rec in SeqIO.parse("ls_orchid.fasta", "fasta")
)
ids = reversed([id for (length, id) in len_and_ids])
del len_and_ids # 释放内存

record_index = SeqIO.index("ls_orchid.fasta", "fasta")
用 open("sorted.fasta", "wb") 作为 out_handle:
    对于 ids 中的 id：
        out_handle.write(record_index.get_raw(id))
```

注意从 Python 3 开始，我们必须打开文件以二进制模式写入，因为该`get_raw()`方法返回`bytes`对象。

作为奖励，因为它不会`SeqRecord`第二次将数据解析为对象，所以它应该更快。如果您只想将其与 FASTA 格式一起使用，我们可以通过使用低级 FASTA 解析器获取记录标识符和长度来进一步加快速度：

```
从 Bio.SeqIO.FastaIO 导入 SimpleFastaParser
从 Bio 导入 SeqIO

# 获取长度和id，并按长度排序
打开（“ls_orchid.fasta”）作为 in_handle：
    len_and_ids =排序（
        (len(seq), title.split(None, 1)[0])
        对于标题，SimpleFastaParser(in_handle) 中的 seq
    )
ids = reversed([id for (length, id) in len_and_ids])
del len_and_ids # 释放内存

record_index = SeqIO.index("ls_orchid.fasta", "fasta")
用 open("sorted.fasta", "wb") 作为 out_handle:
    对于 ids 中的 id：
        out_handle.write(record_index.get_raw(id))
```

## 20.1.6 FASTQ 文件的简单质量过滤



FASTQ 文件格式由 Sanger 引入，现在广泛用于保存核苷酸测序读数及其质量分数。FASTQ 文件（和相关的 QUAL 文件）是每个字母注释的一个很好的例子，因为序列中的每个核苷酸都有一个相关的质量分数。任何每个字母的注释都作为列表、元组或字符串保存在`SeqRecord`字典中`letter_annotations`（元素数量与序列长度相同）。

一项常见任务是获取大量测序读数并根据其质量得分过滤（或裁剪）它们。以下示例非常简单，但应该说明在`SeqRecord`对象中使用质量数据的基础知识。我们在这里要做的就是读取一个 FASTQ 数据文件，并对其进行过滤以仅挑选出 PHRED 质量分数均高于某个阈值（此处为 20）的记录。

对于这个例子，我们将使用从 ENA 序列读取存档下载的一些真实数据， ftp: [//ftp.sra.ebi.ac.uk/vol1/fastq/SRR020/SRR020192/SRR020192.fastq.gz](https://translate.google.com/website?sl=auto&tl=zh-CN&hl=zh-CN&client=webapp&u=ftp://ftp.sra.ebi.ac.uk/vol1/fastq/SRR020/SRR020192/SRR020192.fastq.gz) (2MB) 解压缩到一个 19MB 的文件SRR020192.fastq。这是来自受病毒感染的加利福尼亚海狮的 Roche 454 GS FLX 单端数据（有关详细信息，请参见[https://www.ebi.ac.uk/ena/data/view/SRS004476](https://translate.google.com/website?sl=auto&tl=zh-CN&hl=zh-CN&client=webapp&u=https://www.ebi.ac.uk/ena/data/view/SRS004476)）。

首先，让我们计算一下读数：

```
从 Bio 导入 SeqIO

计数 = 0
对于 SeqIO.parse("SRR020192.fastq", "fastq") 中的记录：
    计数 += 1
print("%i 阅读" % count)
```

现在让我们为最低 PHRED 质量 20 做一个简单的过滤：

```
从 Bio 导入 SeqIO

good_reads = (
    记录
    在 SeqIO.parse("SRR020192.fastq", "fastq") 中记录
    如果 min(rec.letter_annotations["phred_quality"]) >= 20
)
count = SeqIO.write（good_reads，“good_quality.fastq”，“fastq”）
打印（“保存 %i 阅读” % 计数）
```

这仅从 41892 个当前读取中提取了 14580 个读数。更明智的做法是对读数进行质量修剪，但这仅作为示例。

FASTQ 文件可能包含数百万个条目，因此最好避免一次将它们全部加载到内存中。此示例使用生成器表达式，这意味着`SeqRecord`一次只能创建一个生成器表达式 - 避免任何内存限制。

请注意，在这里使用低级`FastqGeneralIterator`解析器会更快（参见第[5.6](https://biopython-org.translate.goog/DIST/docs/tutorial/Tutorial.html?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN&_x_tr_pto=wapp&_x_tr_sch=http#sec%3Alow-level-fasta-fastq)），但这不会将质量字符串转换为整数分数。

## 20.1.7 修剪引物序列



对于这个例子，我们假设GATGACGGTGT是我们想要在一些 FASTQ 格式的读取数据中寻找的 5' 引物序列。如上例所示，我们将使用从 ENA ( [ftp://ftp.sra.ebi.ac.uk/vol1/fastq/SRR020/SRR020192/SRR020192.fastq.gz](https://translate.google.com/website?sl=auto&tl=zh-CN&hl=zh-CN&client=webapp&u=ftp://ftp.sra.ebi.ac.uk/vol1/fastq/SRR020/SRR020192/SRR020192.fastq.gz) ) 下载的SRR020192.fastq文件。

通过使用主`Bio.SeqIO`界面，相同的方法将适用于任何其他支持的文件格式（例如 FASTA 文件）。然而，对于大型 FASTQ 文件，这里的低级`FastqGeneralIterator`解析器会更快（参见前面的示例和第[‍5.6](https://biopython-org.translate.goog/DIST/docs/tutorial/Tutorial.html?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN&_x_tr_pto=wapp&_x_tr_sch=http#sec%3Alow-level-fasta-fastq)）。

此代码使用`Bio.SeqIO`生成器表达式（以避免一次将所有序列加载到内存中），以及`Seq`对象的`startswith`方法来查看读取是否从引物序列开始：

```
从 Bio 导入 SeqIO

primer_reads = (
    记录
    在 SeqIO.parse("SRR020192.fastq", "fastq") 中记录
    如果 rec.seq.startswith("GATGACGGTGT")
)
count = SeqIO.write（primer_reads，“with_primer.fastq”，“fastq”）
打印（“保存 %i 阅读” % 计数）
```

这应该从SRR014849.fastq中找到 13819 个读数并将它们保存到一个新的 FASTQ 文件with_primer.fastq中。

现在假设您想要制作一个包含这些读数但删除了引物序列的 FASTQ 文件？这只是一个很小的变化，因为我们可以切片`SeqRecord`（参见第[4.7](https://biopython-org.translate.goog/DIST/docs/tutorial/Tutorial.html?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN&_x_tr_pto=wapp&_x_tr_sch=http#sec%3ASeqRecord-slicing)）以删除前 11 个字母（我们的引物的长度）：

```
从 Bio 导入 SeqIO

trimmed_primer_reads = (
    记录[11:]
    在 SeqIO.parse("SRR020192.fastq", "fastq") 中记录
    如果 rec.seq.startswith("GATGACGGTGT")
)
count = SeqIO.write（trimmed_primer_reads，“with_primer_trimmed.fastq”，“fastq”）
打印（“保存 %i 阅读” % 计数）
```

同样，这应该从SRR020192.fastq中提取 13819 条读数，但这次去掉前十个字符，并将它们保存到另一个新的 FASTQ 文件with_primer_trimmed.fastq中。

现在，假设您想创建一个新的 FASTQ 文件，其中这些读取已删除引物，但所有其他读取都保持原样？如果我们仍然想使用生成器表达式，那么定义我们自己的 trim 函数可能是最清楚的：

```
从 Bio 导入 SeqIO


def trim_primer（记录，入门）：
    如果 record.seq.startswith(引物):
        返回记录[len（底漆）：]
    别的：
        返回记录


trimmed_reads = (
    trim_primer（记录，“GATGACGGTGT”）
    记录在 SeqIO.parse("SRR020192.fastq", "fastq")
)
count = SeqIO.write（trimmed_reads，“trimmed.fastq”，“fastq”）
打印（“保存 %i 阅读” % 计数）
```

这需要更长的时间，因为这次输出文件包含所有 41892 个读数。同样，我们使用生成器表达式来避免任何内存问题。您也可以使用生成器函数而不是生成器表达式。

```
从 Bio 导入 SeqIO


def trim_primers（记录，引物）：
    """在读取开始时删除完美的引物序列。

    这是一个生成器函数，记录参数应该
    是返回 SeqRecord 对象的列表或迭代器。
    """
    len_primer = len(primer) # 缓存它以备后用
    记录在案：
        如果 record.seq.startswith(引物):
            产量记录[len_primer:]
        别的：
            产量记录


original_reads = SeqIO.parse("SRR020192.fastq", "fastq")
trimmed_reads = trim_primers(original_reads, "GATGACGGTGT")
count = SeqIO.write（trimmed_reads，“trimmed.fastq”，“fastq”）
打印（“保存 %i 阅读” % 计数）
```

如果你想做一些更复杂的事情，只保留一些记录，这种形式会更灵活——如下一个例子所示。

## 20.1.8 修剪适配器序列



这本质上是对前面示例的简单扩展。我们将假装GATGACGGTGT是一些 FASTQ 格式读取数据中的适配器序列，同样是来自 NCBI 的SRR020192.fastq文件（ [ftp://ftp.sra.ebi.ac.uk/vol1/fastq/SRR020/SRR020192 /SRR020192.fastq.gz](https://translate.google.com/website?sl=auto&tl=zh-CN&hl=zh-CN&client=webapp&u=ftp://ftp.sra.ebi.ac.uk/vol1/fastq/SRR020/SRR020192/SRR020192.fastq.gz)）。

*然而这一次，我们将在 reads 的任何地方*寻找序列，而不仅仅是在最开始：

```
从 Bio 导入 SeqIO


def trim_adaptors（记录，适配器）：
    """修剪完美的适配器序列。

    这是一个生成器函数，记录参数应该
    是返回 SeqRecord 对象的列表或迭代器。
    """
    len_adaptor = len(adaptor) # 缓存它以备后用
    记录在案：
        index = record.seq.find（适配器）
        如果索引 == -1：
            # 没有找到适配器，所以不会修剪
            产量记录
        别的：
            # 剪掉适配器
            产量记录[索引+ len_adaptor :]


original_reads = SeqIO.parse("SRR020192.fastq", "fastq")
trimmed_reads = trim_adaptors(original_reads, "GATGACGGTGT")
count = SeqIO.write（trimmed_reads，“trimmed.fastq”，“fastq”）
打印（“保存 %i 阅读” % 计数）
```

因为我们在此示例中使用的是 FASTQ 输入文件，所以`SeqRecord`对象具有质量分数的每个字母注释。通过对`SeqRecord`对象进行切片，在修剪后的记录上使用适当的分数，因此我们也可以将它们输出为 FASTQ 文件。

与我们只在每次读取开始时寻找引物/接头的前一个示例的输出相比，您可能会发现一些修剪后的读数在修剪后非常短（例如，如果接头是在中间而不是附近找到的）开始）。因此，让我们也添加一个最小长度要求：

```
从 Bio 导入 SeqIO


def trim_adaptors（记录、适配器、min_len）：
    """修剪完美的适配器序列，检查读取长度。

    这是一个生成器函数，记录参数应该
    是返回 SeqRecord 对象的列表或迭代器。
    """
    len_adaptor = len(adaptor) # 缓存它以备后用
    记录在案：
        len_record = len(record) # 缓存它以备后用
        如果 len（记录）< min_len：
            # 太短无法保存
            继续
        index = record.seq.find（适配器）
        如果索引 == -1：
            # 没有找到适配器，所以不会修剪
            产量记录
        elif len_record - 索引 - len_adaptor >= min_len:
            # 修剪后仍然足够长
            产量记录[索引+ len_adaptor :]


original_reads = SeqIO.parse("SRR020192.fastq", "fastq")
trimmed_reads = trim_adaptors（original_reads，“GATGACGGTGT”，100）
count = SeqIO.write（trimmed_reads，“trimmed.fastq”，“fastq”）
打印（“保存 %i 阅读” % 计数）
```

通过更改格式名称，您可以将其应用于 FASTA 文件。此代码也可以扩展为进行模糊匹配而不是精确匹配（可能使用成对比对，或考虑读取质量分数），但这会慢得多。

## 20.1.9 转换 FASTQ 文件



回到第[5.5.2](https://biopython-org.translate.goog/DIST/docs/tutorial/Tutorial.html?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN&_x_tr_pto=wapp&_x_tr_sch=http#sec%3ASeqIO-conversion)我们展示了如何使用`Bio.SeqIO`在两种文件格式之间进行转换。在这里，我们将更详细地介绍用于第二代 DNA 测序的 FASTQ 文件。请参考公鸡*等。*(2009) [ [7](https://biopython-org.translate.goog/DIST/docs/tutorial/Tutorial.html?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN&_x_tr_pto=wapp&_x_tr_sch=http#cock2010) ] 以获得更长的描述。FASTQ 文件存储 DNA 序列（作为字符串）和相关的读取质量。

PHRED 分数（用于大多数 FASTQ 文件，也用于 QUAL 文件、ACE 文件和 SFF 文件）已成为使用简单碱基表示给定碱基上测序错误（此处用*P* *e**表示）概率的事实*标准十日志转换：

*Q* PHRED = − 10 × log 10 (  *P* *e* )(20.1)

这意味着错误的读取 ( *P* *e* *= 1) 获得的 PHRED 质量为 0，而像P* *e* = 0.00001这样的非常好的读取获得的 PHRED 质量为 50。虽然原始测序数据质量高于此值的情况很少见，但经过后期处理例如读取映射或组装，质量可能高达 90（实际上，MAQ 工具允许 PHRED 分数在 0 到 93 之间（含）。

FASTQ 格式有可能成为在单个纯文本文件中存储测序读取的字母和质量分数的*事实标准。*唯一美中不足的是，FASTQ格式至少有3个版本，互不兼容，难以区分……

1. 原始的 Sanger FASTQ 格式使用 PHRED 质量编码，ASCII 偏移量为 33。NCBI 在他们的 Short Read Archive 中使用这种格式。我们将其称为.fastq（或fastq-sanger）格式`Bio.SeqIO`。
2. Solexa（后来被 Illumina 收购）推出了他们自己的版本，使用 Solexa 质量编码，ASCII 偏移量为 64。我们称之为fastq-solexa格式。
3. Illumina pipeline 1.3 及更高版本生成具有 PHRED 质量（更一致）的 FASTQ 文件，但使用 64 的 ASCII 偏移编码。我们称之为fastq-illumina格式。

Solexa 质量分数是使用不同的对数转换定义的：

| *Q* Solexa = − 10 × log 10 | ⎛ ⎜ ⎜ ⎝ | *P* *_*1− *P* *e* |      | ⎞ ⎟ ⎟ ⎠ | (20.2) |
| -------------------------- | ------- | ----------------- | ---- | ------- | ------ |
|                            |         |                   |      |         |        |

鉴于 Solexa/Illumina 现在已经开始在其管道 1.3 版中使用 PHRED 分数，Solexa 质量分数将逐渐停止使用。如果您将误差估计 ( *P* *e* ) 等同，这两个方程允许在两个评分系统之间进行转换 - Biopython 包含在模块中执行此操作的函数`Bio.SeqIO.QualityIO`，如果您使用`Bio.SeqIO`将旧的 Solexa/Illumina 文件转换为标准 Sanger 文件，则会调用这些函数FASTQ 文件：

```
从 Bio 导入 SeqIO

SeqIO.convert("solexa.fastq", "fastq-solexa", "standard.fastq", "fastq")
```

如果你想转换一个新的 Illumina 1.3+ FASTQ 文件，所有改变的只是 ASCII 偏移量，因为虽然编码不同，但分数都是 PHRED 质量：

```
从 Bio 导入 SeqIO

SeqIO.convert("illumina.fastq", "fastq-illumina", "standard.fastq", "fastq")
```

`Bio.SeqIO.convert()`请注意，这样使用比合并*快得多*`Bio.SeqIO.parse()`，`Bio.SeqIO.write()`因为优化代码用于 FASTQ 变体之间的转换（以及 FASTQ 到 FASTA 的转换）。

对于高质量的读取，PHRED 和 Solexa 分数大致相等，这意味着由于fasta-solexa和fastq-illumina格式都使用 64 位的 ASCII 偏移量，因此文件几乎相同。这是 Illumina 有意的设计选择，这意味着需要旧的fasta-solexa样式文件的应用程序可能可以使用较新的fastq-illumina文件（在良好数据上）。当然，这两种变体都与 Sanger、NCBI 和其他地方使用的原始 FASTQ 标准有很大不同（格式名称fastq或fastq-sanger）。

有关详细信息，请参阅内置帮助（也[在线](https://translate.google.com/website?sl=auto&tl=zh-CN&hl=zh-CN&client=webapp&u=http://www.biopython.org/docs/1.81/api/Bio.SeqIO.QualityIO.html)）：

```
>>> 从 Bio.SeqIO 导入 QualityIO
>>> 帮助（QualityIO）
```

## 20.1.10 将 FASTA 和 QUAL 文件转换为 FASTQ 文件



FASTQ 文件包含*序列*及其质量字符串。FASTA 文件*仅*包含序列，而 QUAL 文件*仅*包含质量。因此，单个 FASTQ 文件可以与*成对的*FASTA 和 QUAL 文件相互转换。

从 FASTQ 到 FASTA 很容易：

```
从 Bio 导入 SeqIO

SeqIO.convert("example.fastq", "fastq", "example.fasta", "fasta")
```

从 FASTQ 到 QUAL 也很容易：

```
从 Bio 导入 SeqIO

SeqIO.convert("example.fastq", "fastq", "example.qual", "qual")
```

然而，反过来有点棘手。您可以使用`Bio.SeqIO.parse()`迭代*单个*文件中的记录，但在这种情况下我们有两个输入文件。有几种可能的策略，但假设这两个文件真的配对，内存效率最高的方法是一起循环。代码有点繁琐，因此我们提供了一个`PairedFastaQualIterator`在`Bio.SeqIO.QualityIO`模块中调用的函数来执行此操作。这需要两个句柄（FASTA 文件和 QUAL 文件）并返回一个`SeqRecord`迭代器：

```
从 Bio.SeqIO.QualityIO 导入 PairedFastaQualIterator

记录在 PairedFastaQualIterator(open("example.fasta"), open("example.qual")):
    打印（记录）
```

此功能将检查 FASTA 和 QUAL 文件是否一致（例如，记录的顺序相同，并且具有相同的序列长度）。您可以将其与`Bio.SeqIO.write()`将一对 FASTA 和 QUAL 文件转换为单个 FASTQ 文件的功能结合使用：

```
从 Bio 导入 SeqIO
从 Bio.SeqIO.QualityIO 导入 PairedFastaQualIterator

以 open("example.fasta") 作为 f_handle，open("example.qual") 作为 q_handle：
    记录 = PairedFastaQualIterator(f_handle, q_handle)
    count = SeqIO.write（记录，“temp.fastq”，“fastq”）
print("已转换 %i 条记录" % count)
```

## 20.1.11 索引 FASTQ 文件



FASTQ 文件通常非常大，其中有数百万条读数。由于数据量巨大，您无法一次将所有记录加载到内存中。这就是为什么上面的示例（过滤和修整）遍历文件，`SeqRecord`一次只查看一个文件。

然而，有时您不能使用大循环或迭代器——您可能需要随机访问读取。此处该`Bio.SeqIO.index()`函数可能非常有用，因为它允许您通过名称访问 FASTQ 文件中的任何读取（参见第[5.4.2](https://biopython-org.translate.goog/DIST/docs/tutorial/Tutorial.html?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN&_x_tr_pto=wapp&_x_tr_sch=http#sec%3ASeqIO-index)）。

我们将再次使用来自 ENA ( [ftp://ftp.sra.ebi.ac.uk/vol1/fastq/SRR020/SRR020192/SRR020192.fastq.gz](https://translate.google.com/website?sl=auto&tl=zh-CN&hl=zh-CN&client=webapp&u=ftp://ftp.sra.ebi.ac.uk/vol1/fastq/SRR020/SRR020192/SRR020192.fastq.gz) ) 的SRR020192.fastq文件，尽管这实际上很小少于 50,000 次读取的 FASTQ 文件：

```
>>> 从 Bio 导入 SeqIO
>>> fq_dict = SeqIO.index("SRR020192.fastq", "fastq")
>>> len(fq_dict)
41892
>>> 列表（fq_dict.keys（））[：4]
['SRR020192.38240', 'SRR020192.23181', 'SRR020192.40568', 'SRR020192.23186']
>>> fq_dict["SRR020192.23186"].seq
Seq('GTCCCAGTATTCGGATTTGTCTGCCAAAAACAATGAAATTGACACAGTTTACAAC...CCG')
```

当在具有 700 万次读取的 FASTQ 文件上对此进行测试时，索引建立大约需要一分钟，但记录访问几乎是即时的。

姊妹函数`Bio.SeqIO.index_db()`允许您将索引保存到 SQLite3 数据库文件中，以便近乎即时地重用[-](https://biopython-org.translate.goog/DIST/docs/tutorial/Tutorial.html?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN&_x_tr_pto=wapp&_x_tr_sch=http#sec%3ASeqIO-index)有关更多详细信息，请参阅第 5.4.2 节。

章节[20.1.5](https://biopython-org.translate.goog/DIST/docs/tutorial/Tutorial.html?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN&_x_tr_pto=wapp&_x_tr_sch=http#sec%3ASeqIO-sort)展示了如何使用该`Bio.SeqIO.index()`函数对大型 FASTA 文件进行排序——这也可以用于 FASTQ 文件。

## 20.1.12 转换 SFF 文件



如果您使用 454 (Roche) 序列数据，您可能可以访问标准流程图格式 (SFF) 文件形式的原始数据。这包含具有质量分数和原始流信息的序列读取（称为碱基）。

一个常见的任务是将 SFF 转换为一对 FASTA 和 QUAL 文件，或转换为单个 FASTQ 文件。这些操作使用`Bio.SeqIO.convert()`函数是微不足道的（参见章节[‍ 5.5.2](https://biopython-org.translate.goog/DIST/docs/tutorial/Tutorial.html?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN&_x_tr_pto=wapp&_x_tr_sch=http#sec%3ASeqIO-conversion)）：

```
>>> 从 Bio 导入 SeqIO
>>> SeqIO.convert("E3MFGYR02_random_10_reads.sff", "sff", "reads.fasta", "fasta")
10
>>> SeqIO.convert("E3MFGYR02_random_10_reads.sff", "sff", "reads.qual", "qual")
10
>>> SeqIO.convert("E3MFGYR02_random_10_reads.sff", "sff", "reads.fastq", "fastq")
10
```

请记住，convert 函数返回记录数，在这个例子中只有十条。这将为您提供*未修剪的*读数，其中前导和尾随的低质量序列或接头将采用小写形式。如果你想要*修剪的*读数（使用 SFF 文件中记录的剪辑信息）使用这个：

```
>>> 从 Bio 导入 SeqIO
>>> SeqIO.convert("E3MFGYR02_random_10_reads.sff", "sff-trim", "trimmed.fasta", "fasta")
10
>>> SeqIO.convert("E3MFGYR02_random_10_reads.sff", "sff-trim", "trimmed.qual", "qual")
10
>>> SeqIO.convert("E3MFGYR02_random_10_reads.sff", "sff-trim", "trimmed.fastq", "fastq")
10
```

如果您运行 Linux，您可以向 Roche 索取他们的“off instrument”工具（通常称为 Newbler 工具）的副本。这提供了一种在命令行中将 SFF 转换为 FASTA 或 QUAL 的替代方法（但目前不支持 FASTQ 输出），例如

```
$ sffinfo -seq -notrim E3MFGYR02_random_10_reads.sff > reads.fasta
$ sffinfo -qual -notrim E3MFGYR02_random_10_reads.sff > reads.qual
$ sffinfo -seq -trim E3MFGYR02_random_10_reads.sff > trimmed.fasta
$ sffinfo -qual -trim E3MFGYR02_random_10_reads.sff > trimmed.qual
```

Biopython 使用混合大小写序列字符串来表示修整点的方式故意模仿了 Roche 工具所做的事情。

有关 Biopython SFF 支持的更多信息，请参阅内置帮助：

```
>>> 从 Bio.SeqIO 导入 SffIO
>>> 帮助（SffIO）
```

## 20.1.13 识别开放阅读框

识别可能基因的一个非常简单的第一步是寻找开放阅读框 (ORF)。我们的意思是在所有六个框架中寻找没有终止密码子的长区域——一个 ORF 只是一个没有框架终止密码子的核苷酸区域。

当然，要找到一个基因，您还需要担心定位起始密码子、可能的启动子——而在真核生物中，也有内含子需要担心。然而，这种方法在病毒和原核生物中仍然有用。

为了展示您如何使用 Biopython 处理这个问题，我们需要一个序列来搜索，作为示例，我们将再次使用细菌质粒——尽管这次我们将从一个没有预先标记基因的普通 FASTA 文件开始：[NC_005816.fna](https://translate.google.com/website?sl=auto&tl=zh-CN&hl=zh-CN&client=webapp&u=https://raw.githubusercontent.com/biopython/biopython/master/Tests/GenBank/NC_005816.fna)。这是一个细菌序列，所以我们要使用 NCBI 密码子表 11（参见第[3.8](https://biopython-org.translate.goog/DIST/docs/tutorial/Tutorial.html?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN&_x_tr_pto=wapp&_x_tr_sch=http#sec%3Atranslation)关于翻译）。

```
>>> 从 Bio 导入 SeqIO
>>> record = SeqIO.read("NC_005816.fna", "fasta")
>>> 表 = 11
>>> min_pro_len = 100
```

这是一个巧妙的技巧，使用`Seq`对象的`split`方法来获取六个阅读框架中所有可能的 ORF 翻译的列表：

```
>>> 对于 [(+1, record.seq), (-1, record.seq.reverse_complement())] 中的链，nuc：
...对于范围内的框架（3）：
... length = 3 * ((len(record) - frame) // 3) # 三的倍数
... 对于 nuc[frame : frame + length].translate(table).split("*") 中的 pro：
... 如果 len(pro) >= min_pro_len:
... 打印（
...“%s...%s - 长度 %i，链 %i，框架 %i”
... % (pro[:30], pro[-3:], len(pro), strand, frame)
...）
...
GCLMKKSSIVATIITILSGSANAASSQLIP...YRF - 长度 315，链 1，帧 0
KSGELRQTPPASSTLHLRLILQRSGVMMEL...NPE - 长度 285，股线 1，框架 1
GLNCSFFSICNWKFIDYINRLFQIIYLCKN...YYH - 长度 176，链 1，框架 1
VKKILYIKALFLCTVIKLRRFIFSVNNMKF...DLP - 长度 165，股 1，框架 1
NQIQGVICSPDSGEFMVTFETVMEIKILHK...GVA - 长度 355，股线 1，框架 2
RRKEHVSKKRRPQKRPRRRRFFHRLRPPDE...PTR - 长度 128，链 1，框架 2
TGKQNSCQMSAIWQLRQNTATKTRQNRARI...AIK - 长度 100，链 1，框架 2
QGSGYAFHASILSGIAMSHFYFLVLHAVK...CSD - 长度 114，链 -1，框架 0
IYSTSEHTGEQVMRTLDEVIASRSPESQTR...FHV - 长度 111，链 -1，帧 0
WGKLQVIGLSMWMVLFSQRFDDWLNEQEDA...ESK - 长度 125，链 -1，框架 1
RGIFMSDTMVVNGSGGVPAFLFSGSTLSSY...LLK - 长度 361，链 -1，框架 1
WDVKTVTGVLHHPFHLTFSLCPEGATQSGR...VKR - 长度 111，链 -1，框架 1
LSHTVTDFTDQMAQVGLCQCVNVFLDEVTG...KAA - 长度 107，链 -1，框架 2
RALTGLSAPGIRSQTSCDRLRELRYVPVSL...PLQ - 长度 119，链 -1，框架 2
```

*请注意，这里我们从每条*链的 5' 端（开始）开始计算帧数。*有时总是从正向*链的 5' 末端（开始）开始计数会更容易。

您可以轻松编辑上述基于循环的代码来构建候选蛋白质列表，或将其转换为列表理解。现在，这段代码没有做的一件事是跟踪蛋白质的位置。

您可以通过多种方式解决这个问题。例如，以下代码根据蛋白质计数跟踪位置，并通过乘以三转换回父序列，然后针对框架和链进行调整：

```
从 Bio 导入 SeqIO

record = SeqIO.read("NC_005816.gb", "genbank")
表 = 11
min_pro_len = 100


def find_orfs_with_trans(seq, trans_table, min_protein_length):
    答案 = []
    seq_len = len(序列)
    对于 [(+1, seq), (-1, seq.reverse_complement())] 中的链，nuc：
        对于范围内的帧（3）：
            trans = nuc[frame:].translate(trans_table)
            trans_len = len(反式)
            aa_start = 0
            aa_end = 0
            而 aa_start < trans_len:
                aa_end = trans.find("*", aa_start)
                如果 aa_end == -1：
                    aa_end = trans_len
                如果 aa_end - aa_start >= min_protein_length：
                    如果链 == 1：
                        开始 = 帧 + aa_start * 3
                        end = min(seq_len, frame + aa_end * 3 + 3)
                    别的：
                        开始 = seq_len - 帧 - aa_end * 3 - 3
                        结束 = seq_len - 帧 - aa_start * 3
                    answer.append((开始, 结束, strand, trans[aa_start:aa_end]))
                aa_start = aa_end + 1
    回答.排序()
    返回答案


orf_list = find_orfs_with_trans(record.seq, table, min_pro_len)
对于 orf_list 中的开始、结束、链、pro：
    打印（
        “%s...%s - 长度 %i，链 %i，%i:%i”
        % (pro[:30], pro[-3:], len(pro), 链, 开始, 结束)
    )
```

输出：

```
NQIQGVICSPDSGEFMVTFETVMEIKILHK...GVA - 长度 355，第 1 股，41：1109
WDVKTVTGVLHHPFHLTFSLCPEGATQSGR...VKR - 长度 111，链 -1，491:827
KSGELRQTPPASSTLHLRLILQRSGVMMEL...NPE - 长度 285，第 1 股，1030:1888
RALTGLSAPGIRSQTSCDRLRELRYVPVSL...PLQ - 长度 119，链 -1，2830:3190
RRKEHVSKKRRPQKRPRRRRFFHRLRPPDE...PTR - 长度 128，第 1 股，3470:3857
GLNCSFFSICNWKFIDYINRLFQIIYLCKN...YYH - 长度 176，第 1 股，4249:4780
RGIFMSDTMVVNGSGGVPAFLFSGSTLSSY...LLK - 长度 361，链 -1，4814:5900
VKKILYIKALFLCTVIKLRRFIFSVNNMKF...DLP - 长度 165，第 1 股，5923:6421
LSHTVTDFTDQMAQVGLCQCVNVFLDEVTG...KAA - 长度 107，链 -1，5974:6298
GCLMKKSSIVATIITILSGSANAASSQLIP...YRF - 长度 315，第 1 股，6654:7602
IYSTSEHTGEQVMRTLDEVIASRSPESQTR...FHV - 长度 111，链 -1，7788:8124
WGKLQVIGLSMWMVLFSQRFDDWLNEQEDA...ESK - 长度 125，链 -1，8087:8465
TGKQNSCQMSAIWQLRQNTATKTRQNRARI...AIK - 长度 100，链 1，8741:9044
QGSGYAFHASILSGIAMSHFYFLVLHAVK...CSD - 长度 114，链 -1，9264:9609
```

如果你注释掉 sort 语句，那么蛋白质序列将以与之前相同的顺序显示，所以你可以检查这是在做同样的事情。在这里，我们按位置对它们进行了排序，以便更容易与 GenBank 文件中的实际注释进行比较（如[第 17.1.9](https://biopython-org.translate.goog/DIST/docs/tutorial/Tutorial.html?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN&_x_tr_pto=wapp&_x_tr_sch=http#sec%3Agd_nice_example)）。

然而，如果您只想找到开放阅读框的位置，那么翻译每个可能的密码子都是浪费时间，包括进行反向互补以搜索反向链。您需要做的就是搜索可能的终止密码子（及其反向互补）。在这里使用正则表达式是一种显而易见的方法（请参阅 Python 模块`re`）。这些是描述搜索字符串的极其强大（但相当复杂）的方式，许多编程语言和命令行工具（如grep）都支持这种方式。你可以找到关于这个主题的整本书！

# 20.2 序列解析加简单图

本节展示更多序列解析示例，使用`Bio.SeqIO`第[5](https://biopython-org.translate.goog/DIST/docs/tutorial/Tutorial.html?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN&_x_tr_pto=wapp&_x_tr_sch=http#chapter%3Aseqio)，以及 Python 库 matplotlib 的`pylab`绘图接口（[有关教程，请参见 matplotlib 网站](https://translate.google.com/website?sl=auto&tl=zh-CN&hl=zh-CN&client=webapp&u=https://matplotlib.org)）。请注意，要遵循这些示例，您需要安装 matplotlib - 但如果没有它，您仍然可以尝试数据解析位。

## 20.2.1 序列长度直方图

很多时候您可能想要可视化数据集中序列长度的分布——例如基因组组装项目中重叠群大小的范围。在这个例子中，我们将重用我们的兰花 FASTA 文件[ls_orchid.fasta](https://translate.google.com/website?sl=auto&tl=zh-CN&hl=zh-CN&client=webapp&u=https://raw.githubusercontent.com/biopython/biopython/master/Doc/examples/ls_orchid.fasta)，它只有 94 个序列。

首先，我们将使用`Bio.SeqIO`FASTA 文件解析并编译所有序列长度的列表。您可以使用 for 循环执行此操作，但我发现列表理解更令人愉悦：

```
>>> 从 Bio 导入 SeqIO
>>> sizes = [len(rec) for rec in SeqIO.parse("ls_orchid.fasta", "fasta")]
>>> len(尺寸), min(尺寸), max(尺寸)
(94, 572, 789)
>>> 尺码
[740, 753, 748, 744, 733, 718, 730, 704, 740, 709, 700, 726, ..., 592]
```

现在我们有了所有基因的长度（作为整数列表），我们可以使用 matplotlib 直方图函数来显示它。

```
从 Bio 导入 SeqIO

sizes = [len(rec) for rec in SeqIO.parse("ls_orchid.fasta", "fasta")]

导入pylab

pylab.hist（大小，bins=20）
pylab.title(
    “%i 兰花序列\n长度 %i 到 %i” % (len(sizes), min(sizes), max(sizes))
)
pylab.xlabel("序列长度(bp)")
pylab.ylabel("计数")
pylab.show()
```

这应该会弹出一个包含下图的新窗口：

![img](https://translate.google.com/website?sl=auto&tl=zh-CN&hl=zh-CN&client=webapp&u=http://biopython.org/DIST/docs/tutorial/images/hist_plot.png)

请注意，大多数这些兰花序列的长度约为 740 bp，并且这里可能有两类不同的序列和较短序列的子集。

*提示：*除了用于`pylab.show()`在窗口中显示绘图，您还可以使用`pylab.savefig(...)`将图形保存到文件（例如 PNG 或 PDF）。

## 20.2.2 序列 GC% 图

核苷酸序列的另一个容易计算的量是 GC%。例如，您可能想查看细菌基因组中所有基因的 GC%，并调查最近可能通过水平基因转移获得的任何异常值。同样，对于这个例子，我们将重用我们的兰花 FASTA 文件[ls_orchid.fasta](https://translate.google.com/website?sl=auto&tl=zh-CN&hl=zh-CN&client=webapp&u=https://raw.githubusercontent.com/biopython/biopython/master/Doc/examples/ls_orchid.fasta)。

首先，我们将用于`Bio.SeqIO`解析 FASTA 文件并编译所有 GC 百分比的列表。同样，您可以使用 for 循环执行此操作，但我更喜欢这样：

```
从 Bio 导入 SeqIO
从 Bio.SeqUtils 导入 gc_fraction

gc_values =排序（
    100 * gc_fraction(rec.seq) for rec in SeqIO.parse("ls_orchid.fasta", "fasta")
)
```

读取每个序列并计算 GC% 后，我们将它们按升序排序。现在我们将采用这个浮点值列表并使用 matplotlib 绘制它们：

```
导入pylab

pylab.plot（gc_values）
pylab.title(
    “%i 兰花序列\nGC%% %0.1f 到 %0.1f”
    % (len(gc_values), min(gc_values), max(gc_values))
)
pylab.xlabel("基因")
pylab.ylabel("GC%")
pylab.show()
```

与前面的示例一样，应该会弹出一个包含图表的新窗口：

![img](https://translate.google.com/website?sl=auto&tl=zh-CN&hl=zh-CN&client=webapp&u=http://biopython.org/DIST/docs/tutorial/images/gc_plot.png)

如果你在一个生物体的全套基因上尝试这个，你可能会得到比这更平滑的图。

## 20.2.3 核苷酸点图

点图是一种直观地比较两个核苷酸序列彼此相似性的方法。滑动窗口用于比较短子序列，通常带有不匹配阈值。这里为简单起见，我们将只寻找完美匹配（在下图中以黑色显示）。

首先，我们需要两个序列。为了便于讨论，我们只从我们的兰花 FASTA 文件[ls_orchid.fasta](https://translate.google.com/website?sl=auto&tl=zh-CN&hl=zh-CN&client=webapp&u=https://raw.githubusercontent.com/biopython/biopython/master/Doc/examples/ls_orchid.fasta)中取出前两个：

```
从 Bio 导入 SeqIO

打开（“ls_orchid.fasta”）作为 in_handle：
    record_iterator = SeqIO.parse(in_handle, "fasta")
    rec_one = next(record_iterator)
    rec_two = next(record_iterator)
```

我们将展示两种方法。首先，一个简单的天真实现将所有窗口大小的子序列相互比较以编译相似度矩阵。您可以构造一个矩阵或数组对象，但这里我们只使用通过嵌套列表理解创建的布尔列表列表：

```
窗口 = 7
seq_one = rec_one.seq.upper()
seq_two = rec_two.seq.upper()
数据 = [
    [
        (seq_one[i : i + window] != seq_two [j : j + window])
        对于范围内的 j(len(seq_one) - 窗口)
    ]
    对于范围内的我（len（seq_two）-窗口）
]
```

请注意，我们没有*在*此处检查反向补码匹配。现在我们将使用 matplotlib 的`pylab.imshow()`函数来显示这些数据，首先请求灰色配色方案，所以这是黑白的：

```
导入pylab

pylab.gray()
pylab.imshow（数据）
pylab.xlabel("%s (length %i bp)" % (rec_one.id, len(rec_one)))
pylab.ylabel("%s (length %i bp)" % (rec_two.id, len(rec_two)))
pylab.title("点图使用窗口大小 %i\n(不允许不匹配)" % window)
pylab.show()
```

这应该会弹出一个包含如下图形的新窗口：

![img](https://translate.google.com/website?sl=auto&tl=zh-CN&hl=zh-CN&client=webapp&u=http://biopython.org/DIST/docs/tutorial/images/dot_plot.png)

如您所料，这两个序列非常相似，沿对角线有部分窗口大小的匹配项。没有指示反转或其他有趣事件的非对角线匹配。

上面的代码在小例子上运行良好，但是将它应用到更大的序列有两个问题，我们将在下面解决。首先，这种针对所有比较的蛮力方法非常缓慢。相反，我们将编译将窗口大小的子序列映射到它们的位置的字典，然后采用集合交集来查找在两个序列中找到的那些子序列。这会使用更多内存，但速度*更快*。其次，该`pylab.imshow()`功能受限于它可以显示的矩阵大小。作为替代方案，我们将使用该`pylab.scatter()`功能。

我们首先创建字典，将窗口大小的子序列映射到位置：

```
窗口 = 7
dict_one = {}
dict_two = {}
对于 (seq, section_dict) 在 [
    (rec_one.seq.upper(), dict_one),
    (rec_two.seq.upper(), dict_two),
]：
    对于范围内的我（len（seq）-窗口）：
        section = seq[i : i + 窗口]
        尝试：
            section_dict[section].append(i)
        除了 KeyError：
            section_dict[section] = [i]
# 现在找到在两个序列中找到的任何子序列
匹配 = 设置（dict_one）.intersection（dict_two）
print("%i 个唯一匹配项" % len(匹配项))
```

为了使用`pylab.scatter()`我们需要单独的*x*和*y*坐标列表：

```
# 为散点图创建 x 和 y 坐标列表
x = []
y = []
对于比赛中的部分：
    对于 dict_one[section] 中的 i：
        对于 j in dict_two[section]：
            x.append(i)
            y.追加(j)
```

我们现在准备将修改后的点图绘制为散点图：

```
导入pylab

pylab.cla() # 清除任何先前的图
pylab.gray()
pylab.scatter（x，y）
pylab.xlim(0, len(rec_one) - 窗口)
pylab.ylim(0, len(rec_two) - 窗口)
pylab.xlabel("%s (length %i bp)" % (rec_one.id, len(rec_one)))
pylab.ylabel("%s (length %i bp)" % (rec_two.id, len(rec_two)))
pylab.title("点图使用窗口大小 %i\n(不允许不匹配)" % window)
pylab.show()
```

这应该会弹出一个包含如下图形的新窗口：

![img](https://translate.google.com/website?sl=auto&tl=zh-CN&hl=zh-CN&client=webapp&u=http://biopython.org/DIST/docs/tutorial/images/dot_plot_scatter.png)

我个人觉得第二个情节更容易阅读！再次注意，我们在这里*没有*检查反向互补匹配——你可以扩展这个例子来做这个，也许用一种颜色绘制正向匹配，用另一种颜色绘制反向匹配。

## 20.2.4 绘制测序读取数据的质量分数

如果您正在处理二代测序数据，您可能想尝试绘制质量数据。下面是一个使用两个包含成对末端读取的 FASTQ 文件的示例，SRR001666_1.fastq用于正向读取，SRR001666_2.fastq用于反向读取。这些是从 ENA 序列读取存档 FTP 站点（[ftp://ftp.sra.ebi.ac.uk/vol1/fastq/SRR001/SRR001666/SRR001666_1.fastq.gz](https://translate.google.com/website?sl=auto&tl=zh-CN&hl=zh-CN&client=webapp&u=ftp://ftp.sra.ebi.ac.uk/vol1/fastq/SRR001/SRR001666/SRR001666_1.fastq.gz)和[ftp://ftp.sra.ebi）下载的。 ac.uk/vol1/fastq/SRR001/SRR001666/SRR001666_2.fastq.gz](https://translate.google.com/website?sl=auto&tl=zh-CN&hl=zh-CN&client=webapp&u=ftp://ftp.sra.ebi.ac.uk/vol1/fastq/SRR001/SRR001666/SRR001666_2.fastq.gz)），并且来自*大肠杆菌*——详情见[https://www.ebi.ac.uk/ena/data/view/SRR001666 。](https://translate.google.com/website?sl=auto&tl=zh-CN&hl=zh-CN&client=webapp&u=https://www.ebi.ac.uk/ena/data/view/SRR001666)

在下面的代码中，该`pylab.subplot(...)`函数用于并排显示两个子图的正向和反向质量。还有一些代码只绘制前五十个读数。

```
导入pylab
从 Bio 导入 SeqIO

对于 [1, 2] 中的子图：
    filename = "SRR001666_%i.fastq" % 子图
    pylab.subplot(1, 2, 子图)
    对于我，记录在枚举中（SeqIO.parse（文件名，“fastq”））：
        如果我 >= 50：
            破#绝招！
        pylab.plot(record.letter_annotations["phred_quality"])
    pylab.ylim(0, 45)
    pylab.ylabel("PHRED 质量得分")
    pylab.xlabel("位置")
pylab.savefig("SRR001666.png")
打印（“完成”）
```

您应该注意，我们在这里使用`Bio.SeqIO`格式名称fastq，因为 NCBI 使用带有 PHRED 分数的标准 Sanger FASTQ 格式保存这些读数。然而，正如您可能从读取长度猜到的那样，该数据来自 Illumina 基因组分析仪，并且最初可能采用两种 Solexa/Illumina FASTQ 变体文件格式之一。

此示例使用`pylab.savefig(...)`函数而不是`pylab.show(...)`，但如前所述，两者都很有用。这是结果：

![img](https://translate.google.com/website?sl=auto&tl=zh-CN&hl=zh-CN&client=webapp&u=http://biopython.org/DIST/docs/tutorial/images/SRR001666.png)

# 20.3 处理对齐

本节可以看作是第[6](https://biopython-org.translate.goog/DIST/docs/tutorial/Tutorial.html?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN&_x_tr_pto=wapp&_x_tr_sch=http#chapter%3Aalign)。

## 20.3.1 计算汇总信息

对齐后，您很可能会想要查找有关它的信息。我们没有尝试让所有可以生成关于对齐对象本身的对齐信息的函数，而是尝试将功能分离到单独的类中，这些类作用于对齐。

准备计算有关对象的摘要信息很快就可以完成。假设我们有一个名为 的对齐对象`alignment`，例如`Bio.AlignIO.read(...)`按照第[6](https://biopython-org.translate.goog/DIST/docs/tutorial/Tutorial.html?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN&_x_tr_pto=wapp&_x_tr_sch=http#chapter%3Aalign)使用 read in using 。我们需要做的就是获得一个计算摘要信息的对象：

```
从 Bio.Align 导入 AlignInfo

summary_align = AlignInfo.SummaryInfo(对齐方式)
```

该`summary_align`对象非常有用，将为您完成以下巧妙的事情：

1. 计算一个快速一致的序列——见章节[‍ 20.3.2](https://biopython-org.translate.goog/DIST/docs/tutorial/Tutorial.html?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN&_x_tr_pto=wapp&_x_tr_sch=http#sec%3Aconsensus)
2. 获取对齐的位置特定分数矩阵 - 参见章节[‍ 20.3.3](https://biopython-org.translate.goog/DIST/docs/tutorial/Tutorial.html?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN&_x_tr_pto=wapp&_x_tr_sch=http#sec%3Apssm)
3. 计算比对的信息内容——见章节[‍ 20.3.4](https://biopython-org.translate.goog/DIST/docs/tutorial/Tutorial.html?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN&_x_tr_pto=wapp&_x_tr_sch=http#sec%3Agetting_info_content)
4. 生成关于对齐中替换的信息——[第 20.4](https://biopython-org.translate.goog/DIST/docs/tutorial/Tutorial.html?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN&_x_tr_pto=wapp&_x_tr_sch=http#sec%3Asub_matrix)详细介绍了使用它来生成替换矩阵。

## 20.3.2 计算快速一致序列

`SummaryInfo`在[‍ 20.3.1](https://biopython-org.translate.goog/DIST/docs/tutorial/Tutorial.html?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN&_x_tr_pto=wapp&_x_tr_sch=http#sec%3Asummary_info)提供了计算对齐的快速共识的功能。假设我们有一个`SummaryInfo`名为的对象，`summary_align`我们可以通过执行以下操作来计算共识：

```
共识 = summary_align.dumb_consensus()
```

顾名思义，这是一个非常简单的共识计算器，只会将共识中每个点的所有残差相加，如果最常见的值高于某个阈值，则会将共同的残差添加到共识中。如果它没有达到阈值，它会在共识中添加一个模糊字符。返回的共识对象是一个`Seq`对象。

您可以`dumb_consensus`通过传递可选参数来调整工作方式：

- **门槛**

  这是一个阈值，指定特定残基在添加之前必须在某个位置出现的频率。默认值为 0.7（表示 70%）。

- **暧昧的性格**

  这是要使用的歧义字符。默认值为“N”。

## 20.3.3 位置特定分数矩阵



位置特定分数矩阵 (PSSM) 以不同于共识的方式总结比对信息，可能对不同的任务有用。基本上，PSSM 是一个计数矩阵。对于比对中的每一列，计算每个字母的数量并求和。总计相对于沿左轴的一些代表性序列显示。该序列可以是共有序列，但也可以是比对中的任何序列。例如对于对齐，

```
总工会
AT-C
CTGTC
```

PSSM 是：

```
      海关总署
    克 1 1 0 1
    0 0 3 0
    1 1 0 0
    0 0 2 0
    C 0 0 0 3
```

假设我们有一个名为 的对齐对象`c_align`。为了获得带有共识序列的 PSSM，我们首先获得一个摘要对象并计算共识序列：

```
summary_align = AlignInfo.SummaryInfo(c_align)
共识 = summary_align.dumb_consensus()
```

现在，我们想要制作 PSSM，但`N`在计算时忽略任何模糊残差：

```
my_pssm = summary_align.pos_specific_score_matrix（共识，chars_to_ignore = [“N”]）
```

对此应注意两点：

1. 为了保持字母表的严格性，您只能在 PSSM 顶部包含对齐对象字母表中的字符。PSSM 的顶轴不包括间隙。

2. 传递给轴左侧显示的序列不需要是一致的。例如，如果您想显示沿此轴对齐的第二个序列，您需要执行以下操作：

   ```
   second_seq = alignment.get_seq_by_num(1)
   my_pssm = summary_align.pos_specific_score_matrix(second_seq, chars_to_ignore=["N"])
   ```

上面的命令返回一个`PSSM`对象。要打印出如上所示的 PSSM，我们只需执行一个`print(my_pssm)`，它会给出：

```
    ACGT
T 0.0 0.0 0.0 7.0
一个 7.0 0.0 0.0 0.0
T 0.0 0.0 0.0 7.0
一个 7.0 0.0 0.0 0.0
C 0.0 7.0 0.0 0.0
一个 7.0 0.0 0.0 0.0
T 0.0 0.0 0.0 7.0
T 1.0 0.0 0.0 6.0
...
```

您可以通过下标访问 PSSM 的任何元素`your_pssm[sequence_number][residue_count_name]`。例如，要获取上述 PSSM 的第二个元素中“A”残基的计数，您可以执行以下操作：

```
>>> 打印（my_pssm[1][“A”]）
7.0
```

PSSM 类的结构有望使访问元素和漂亮地打印矩阵变得容易。

## 20.3.4 信息内容



一个可能有用的进化保护措施是序列的信息内容。

[可以在http://www.lecb.ncifcrf.gov/~toms/paper/primer/](https://translate.google.com/website?sl=auto&tl=zh-CN&hl=zh-CN&client=webapp&u=http://www.lecb.ncifcrf.gov/~toms/paper/primer/)找到针对分子生物学家的有用的信息论介绍。出于我们的目的，我们将查看一致序列或一致序列的一部分的信息内容。我们使用以下公式计算多序列比对中特定列的信息含量：

| *j* =  *_* | *纳**_*∑*我*=1 | *日志**_*  *_* | ⎛ ⎜ ⎜ ⎝ | *P* *ij**qi* *_* | ⎞ ⎟ ⎟ ⎠ |
| ---------- | -------------- | -------------- | ------- | ---------------- | ------- |
|            |                |                |         |                  |         |

在哪里：

- *IC* *j* –比对中第*j*列的信息内容。
- *N* *a* – 字母表中的字母数。
- *P* *ij* *– 特定字母i*在第*j*列中的频率（i. ‍e. ‍如果 G 在对齐列中出现 6 次中的 3 次，则为 0.5）
- *Q* *i* – 字母*i*的预期频率。这是一个可选参数，其使用由用户自行决定。默认情况下，蛋白质字母表自动分配为 0.05 = 1/20，核酸字母表自动分配为 0.25 = 1/4。这是为了在不假设任何先验分布的情况下获取信息内容。当假设先验或使用非标准字母表时，您应该提供*Q* *i*的值。

好吧，现在我们已经了解了 Biopython 中正在计算的信息内容，让我们看看如何为比对的特定区域获取它。

首先，我们需要使用我们的比对来获取比对摘要对象，我们假设它被调用`summary_align`（参见[‍20.3.1](https://biopython-org.translate.goog/DIST/docs/tutorial/Tutorial.html?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN&_x_tr_pto=wapp&_x_tr_sch=http#sec%3Asummary_info)）以获取有关如何获取此对象的说明。一旦我们得到这个对象，计算一个区域的信息内容就很容易了：

```
info_content = summary_align.information_content(5, 30, chars_to_ignore=["N"])
```

哇，这比上面的公式看起来要容易得多！该变量`info_content`现在包含一个浮点值，指定指定区域（从对齐的 5 到 30）上的信息内容。我们在计算信息内容时特别忽略了歧义残差“N”，因为这个值不包含在我们的字母表中（所以我们不应该对它感兴趣！）。

如上所述，我们还可以通过提供具有预期频率的字典来计算相关信息内容：

```
expect_freq = {“A”：0.3，“G”：0.2，“T”：0.3，“C”：0.2}
info_content = summary_align.information_content(
    5、30、e_freq_table=e_freq_table、chars_to_ignore=["N"]
)
```

现在，`info_content`将包含与预期频率相关的区域的相关信息内容。

返回值是在上面的公式中以2为底数作为对数底数计算出来的。您可以通过将参数`log_base`作为所需的基础传递来修改它：

```
info_content = summary_align.information_content(
    5、30，log_base=10，chars_to_ignore=["N"]
)
```

默认情况下，在计算该列的相关信息列时，不考虑该列中频率为 0 的核苷酸或氨基酸残基。如果这不是所需的结果，您可以改用`pseudo_count`。

```
info_content = summary_align.information_content(
    5, 30, chars_to_ignore=["N"], 伪计数=1
)
```

*在这种情况下，第j*列中特定字母*i*的观测频率*P* *ij*计算如下：

| *P* *ij* = | *n* *ij* +  *k* ×  *Q* *i**j* +  *k* *_* |
| ---------- | ---------------------------------------- |
|            |                                          |

在哪里：

- *k——*你作为参数传递的伪计数。
- *k——*你作为参数传递的伪计数。
- *Q* *i* –如上所述的字母*i的预期频率。*

好了，现在您可以计算信息内容了。如果您想尝试将此应用于一些现实生活中的问题，最好深入研究有关信息内容的文献以了解它是如何使用的。希望您的挖掘不会揭示在编写此函数时所犯的任何错误！

# 20.4 置换矩阵

替代矩阵是日常生物信息学工作中极其重要的一部分。它们提供了用于对两个不同残基相互替代的可能性进行分类的评分项。这对于进行序列比较是必不可少的。Durbin 等人的书“生物序列分析”。提供了对替换矩阵及其用途的非常好的介绍。一些著名的替换矩阵是 PAM 和 BLOSUM 系列矩阵。

Biopython 提供了大量的通用替换矩阵，还提供了创建您自己的替换矩阵的功能。

## 20.4.1 使用通用替换矩阵

## 20.4.2 从多序列比对计算替换矩阵



您可以根据比对创建自己的替换矩阵。在本例中，我们将首先从 Clustalw 文件[protein.aln](https://biopython-org.translate.goog/DIST/docs/tutorial/examples/protein.aln?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN&_x_tr_pto=wapp&_x_tr_sch=http)中读取蛋白质序列比对（也可[在此处](https://translate.google.com/website?sl=auto&tl=zh-CN&hl=zh-CN&client=webapp&u=https://raw.githubusercontent.com/biopython/biopython/master/Doc/examples/protein.aln)在线获取）

```
>>> 从 Bio 导入 AlignIO
>>> 文件名 = "protein.aln"
>>> alignment = AlignIO.read(文件名, "clustal")
```

第[‍ 6.5.1](https://biopython-org.translate.goog/DIST/docs/tutorial/Tutorial.html?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN&_x_tr_pto=wapp&_x_tr_sch=http#sec%3Aalign_clustal)包含有关执行此操作的更多信息。

比对的属性`substitutions`存储了不同残基相互替换的次数：

```
>>> observed_frequencies = 对齐.替换
```

为了使示例更具可读性，我们将仅选择带有带极性电荷的侧链的氨基酸：

```
>>> observed_frequencies = observed_frequencies.select("DEHKR")
>>> 打印（观察到的频率）
       DEHKR
D 2360.0 255.5 7.5 0.5 25.0
E 255.5 3305.0 16.5 27.0 2.0
高 7.5 16.5 1235.0 16.0 8.5
K 0.5 27.0 16.0 3218.0 116.5
R 25.0 2.0 8.5 116.5 2079.0
<空白>
```

其他氨基酸的行和列从矩阵中移除。

接下来，我们对矩阵进行归一化：

```
>>> 导入 numpy
>>> observed_frequencies /= numpy.sum(observed_frequencies)
```

对行或列求和给出每个残基出现的相对频率：

```
>>> residue_frequencies = numpy.sum(observed_frequencies, 0)
>>> print(residue_frequencies.format("%.4f"))
D 0.2015
E 0.2743
H 0.0976
K 0.2569
R 0.1697
<空白>
>>> numpy.sum(residue_frequencies)
1.0
```

残基对的预期频率是

```
>>> expected_frequencies = numpy.dot(
... residue_frequencies[:, None], residue_frequencies[None, :]
...）
>>> print(expected_frequencies.format("%.4f"))
       DEHKR
D 0.0406 0.0553 0.0197 0.0518 0.0342
E 0.0553 0.0752 0.0268 0.0705 0.0465
H 0.0197 0.0268 0.0095 0.0251 0.0166
K 0.0518 0.0705 0.0251 0.0660 0.0436
R 0.0342 0.0465 0.0166 0.0436 0.0288
<空白>
```

在这里，`residue_frequencies[:, None]`创建一个二维数组，其中包含一个值为 的单列`residue_frequencies`，以及`residue_frequencies[None, :]`一个将这些值作为单行的二维数组。取他们的点积（内积）会创建一个预期频率矩阵，其中每个条目都包含两个`residue_frequencies`相互相乘的值。例如，`expected_frequencies['D', 'E']`等于`residue_frequencies['D'] * residue_frequencies['E']`。

我们现在可以通过将观察到的频率除以预期频率并取对数来计算对数优势矩阵：

```
>>> m = numpy.log2(observed_frequencies / expected_frequencies)
>>> 打印（米）
      DEHKR
D 2.1 -1.5 -5.1 -10.4 -4.2
E -1.5 1.7 -4.4 -5.1 -8.3
高 -5.1 -4.4 3.3 -4.4 -4.7
K -10.4 -5.1 -4.4 1.9 -2.3
R -4.2 -8.3 -4.7 -2.3 2.5
<空白>
```

该矩阵可用作执行比对时的替换矩阵。例如，

```
>>> 从 Bio.Align 导入 PairwiseAligner
>>> 对齐器 = PairwiseAligner()
>>> aligner.substitution_matrix = m
>>> aligner.gap_score = -3.0
>>> alignments = aligner.align("DEHEK", "DHHKK")
>>> 打印（对齐[0]）
目标 0 DEHEK 5
                  0 |.|.| 5个
查询 0 DHHKK 5
<空白>
>>> print("%.2f" % alignments.score)
-2.18
>>> score = m["D", "D"] + m["E", "H"] + m["H", "H"] + m["E", "K"] + m [“K”，“K”]
>>> print("%.2f" % 分数)
-2.18
```

# 20.5 BioSQL——在关系数据库中存储序列

[BioSQL是](https://translate.google.com/website?sl=auto&tl=zh-CN&hl=zh-CN&client=webapp&u=https://www.biosql.org/)[OBF](https://translate.google.com/website?sl=auto&tl=zh-CN&hl=zh-CN&client=webapp&u=https://www.open-bio.org/wiki/Main_Page)项目（BioPerl、BioJava 等）之间的共同努力，以支持用于存储序列数据的共享数据库模式。理论上，您可以使用 BioPerl 将 GenBank 文件加载到数据库中，然后使用 Biopython 从数据库中提取它作为具有特征的记录对象 - 并获得或多或少与直接将 GenBank 文件加载为 SeqRecord 相同的东西使用`Bio.SeqIO`（第[‍ 5](https://biopython-org.translate.goog/DIST/docs/tutorial/Tutorial.html?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN&_x_tr_pto=wapp&_x_tr_sch=http#chapter%3Aseqio)）。

Biopython 的 BioSQL 模块目前记录在[http://biopython.org/wiki/BioSQL](https://biopython-org.translate.goog/wiki/BioSQL?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN&_x_tr_pto=wapp&_x_tr_sch=http)，这是我们维基页面的一部分。