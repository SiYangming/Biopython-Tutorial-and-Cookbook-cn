本章是关于多序列比对的，我们指的是多个序列的集合，这些序列已经比对在一起——通常插入间隙字符，并添加前导或尾随间隙——这样所有序列字符串的长度都相同。这样的对齐可以看作是一个字母矩阵，其中每一行在`SeqRecord`内部都作为一个对象保存。

我们将介绍`MultipleSeqAlignment`保存这种数据的对象，以及`Bio.AlignIO`以各种文件格式读写它们的模块（沿用`Bio.SeqIO`上一章模块的设计）。请注意， 和`Bio.SeqIO`都`Bio.AlignIO`可以读取和写入序列比对文件。适当的选择在很大程度上取决于您要对数据执行的操作。

本章的最后一部分是关于常见的多序列比对工具（如 ClustalW 和 MUSCLE）的命令行包装器。

## 6.1 解析或读取序列比对

我们有两个用于读取序列比对的函数，`Bio.AlignIO.read()`它们`Bio.AlignIO.parse()`遵循中介绍的约定`Bio.SeqIO`分别用于包含一个或多个比对的文件。

使用`Bio.AlignIO.parse()`将返回一个提供对象的迭代*器*`MultipleSeqAlignment`。迭代器通常用在 for 循环中。您将拥有多个不同比对的情况示例包括来自 PHYLIP 工具的重采样比对，或`seqboot`来自 EMBOSS 工具的多个成对比对，或 Bill Pearson 的 FASTA 工具。`water``needle`

然而，在许多情况下，您将处理仅包含一个对齐的文件。在这种情况下，您应该使用`Bio.AlignIO.read()`返回单个`MultipleSeqAlignment`对象的函数。

这两个函数都需要两个强制参数：

1. 第一个参数是一个从中读取数据的 handle，通常是一个打开的文件（参见第[23.1](https://biopython-org.translate.goog/DIST/docs/tutorial/Tutorial.html?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN&_x_tr_pto=wapp&_x_tr_sch=http#sec%3Aappendix-handles)*）*或一个文件名。
2. 第二个参数是指定对齐格式的小写字符串。正如`Bio.SeqIO`我们不会尝试为您猜测文件格式一样！有关受支持格式的完整列表，请参阅[http://biopython.org/wiki/AlignIO 。](https://biopython-org.translate.goog/wiki/AlignIO?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN&_x_tr_pto=wapp&_x_tr_sch=http)

还有一个可选`seq_count`参数，在下面的第[6.1.3](https://biopython-org.translate.goog/DIST/docs/tutorial/Tutorial.html?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN&_x_tr_pto=wapp&_x_tr_sch=http#sec%3AAlignIO-count-argument)用于处理可能包含多个对齐方式的不明确文件格式。

### 6.1.1 单一对齐

例如，考虑以下 PFAM 或斯德哥尔摩文件格式的注释丰富的蛋白质比对：

```
## 斯德哥尔摩 1.0
#=GS COATB_BPIKE/30-81 AC P03620.1
#=GS COATB_BPIKE/30-81 DR PDB；1if ; 1-52；
#=GS Q9T0Q8_BPIKE/1-52 AC Q9T0Q8.1
#=GS COATB_BPI22/32-83 AC P15416.1
#=GS COATB_BPM13/24-72 AC P69541.1
#=GS COATB_BPM13/24-72 DR PDB；2cpb; 1-49；
#=GS COATB_BPM13/24-72 DR PDB；2厘泊；1-49；
#=GS COATB_BPZJ2/1-49 AC P03618.1
#=GS Q9T0Q9_BPFD/1-49 AC Q9T0Q9.1
#=GS Q9T0Q9_BPFD/1-49 DR PDB；1nh4A；1-49；
#=GS COATB_BPIF1/22-73 AC P03619.2
#=GS COATB_BPIF1/22-73 DR PDB；1 如果 ; 1-50；
COATB_BPIKE/30-81 AEPNAATNYATEAMDSLKTQAIDLISQTWPVVTTVVVAGLVIRLFKKFSSKA
#=GR COATB_BPIKE/30-81 SS -HHHHHHHHHHHHHH--HHHHHHHH--HHHHHHHHHHHHHHHHHHHHHH----
Q9T0Q8_BPIKE/1-52 AEPNAATNYATEAMDSLKTQAIDLISQTWPVVTTVVVAGLVIKLFKKFVSRA
COATB_BPI22/32-83 DGTSTATSYATEAMNSLKTQATDLIDQTWPVVTSVAVAGLAIRLFKKFSSKA
COATB_BPM13/24-72 AEGDDP...AKAAFNSLQASATEYIGYAWAMVVVIVGATIGIKLFKKFTSKA
#=GR COATB_BPM13/24-72 SS ---ST...CHCHHHHCCCCTCCCCTTCHHHHHHHHHHHHHHHHHHHHCTT--
COATB_BPZJ2/1-49 AEGDDP...AKAAFDSLQASATEYIGYAWAMVVVIVGATIGIKLFKKFASKA
Q9T0Q9_BPFD/1-49 AEGDDP...AKAAFDSLQASATEYIGYAWAMVVVIVGATIGIKLFKKFTSKA
#=GR Q9T0Q9_BPFD/1-49 SS ------...-HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH--
COATB_BPIF1/22-73 FAADDATSQAKAAFDSLTAQATEMSGYAWALVVLVVGATVGIKLFKKFVSRA
#=GR COATB_BPIF1/22-73 SS XX-HHHH--HHHHHH--HHHHHHH--HHHHHHHHHHHHHHHHHHHHHHHH--
#=GC SS_cons XHHHHHHHHHHHHHHCHHHHHHHCHHHHHHHHHHHHHHHHHHHHHHHC--
#=GC seq_cons AEssss...AptAhDSLpspAT-hIu.sWshVsslVsAsluIKLFKKFsSKA
//
```

[这是 Phage_Coat_Gp8 (PF05371) PFAM 条目的种子比对，从https://pfam.xfam.org/](https://translate.google.com/website?sl=auto&tl=zh-CN&hl=zh-CN&client=webapp&u=https://pfam.xfam.org/)的现已过时的 PFAM 版本下载。我们可以按如下方式加载此文件（假设它已在当前工作目录中作为“PF05371_seed.sth”保存到磁盘）：

```
>>> 从 Bio 导入 AlignIO
>>> alignment = AlignIO.read("PF05371_seed.sth", "stockholm")
```

此代码将打印出对齐摘要：

```
>>> 打印（对齐）
7行52列对齐
AEPNAATNYATEAMDSLKTQAIDLISQTWPVVTTVVVAGLVIRL...SKA COATB_BPIKE/30-81
AEPNAATNYATEAMDSLKTQAIDLISQTWPVVTTVVVAGLVIKL...SRA Q9T0Q8_BPIKE/1-52
DGTSTATSYATEAMNSLKTQATDLIDQTWPVVTSVAVAGLAIRL...SKA COATB_BPI22/32-83
AEGDDP---AKAAFNSLQASATEYIGYAWAMVVVIVGATIGIKL...SKA COATB_BPM13/24-72
AEGDDP---AKAAFDSLQASATEYIGYAWAMVVVIVGATIGIKL...SKA COATB_BPZJ2/1-49
AEGDDP---AKAAFDSLQASATEYIGYAWAMVVVIVGATIGIKL...SKA Q9T0Q9_BPFD/1-49
FAADDATSQAKAAFDSLTAQATEMSGYAWALVVLVVGATVGIKL...SRA COATB_BPIF1/22-73
```

您会注意到在上面的输出中序列已被截断。我们可以改为编写自己的代码，通过将行作为`SeqRecord`对象进行迭代来按照我们的意愿对其进行格式化：

```
>>> 从 Bio 导入 AlignIO
>>> alignment = AlignIO.read("PF05371_seed.sth", "stockholm")
>>> print("对齐长度 %i" % alignment.get_alignment_length())
对齐长度 52
>>> 对齐记录：
... print("%s - %s" % (record.seq, record.id))
...
AEPNAATNYATEAMDSLKTQAIDLISQTWPVVTTVVVAGLVIRLFKKFSSKA - COATB_BPIKE/30-81
AEPNAATNYATEAMDSLKTQAIDLISQTWPVVTTVVVAGLVIKLFKKFVSRA - Q9T0Q8_BPIKE/1-52
DGTSTATSYATEAMNSLKTQATDLIDQTWPVVTSVAVAGLAIRLFKKFSSKA - COATB_BPI22/32-83
AEGDDP---AKAAFNSLQASATEYIGYAWAMVVVIVGATIGIKLFKKFTSKA - COATB_BPM13/24-72
AEGDDP---AKAAFDSLQASATEYIGYAWAMVVVIVGATIGIKLFKKFASKA - COATB_BPZJ2/1-49
AEGDDP---AKAAFDSLQASATEYIGYAWAMVVVIVGATIGIKLFKKFTSKA - Q9T0Q9_BPFD/1-49
FAADDATSQAKAAFDSLTAQATEMSGYAWALVVLVVGATVGIKLFKKFVSRA - COATB_BPIF1/22-73
```

`format`您还可以在对齐对象[上](https://biopython-org.translate.goog/DIST/docs/tutorial/Tutorial.html?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN&_x_tr_pto=wapp&_x_tr_sch=http#sec%3Aalignment-format)调用 Python 的内置函数，以以特定的文件格式显示它——有关详细信息，请参阅第 6.2.2 节。

您是否注意到上面的原始文件中有几个序列包含对 PDB 和相关的已知二级结构的数据库交叉引用？尝试这个：

```
>>> 对齐记录：
...如果记录.dbxrefs：
... print("%s %s" % (record.id, record.dbxrefs))
...
COATB_BPIKE/30-81 ['PDB; 1if ; 1-52;']
COATB_BPM13/24-72 ['PDB; 2cpb; 1-49;', 'PDB; 2厘泊；1-49;']
Q9T0Q9_BPFD/1-49 ['PDB; 1nh4A；1-49;']
COATB_BPIF1/22-73 ['PDB; 1 如果 ; 1-50;']
```

要查看所有序列注释，请尝试以下操作：

```
>>> 对齐记录：
...打印（记录）
...
```

PFAM 在[http://pfam.xfam.org/family/PF05371](https://translate.google.com/website?sl=auto&tl=zh-CN&hl=zh-CN&client=webapp&u=http://pfam.xfam.org/family/PF05371)提供了一个很好的网络界面，它实际上可以让你下载其他几种格式的比对。这是文件在 FASTA 文件格式中的样子：

```
>COATB_BPIKE/30-81
AEPNAATNYATEAMDSLKTQAIDLISQTWPVVTTVVVAGLVIRLFKKFSSKA
>Q9T0Q8_BPIKE/1-52
AEPNAATNYATEAMDSLKTQAIDLISQTWPVVTTVVVAGLVIKLFKKFVSRA
>COATB_BPI22/32-83
DGTSTATSYATEAMNSLKTQATDLIDQTWPVVTSVAVAGLAIRLFKKFSSKA
>COATB_BPM13/24-72
AEGDDP---AKAAFNSLQASATEYIGYAWAMVVVIVGATIGIKLFKKFTSKA
>COATB_BPZJ2/1-49
AEGDDP---AKAAFDSLQASATEYIGYAWAMVVVIVGATIGIKLFKKFASKA
>Q9T0Q9_BPFD/1-49
AEGDDP---AKAAFDSLQASATEYIGYAWAMVVVIVGATIGIKLFKKFTSKA
>COATB_BPIF1/22-73
FAADDATSQAKAAFDSLTAQATEMSGYAWALVVLVVGATVGIKLFKKFVSRA
```

请注意，该网站应该有一个选项，可以将间隙显示为句点（点）或破折号，我们在上面显示了破折号。假设您下载并将其保存为文件“PF05371_seed.faa”，那么您可以使用几乎完全相同的代码加载它：

```
>>> 从 Bio 导入 AlignIO
>>> alignment = AlignIO.read("PF05371_seed.faa", "fasta")
>>> 打印（对齐）
```

这段代码中唯一改变的是文件名和格式字符串。您将获得与以前相同的输出，序列和记录标识符相同。然而，如您所料，如果您检查每一个，`SeqRecord`则没有注释或数据库交叉引用，因为这些不包含在 FASTA 文件格式中。

请注意，您可以`Bio.AlignIO`自己将原始斯德哥尔摩格式文件转换为 FASTA 文件，而不是使用 Sanger 网站（见下文）。

对于任何受支持的文件格式，您只需更改格式字符串即可以完全相同的方式加载比对。例如，对 PHYLIP 文件使用“phylip”，对 NEXUS 文件使用“nexus”，对 EMBOSS 工具输出的对齐使用“emboss”。[维基页面 ( http://biopython.org/wiki/AlignIO](https://biopython-org.translate.goog/wiki/AlignIO?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN&_x_tr_pto=wapp&_x_tr_sch=http) ) 和内置文档（也[在线](https://biopython-org.translate.goog/docs/1.81/api/Bio.AlignIO.html?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN&_x_tr_pto=wapp&_x_tr_sch=http)）中有完整列表：

```
>>> 从 Bio 导入 AlignIO
>>> 帮助（AlignIO）
```

### 6.1.2 多重比对

上一节重点介绍了读取包含单个比对的文件。然而，一般来说，文件可以包含多个对齐方式，要读取这些文件，我们必须使用该`Bio.AlignIO.parse()`函数。

假设您有一个 PHYLIP 格式的小对齐：

```
    5 6
阿尔法AACAAC
贝塔AACCCC
伽玛ACCAAC
台达CCACCA
小量CCAAAC
```

如果您想使用 PHYLIP 工具引导系统发育树，其中一个步骤是使用该工具创建一组许多重采样比对`bootseq`。这将给出类似这样的输出，为简洁起见已缩写：

```
    5 6
阿尔法AAACCA
测试版AAACCC
伽马 ACCCCA
台达民航局
小量CCCAAA
    5 6
阿尔法 AAACAA
测试版AAACCC
伽马 ACCCAA
台达中国民航总局
小量CCCAAA
    5 6
阿尔法 AAAAAC
测试版AAACCC
伽马AACAAC
台达中国商会
小量CCCAAC
...
    5 6
阿尔法AAAACC
测试版 ACCCCC
伽玛AAAACC
台达CCCCAA
Epsilon CAAACC
```

如果你想在使用中阅读这个，`Bio.AlignIO`你可以使用：

```
>>> 从 Bio 导入 AlignIO
>>> alignments = AlignIO.parse("resampled.phy", "phylip")
>>> 用于对齐对齐：
...打印（对齐）
... 打印（）
...
```

这将给出以下输出，再次缩写为显示：

```
5 行 6 列对齐
AAACCA阿尔法
AAACCC 测试版
ACCCCA伽玛
民航三角洲
CCCAAA 小量

5 行 6 列对齐
AAACAA阿尔法
AAACCC 测试版
ACCCAA伽玛
中国民航三角洲
CCCAAA 小量

5 行 6 列对齐
AAAAAC阿尔法
AAACCC 测试版
AACAAC伽玛
中国中华总商会三角洲
CCCAAC小量

...

5 行 6 列对齐
AAAACC 阿尔法
ACCCCC测试版
AAAACC伽玛
CCCCAA三角洲
中国民航总局 Epsilon
```

与 function 一样`Bio.SeqIO.parse()`，using`Bio.AlignIO.parse()`返回一个迭代器。如果您想一次将所有对齐方式保存在内存中，这将允许您以任何顺序访问它们，请将迭代器变成一个列表：

```
>>> 从 Bio 导入 AlignIO
>>> alignments = list(AlignIO.parse("resampled.phy", "phylip"))
>>> last_align = 对齐方式[-1]
>>> first_align = 对齐[0]
```

### 6.1.3 模糊对齐

许多比对文件格式可以显式存储多个比对，并且每个比对之间的划分很清楚。但是，当使用通用序列文件格式时，就没有这样的块结构。最常见的情况是对齐以 FASTA 文件格式保存。例如考虑以下内容：

```
>阿尔法
ACTACGACTAGCTCAG--G
>测试版
ACTACCGCTAGCTCAGAAG公司
>伽玛
ACTACGGCTAGCACAGAAG公司
>阿尔法
ACTACGACTAGCTCAGG——
>测试版
ACTACCGCTAGCTCAGAAG公司
>伽玛
ACTACGGCTAGCACAGAAG公司
```

这可能是包含六个序列（具有重复标识符）的单个比对。或者，从标识符判断，这可能是两个不同的比对，每个比对具有三个序列，它们恰好都具有相同的长度。

下一个例子呢？

```
>阿尔法
ACTACGACTAGCTCAG--G
>测试版
ACTACCGCTAGCTCAGAAG公司
>阿尔法
ACTACGACTAGCTCAGG——
>伽玛
ACTACGGCTAGCACAGAAG公司
>阿尔法
ACTACGACTAGCTCAGG——
>三角洲
ACTACGGCTAGCACAGAAG公司
```

同样，这可能是具有六个序列的单一比对。然而，这次基于标识符，我们可能会猜测这是三个成对的比对，它们偶然都具有相同的长度。

最后一个例子是类似的：

```
>阿尔法
ACTACGACTAGCTCAG--G
>XXX
ACTACCGCTAGCTCAGAAG公司
>阿尔法
ACTACGACTAGCTCAGG公司
>年年年
ACTACGGCAAGCACAGG公司
>阿尔法
--ACTACGAC--TAGCTCAGG
>ZZZ
GGACTACGACAATAGCTCAGG公司
```

在第三个示例中，由于长度不同，不能将其视为包含所有六个记录的单个比对。然而，它可以是三个成对的比对。

显然，尝试在 FASTA 文件中存储多个比对并不理想。但是，如果您被迫将这些作为输入文件来处理，`Bio.AlignIO`则可以应对所有比对具有相同记录数的最常见情况。这方面的一个例子是成对比对的集合，它可以由 EMBOSS 工具生成`needle`，并且`water`——尽管在这种情况下，`Bio.AlignIO`应该能够使用“emboss”作为格式字符串来理解它们的本机输出。

为了将这些 FASTA 示例解释为几个单独的比对，我们可以使用`Bio.AlignIO.parse()`可选`seq_count`参数指定每个比对中预期的序列数（在这些示例中分别为 3、2 和 2）。例如，使用第三个例子作为输入数据：

```
>>> 用于 AlignIO.parse(handle, "fasta", seq_count=2) 中的对齐：
... print("对齐长度 %i" % alignment.get_alignment_length())
... 对齐记录：
... print("%s - %s" % (record.seq, record.id))
... 打印（）
...
```

给予：

```
对齐长度 19
ACTACGACTAGCTCAG--G - 阿尔法
ACTACCGCTAGCTCAGAAG - XXX

对齐长度 17
ACTACGACTAGCTCAGG - 阿尔法
ACTACGGCAAGCACAGG-YYY

对齐长度 21
--ACTACGAC--TAGCTCAGG - 阿尔法
GGACTACGACAATAGCTCAG-ZZZ
```

使用`Bio.AlignIO.read()`或`Bio.AlignIO.parse()`不使用`seq_count`参数将给出包含前两个示例的所有六个记录的单个对齐。对于第三个示例，将引发异常，因为长度不同会阻止它们变成单一对齐。

如果文件格式本身具有允许`Bio.AlignIO`直接确定每个比对中的序列数的块结构，则`seq_count`不需要该参数。如果已提供，但与文件内容不一致，则会引发错误。

请注意，此可选`seq_count`参数假定文件中的每个比对具有相同数量的序列。假设你可能会遇到奇怪的情况，例如一个包含多个比对的 FASTA 文件，每个比对具有不同数量的序列——尽管我很想听到一个真实世界的例子。假设您无法以更好的文件格式获取数据，则没有直接的方法可以使用`Bio.AlignIO`. 在这种情况下，您可以考虑使用序列本身读取序列`Bio.SeqIO`并将它们一起批处理以创建适当的比对。

## 6.2 书写对齐

我们已经讨论了使用`Bio.AlignIO.read()`和`Bio.AlignIO.parse()`用于对齐输入（读取文件），现在我们将看看`Bio.AlignIO.write()`哪个用于对齐输出（写入文件）。这是一个采用三个参数的函数：一些`MultipleSeqAlignment`对象（或为了向后兼容过时的`Alignment`对象）、要写入的句柄或文件名以及序列格式。

`MultipleSeqAlignment`这是一个示例，我们首先以困难的方式创建一些对象（手动，而不是从文件加载它们）。请注意，我们创建了一些`SeqRecord`对象来构建对齐方式。

```
>>> 从 Bio.Seq 导入 Seq
>>> 从 Bio.SeqRecord 导入 SeqRecord
>>> 从 Bio.Align 导入 MultipleSeqAlignment
>>> align1 = MultipleSeqAlignment(
... [
... SeqRecord(Seq("ACTGCTAGCTAG"), id="Alpha"),
... SeqRecord(Seq("ACT-CTAGCTAG"), id="Beta"),
... SeqRecord(Seq("ACTGCTAGDTAG"), id="伽玛"),
...]
...）
>>> align2 = MultipleSeqAlignment(
... [
... SeqRecord(Seq("GTCAGC-AG"), id="Delta"),
... SeqRecord(Seq("GACAGCTAG"), id="Epsilon"),
... SeqRecord(Seq("GTCAGCTAG"), id="Zeta"),
...]
...）
>>> align3 = MultipleSeqAlignment(
... [
... SeqRecord(Seq("ACTAGTACAGCTG"), id="Eta"),
... SeqRecord(Seq("ACTAGTACAGCT-"), id="Theta"),
... SeqRecord(Seq("-CTACTACAGGTG"), id="Iota"),
...]
...）
>>> my_alignments = [align1, align2, align3]
```

现在我们有了一个对象列表`Alignment`，我们将把它们写入一个 PHYLIP 格式的文件：

```
>>> 从 Bio 导入 AlignIO
>>> AlignIO.write(my_alignments, "my_example.phy", "phylip")
```

如果你在你最喜欢的文本编辑器中打开这个文件，它应该是这样的：

```
3 12
阿尔法 ACTGCTAGCT 股份公司
Beta ACT-CTAGCT AG
Gamma ACTGCTAGDT 股份公司
 3 9
台达GTCAGC-AG
Epislon GACAGCTAG
Zeta GTCAGCTAG
 3 13
埃塔 ACTAGTACAG CTG
Theta ACTAGTACAG CT-
Iota-CTACTACAG GTG
```

更常见的是想要加载现有对齐并保存它，也许是在进行一些简单的操作（例如删除某些行或列）之后。

假设您想知道函数`Bio.AlignIO.write()`写入句柄的对齐方式有多少？如果您的对齐方式像上面的示例一样在列表中，您可以只使用`len(my_alignments)`，但是当您的记录来自生成器/迭代器时，您不能这样做。因此，该`Bio.AlignIO.write()`函数返回写入文件的比对数。

*注意*- 如果您告诉`Bio.AlignIO.write()`函数写入一个已经存在的文件，旧文件将在没有任何警告的情况下被覆盖。

### 6.2.1 序列比对文件格式之间的转换



在序列比对文件格式之间转换的`Bio.AlignIO`工作方式与在序列文件格式之间转换的方式相同`Bio.SeqIO`（第[5.5.2](https://biopython-org.translate.goog/DIST/docs/tutorial/Tutorial.html?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN&_x_tr_pto=wapp&_x_tr_sch=http#sec%3ASeqIO-conversion)）。我们通常使用加载对齐方式`Bio.AlignIO.parse()`，然后使用`Bio.AlignIO.write()`- 或者只使用`Bio.AlignIO.convert()`辅助函数来保存它们。

对于此示例，我们将加载之前使用的 PFAM/Stockholm 格式文件并将其保存为 Clustal W 格式文件：

```
>>> 从 Bio 导入 AlignIO
>>> count = AlignIO.convert("PF05371_seed.sth", "stockholm", "PF05371_seed.aln", "clustal")
>>> print("转换后的 %i 对齐方式" % count)
转换 1 路线
```

或者，使用`Bio.AlignIO.parse()`和`Bio.AlignIO.write()`：

```
>>> 从 Bio 导入 AlignIO
>>> alignments = AlignIO.parse("PF05371_seed.sth", "斯德哥尔摩")
>>> count = AlignIO.write(alignments, "PF05371_seed.aln", "clustal")
>>> print("转换后的 %i 对齐方式" % count)
转换 1 路线
```

该`Bio.AlignIO.write()`函数期望被赋予多个对齐对象。在上面的例子中，我们给了它返回的对齐迭代器`Bio.AlignIO.parse()`。

在这种情况下，我们知道文件中只有一个对齐方式，因此我们可以改用`Bio.AlignIO.read()`它，但请注意，我们必须将此对齐方式`Bio.AlignIO.write()`作为单个元素列表传递给：

```
>>> 从 Bio 导入 AlignIO
>>> alignment = AlignIO.read("PF05371_seed.sth", "stockholm")
>>> AlignIO.write([alignment], "PF05371_seed.aln", "clustal")
```

无论哪种方式，您最终都应该得到具有以下内容的相同的新 Clustal W 格式文件“PF05371_seed.aln”：

```
CLUSTAL X (1.81) 多序列比对


COATB_BPIKE/30-81 AEPNAATNYATEAMDSLKTQAIDLISQTWPVVTTVVVAGLVIRLFKKFSS
Q9T0Q8_BPIKE/1-52 AEPNAATNYATEAMDSLKTQAIDLISQTWPVVTTVVVAGLVIKLFKKFVS
COATB_BPI22/32-83 DGTSTATSYATEAMNSLKTQATDLIDQTWPVVTSVAVAGLAIRLFKKFSS
COATB_BPM13/24-72 AEGDDP---AKAAFNSLQASATEYIGYAWAMVVVIVGATIGIKLFKKFTS
COATB_BPZJ2/1-49 AEGDDP---AKAAFDSLQASATEYIGYAWAMVVVIVGATIGIKLFKKFAS
Q9T0Q9_BPFD/1-49 AEGDDP---AKAAFDSLQASATEYIGYAWAMVVVIVGATIGIKLFKKFTS
COATB_BPIF1/22-73 FAADDATSQAKAAFDSLTAQATEMSGYAWALVVLVVGATVGIKLFKKFVS

COATB_BPIKE/30-81 KA
Q9T0Q8_BPIKE/1-52 RA
COATB_BPI22/32-83 KA
COATB_BPM13/24-72 KA
COATB_BPZJ2/1-49 KA
Q9T0Q9_BPFD/1-49 KA
COATB_BPIF1/22-73 RA
```

或者，您可以制作一个 PHYLIP 格式的文件，我们将其命名为“PF05371_seed.phy”：

```
>>> 从 Bio 导入 AlignIO
>>> AlignIO.convert("PF05371_seed.sth", "stockholm", "PF05371_seed.phy", "phylip")
```

这次输出如下所示：

```
7 52
COATB_BPIK AEPNAATNYA TEAMDSLKTQ AIDLISQTWP VVTTVVVAGL VIRLFKKFSS
Q9T0Q8_BPI AEPNAATNYA TEAMDSLKTQ AIDLISQTWP VVTTVVVAGL VIKLFKKFVS
COATB_BPI2 DGTSTATSYA TEAMNSLKTQ ATDLIDQTWP VVTSVAVAGL AIRLFKKFSS
COATB_BPM1 AEGDDP---A KAAFNSLQAS ATEYIGYAWA MVVVIVGATI GIKLFKKFTS
COATB_BPZJ AEGDDP---A KAAFDSLQAS ATEYIGYAWA MVVVIVGATI GIKLFKKFAS
Q9T0Q9_BPF AEGDDP---A KAAFDSLQAS ATEYIGYAWA MVVVIVGATI GIKLFKKFTS
COATB_BPIF FAADDATSQA KAAFDSLTAQ ATEMSGYAWA LVVLVVGATV GIKLFKKFVS

           K A
           RA
           K A
           K A
           K A
           K A
           RA
```

原始 PHYLIP 比对文件格式的一大障碍是序列标识符被严格截断为十个字符。在此示例中，如您所见，生成的名称仍然是唯一的 - 但它们的可读性不高。因此，原始 PHYLIP 格式的一种更宽松的变体现在得到了相当广泛的使用：

```
>>> 从 Bio 导入 AlignIO
>>> AlignIO.convert("PF05371_seed.sth", "stockholm", "PF05371_seed.phy", "phylip-relaxed")
```

这次输出看起来像这样，使用更长的缩进以允许完整给出所有标识符：

```
7 52
COATB_BPIKE/30-81 AEPNAATNYA TEAMDSLKTQ AIDLISQTWP VVTTVVVAGL VIRLFKKFSS
Q9T0Q8_BPIKE/1-52 AEPNAATNYA TEAMDSLKTQ AIDLISQTWP VVTTVVVAGL VIKLFKKFVS
COATB_BPI22/32-83 DGTSTATSYA TEAMNSLKTQ ATDLIDQTWP VVTSVAVAGL AIRLFKKFSS
COATB_BPM13/24-72 AEGDDP---A KAAFNSLQAS ATEYIGYAWA MVVVIVGATI GIKLFKKFTS
COATB_BPZJ2/1-49 AEGDDP---A KAAFDSLQAS ATEYIGYAWA MVVVIVGATI GIKLFKKFAS
Q9T0Q9_BPFD/1-49 AEGDDP---A KAAFDSLQAS ATEYIGYAWA MVVVIVGATI GIKLFKKFTS
COATB_BPIF1/22-73 FAADDATSQA KAAFDSLTAQ ATEMSGYAWA LVVLVVGATV GIKLFKKFVS

                   K A
                   RA
                   K A
                   K A
                   K A
                   K A
                   RA
```

如果您必须使用原始的严格 PHYLIP 格式，那么您可能需要以某种方式压缩标识符 - 或者分配您自己的名称或编号系统。下面这段代码在保存输出之前操作记录标识符：

```
>>> 从 Bio 导入 AlignIO
>>> alignment = AlignIO.read("PF05371_seed.sth", "stockholm")
>>> 名称映射 = {}
>>> 对于我，在枚举中记录（对齐）：
... name_mapping[i] = record.id
... record.id = "seq%i" % i
...
>>> 打印（名称映射）
{0：'COATB_BPIKE/30-81'，1：'Q9T0Q8_BPIKE/1-52'，2：'COATB_BPI22/32-83'，3：'COATB_BPM13/24-72'，4：'COATB_BPZJ2/1-49' , 5: 'Q9T0Q9_BPFD/1-49', 6: 'COATB_BPIF1/22-73'}
>>> AlignIO.write([对齐], "PF05371_seed.phy", "phylip")
```

此代码使用 Python 字典来记录从新序列系统到原始标识符的简单映射：

```
{
    0：“COATB_BPIKE/30-81”，
    1：“Q9T0Q8_BPIKE/1-52”，
    2：“COATB_BPI22/32-83”，
    ## ...
}
```

这是新的（严格的）PHYLIP 格式输出：

```
7 52
seq0 AEPNAATNYA TEAMDSLKTQ AIDLISQTWP VVTTVVVAGL VIRLFKKFSS
seq1 AEPNAATNYA TEAMDSLKTQ AIDLISQTWP VVTTVVVAGL VIKLFKKFVS
seq2 DGTSTATSYA TEAMNSLKTQ ATDLIDQTWP VVTSVAVAGL AIRLFKKFSS
seq3 AEGDDP---A KAAFNSLQAS ATEYIGYAWA MVVVIVGATI GIKLFKKFTS
seq4 AEGDDP---A KAAFDSLQAS ATEYIGYAWA MVVVIVGATI GIKLFKKFAS
seq5 AEGDDP---A KAAFDSLQAS ATEYIGYAWA MVVVIVGATI GIKLFKKFTS
seq6 FAADDATSQA KAAFDSLTAQ ATEMSGYAWA LVVLVVGATV GIKLFKKFVS

           K A
           RA
           K A
           K A
           K A
           K A
           RA
```

一般来说，由于标识符的限制，使用*严格的*PHYLIP 文件格式不应该是您的第一选择。另一方面，使用 PFAM/Stockholm 格式也可以让您记录很多额外的注释。

### 6.2.2 将对齐对象作为格式化字符串

该`Bio.AlignIO`界面基于句柄，这意味着如果您想将对齐方式转换为特定文件格式的字符串，您需要做更多的工作（见下文）。`format`但是，您可能更喜欢在对齐对象上调用 Python 的内置函数。`Bio.AlignIO`这将输出格式规范作为单个参数，这是作为输出格式支持的小写字符串。例如：

```
>>> 从 Bio 导入 AlignIO
>>> alignment = AlignIO.read("PF05371_seed.sth", "stockholm")
>>> 打印（格式（对齐，“clustal”））
CLUSTAL X (1.81) 多序列比对


COATB_BPIKE/30-81 AEPNAATNYATEAMDSLKTQAIDLISQTWPVVTTVVVAGLVIRLFKKFSS
Q9T0Q8_BPIKE/1-52 AEPNAATNYATEAMDSLKTQAIDLISQTWPVVTTVVVAGLVIKLFKKFVS
COATB_BPI22/32-83 DGTSTATSYATEAMNSLKTQATDLIDQTWPVVTSVAVAGLAIRLFKKFSS
...
```

没有输出格式规范，`format`返回与 相同的输出`str`。

如第[4.6](https://biopython-org.translate.goog/DIST/docs/tutorial/Tutorial.html?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN&_x_tr_pto=wapp&_x_tr_sch=http#sec%3ASeqRecord-format)，该`SeqRecord`对象有一个类似的方法，使用`Bio.SeqIO`.

内部`format`是`Bio.AlignIO.write()`用`StringIO`句柄调用。例如，如果您使用的是旧版本的 Biopython，则可以在自己的代码中执行此操作：

```
>>> 从 io 导入 StringIO
>>> 从 Bio 导入 AlignIO
>>> alignments = AlignIO.parse("PF05371_seed.sth", "斯德哥尔摩")
>>> out_handle = StringIO()
>>> AlignIO.write(alignments, out_handle, "clustal")
1个
>>> clustal_data = out_handle.getvalue()
>>> 打印（clustal_data）
CLUSTAL X (1.81) 多序列比对


COATB_BPIKE/30-81 AEPNAATNYATEAMDSLKTQAIDLISQTWPVVTTVVVAGLVIRLFKKFSS
Q9T0Q8_BPIKE/1-52 AEPNAATNYATEAMDSLKTQAIDLISQTWPVVTTVVVAGLVIKLFKKFVS
COATB_BPI22/32-83 DGTSTATSYATEAMNSLKTQATDLIDQTWPVVTSVAVAGLAIRLFKKFSS
COATB_BPM13/24-72 AEGDDP---AKAAFNSLQASATEYIGYAWAMVVVIVGATIGIKLFKKFTS
...
```

## 6.3 操纵路线



现在我们已经介绍了加载和保存路线，我们将看看您还可以用它们做什么。

### 6.3.1 切片对齐

首先，在某种意义上，对齐对象就像对象（行）`list`的Python。考虑到这个模型，希望（行数）和迭代（每行作为一个）`SeqRecord`的操作是有意义的：`len()``SeqRecord`

```
>>> 从 Bio 导入 AlignIO
>>> alignment = AlignIO.read("PF05371_seed.sth", "stockholm")
>>> print("行数：%i" % len(alignment))
行数：7
>>> 对齐记录：
... print("%s - %s" % (record.seq, record.id))
...
AEPNAATNYATEAMDSLKTQAIDLISQTWPVVTTVVVAGLVIRLFKKFSSKA - COATB_BPIKE/30-81
AEPNAATNYATEAMDSLKTQAIDLISQTWPVVTTVVVAGLVIKLFKKFVSRA - Q9T0Q8_BPIKE/1-52
DGTSTATSYATEAMNSLKTQATDLIDQTWPVVTSVAVAGLAIRLFKKFSSKA - COATB_BPI22/32-83
AEGDDP---AKAAFNSLQASATEYIGYAWAMVVVIVGATIGIKLFKKFTSKA - COATB_BPM13/24-72
AEGDDP---AKAAFDSLQASATEYIGYAWAMVVVIVGATIGIKLFKKFASKA - COATB_BPZJ2/1-49
AEGDDP---AKAAFDSLQASATEYIGYAWAMVVVIVGATIGIKLFKKFTSKA - Q9T0Q9_BPFD/1-49
FAADDATSQAKAAFDSLTAQATEMSGYAWALVVLVVGATVGIKLFKKFVSRA - COATB_BPIF1/22-73
```

您还可以使用类列表`append`和`extend`方法将更多行添加到对齐中（作为`SeqRecord`对象）。牢记列表隐喻，对齐的简单切片也应该有意义 - 它选择一些行返回另一个对齐对象：

```
>>> 打印（对齐）
7行52列对齐
AEPNAATNYATEAMDSLKTQAIDLISQTWPVVTTVVVAGLVIRL...SKA COATB_BPIKE/30-81
AEPNAATNYATEAMDSLKTQAIDLISQTWPVVTTVVVAGLVIKL...SRA Q9T0Q8_BPIKE/1-52
DGTSTATSYATEAMNSLKTQATDLIDQTWPVVTSVAVAGLAIRL...SKA COATB_BPI22/32-83
AEGDDP---AKAAFNSLQASATEYIGYAWAMVVVIVGATIGIKL...SKA COATB_BPM13/24-72
AEGDDP---AKAAFDSLQASATEYIGYAWAMVVVIVGATIGIKL...SKA COATB_BPZJ2/1-49
AEGDDP---AKAAFDSLQASATEYIGYAWAMVVVIVGATIGIKL...SKA Q9T0Q9_BPFD/1-49
FAADDATSQAKAAFDSLTAQATEMSGYAWALVVLVVGATVGIKL...SRA COATB_BPIF1/22-73
>>> 打印（对齐[3:7]）
4行52列对齐
AEGDDP---AKAAFNSLQASATEYIGYAWAMVVVIVGATIGIKL...SKA COATB_BPM13/24-72
AEGDDP---AKAAFDSLQASATEYIGYAWAMVVVIVGATIGIKL...SKA COATB_BPZJ2/1-49
AEGDDP---AKAAFDSLQASATEYIGYAWAMVVVIVGATIGIKL...SKA Q9T0Q9_BPFD/1-49
FAADDATSQAKAAFDSLTAQATEMSGYAWALVVLVVGATVGIKL...SRA COATB_BPIF1/22-73
```

如果你想按列选择怎么办？那些使用过 NumPy 矩阵或数组对象的人不会对此感到惊讶——你使用了双索引。

```
>>> 打印（对齐[2, 6]）
吨
```

使用两个整数索引提取一个字母，简写为：

```
>>> 打印（对齐[2].seq[6]）
吨
```

您可以像这样将单个列作为字符串拉出：

```
>>> 打印（对齐方式[:, 6]）
TTT---T
```

您还可以选择一系列列。例如，要挑选出我们之前提取的相同三行，但只取前六列：

```
>>> 打印（对齐 [3:6, :6]）
3 行 6 列对齐
AEGDDP COATB_BPM13/24-72
AEGDDP COATB_BPZJ2/1-49
AEGDDP Q9T0Q9_BPFD/1-49
```

保留第一个索引意味着`:`获取所有行：

```
>>> 打印（对齐方式[:, :6]）
7 行 6 列对齐
AEPNAA COATB_BPIKE/30-81
AEPNAA Q9T0Q8_BPIKE/1-52
DGTSTA COATB_BPI22/32-83
AEGDDP COATB_BPM13/24-72
AEGDDP COATB_BPZJ2/1-49
AEGDDP Q9T0Q9_BPFD/1-49
FAADDA COATB_BPIF1/22-73
```

这给我们带来了一种删除部分的巧妙方法。注意第 7、8 和 9 列，它们是七个序列中三个序列中的间隙：

```
>>> 打印（对齐方式[:, 6:9]）
7 行 3 列对齐
纽约州 COATB_BPIKE/30-81
TNY Q9T0Q8_BPIKE/1-52
TSY COATB_BPI22/32-83
--- COATB_BPM13/24-72
--- COATB_BPZJ2/1-49
--- Q9T0Q9_BPFD/1-49
TSQ COATB_BPIF1/22-73
```

同样，您可以切片以获取第九列之后的所有内容：

```
>>> 打印（对齐方式[:, 9:]）
对齐 7 行 43 列
ATEAMDSLKTQAIDLISQTWPVVTTVVVAGLVIRLFKKFSSKA COATB_BPIKE/30-81
ATEAMDSLKTQAIDLISQTWPVVTTVVVAGLVIKLFKKFVSRA Q9T0Q8_BPIKE/1-52
ATEAMNSLKTQATDLIDQTWPVVTSVAVAGLAIRLFKKFSSKA COATB_BPI22/32-83
AKAAFNSLQASATEYIGYAWAMVVVIVGATIGIKLFKKFTSKA COATB_BPM13/24-72
AKAAFDSLQASATEYIGYAWAMVVVIVGATIGIKLFKKFASKA COATB_BPZJ2/1-49
AKAAFDSLQASATEYIGYAWAMVVVIVGATIGIKLFKKFTSKA Q9T0Q9_BPFD/1-49
AKAAFDSLTAQATEMSGYAWALVVLVVGATVGIKLFKKFVSRA COATB_BPIF1/22-73
```

现在，有趣的是对齐对象的添加是按列工作的。这使您可以将此作为删除列块的一种方式：

```
>>> edited = alignment[:, :6] + alignment[:, 9:]
>>> 打印（编辑）
7 行 49 列对齐
AEPNAAATEAMDSLKTQAIDLISQTWPVVTTVVVAGLVIRLFKKFSSKA COATB_BPIKE/30-81
AEPNAAATEAMDSLKTQAIDLISQTWPVVTTVVVAGLVIKLFKKFVSRA Q9T0Q8_BPIKE/1-52
DGTSTAATEAMNSLKTQATDLIDQTWPVVTSVAVAGLAIRLFKKFSSKA COATB_BPI22/32-83
AEGDDPAKAAFNSLQASATEYIGYAWAMVVVIVGATIGIKLFKKFTSKA COATB_BPM13/24-72
AEGDDPAKAAFDSLQASATEYIGYAWAMVVVIVGATIGIKLFKKFASKA COATB_BPZJ2/1-49
AEGDDPAKAAFDSLQASATEYIGYAWAMVVVIVGATIGIKLFKKFTSKA Q9T0Q9_BPFD/1-49
FAADDAAKAAFDSLTAQATEMSGYAWALVVLVVGATVGIKLFKKFVSRA COATB_BPIF1/22-73
```

比对添加的另一个常见用途是将几个不同基因的比对组合成元比对。不过要注意——标识符需要匹配（请参阅第[4.8](https://biopython-org.translate.goog/DIST/docs/tutorial/Tutorial.html?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN&_x_tr_pto=wapp&_x_tr_sch=http#sec%3ASeqRecord-addition)了解添加`SeqRecord`对象的工作原理）。您可能会发现首先按 id 字母顺序对对齐行进行排序很有帮助：

```
>>> edited.sort()
>>> 打印（编辑）
7 行 49 列对齐
DGTSTAATEAMNSLKTQATDLIDQTWPVVTSVAVAGLAIRLFKKFSSKA COATB_BPI22/32-83
FAADDAAKAAFDSLTAQATEMSGYAWALVVLVVGATVGIKLFKKFVSRA COATB_BPIF1/22-73
AEPNAAATEAMDSLKTQAIDLISQTWPVVTTVVVAGLVIRLFKKFSSKA COATB_BPIKE/30-81
AEGDDPAKAAFNSLQASATEYIGYAWAMVVVIVGATIGIKLFKKFTSKA COATB_BPM13/24-72
AEGDDPAKAAFDSLQASATEYIGYAWAMVVVIVGATIGIKLFKKFASKA COATB_BPZJ2/1-49
AEPNAAATEAMDSLKTQAIDLISQTWPVVTTVVVAGLVIKLFKKFVSRA Q9T0Q8_BPIKE/1-52
AEGDDPAKAAFDSLQASATEYIGYAWAMVVVIVGATIGIKLFKKFTSKA Q9T0Q9_BPFD/1-49
```

请注意，如果行数相同，则只能将两个路线相加。

### 6.3.2 对齐为数组

根据您正在做的事情，将对齐对象转换为字母数组可能更有用——您可以使用 NumPy 做到这一点：

```
>>> 将 numpy 导入为 np
>>> 从 Bio 导入 AlignIO
>>> alignment = AlignIO.read("PF05371_seed.sth", "stockholm")
>>> align_array = np.array(对齐)
>>> print("数组形状 %i by %i" % align_array.shape)
阵列形状 7 x 52
>>> align_array[:, :10] ## doctest:+ELLIPSIS
阵列（[['A'，'E'，'P'，'N'，'A'，'A'，'T'，'N'，'Y'，'A']，
       ['A', 'E', 'P', 'N', 'A', 'A', 'T', 'N', 'Y', 'A'],
       ['D', 'G', 'T', 'S', 'T', 'A', 'T', 'S', 'Y', 'A'],
       ['A', 'E', 'G', 'D', 'D', 'P', '-', '-', '-', 'A'],
       ['A', 'E', 'G', 'D', 'D', 'P', '-', '-', '-', 'A'],
       ['A', 'E', 'G', 'D', 'D', 'P', '-', '-', '-', 'A'],
       ['F', 'A', 'A', 'D', 'D', 'A', 'T', 'S', 'Q', 'A']],...
```

请注意，这会将内存中的原始 Biopython 对齐对象和 NumPy 数组作为单独的对象 - 编辑一个不会更新另一个！

## 6.4 获取对齐信息

### 6.4.1 置换

对齐的属性`substitutions`报告对齐中的字母相互替换的频率。这是通过获取对齐中的所有行对，计算两个字母彼此对齐的次数，然后对所有对求和来计算的。例如，

```
>>> 从 Bio.Seq 导入 Seq
>>> 从 Bio.SeqRecord 导入 SeqRecord
>>> 从 Bio.Align 导入 MultipleSeqAlignment
>>> 比对 = MultipleSeqAlignment(
... [
... SeqRecord(Seq("ACTCCTA"), id="seq1"),
... SeqRecord(Seq("AAT-CTA"), id="seq2"),
... SeqRecord(Seq("CCTACT-"), id="seq3"),
... SeqRecord(Seq("TCTCCTC"), id="seq4"),
...]
...）
>>> 打印（对齐）
4 行 7 列对齐
ACTCCTA seq1
AAT-CTA序列2
CCTACT-seq3
TCTCCTC seq4
>>> 替换 = alignment.substitutions
>>> 打印（替换）
    行为
一个 2.0 4.5 1.0
C 4.5 10.0 0.5
T 1.0 0.5 12.0
<空白>
```

由于对的排序是任意的，因此计数在对角线上方和下方平均分配。例如，`A`to的 9 个对齐`C`存储为 4.5 at position`['A', 'C']`和 4.5 at position `['C', 'A']`。如第[20.4.2](https://biopython-org.translate.goog/DIST/docs/tutorial/Tutorial.html?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN&_x_tr_pto=wapp&_x_tr_sch=http#sec%3Asubs_mat_ex)。

请注意，`alignment.substitutions`仅包含对齐中出现的字母的条目。您可以使用该`select`方法为丢失的字母添加条目，例如

```
>>> m = substitutions.select("ATCG")
>>> 打印（米）
    ATCG
一个 2.0 1.0 4.5 0.0
T 1.0 12.0 0.5 0.0
C 4.5 0.5 10.0 0.0
G 0.0 0.0 0.0 0.0
<空白>
```

这也允许您更改字母表中字母的顺序。

## 6.5 对齐工具



有*很多*用于比对序列的算法，包括成对比对和多序列比对。这些计算相对较慢，您通常不想在 Python 中编写这样的算法。对于成对比对，Biopython 包含`PairwiseAligner`（参见第[6.6](https://biopython-org.translate.goog/DIST/docs/tutorial/Tutorial.html?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN&_x_tr_pto=wapp&_x_tr_sch=http#sec%3Apairwise)）。此外，您可以使用 Biopython 代表您调用命令行工具。通常你会：

1. 准备一个未比对序列的输入文件，通常这将是一个 FASTA 文件，您可以使用它创建`Bio.SeqIO`（参见第[5](https://biopython-org.translate.goog/DIST/docs/tutorial/Tutorial.html?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN&_x_tr_pto=wapp&_x_tr_sch=http#chapter%3Aseqio)）。
2. 调用命令行工具来处理这个输入文件，通常是通过 Biopython 的命令行包装器之一（我们将在此处讨论）。
3. 读取工具的输出，即您的对齐序列，通常使用`Bio.AlignIO`（参见本章前面部分）。

我们将在本章中讨论的所有命令行包装器都遵循相同的风格。您创建一个指定选项（例如输入文件名和输出文件名）的命令行对象，然后通过 Python 操作系统调用（例如使用subprocess模块）调用此命令行。

*警告：*我们已决定在未来的 Biopython 版本中删除这些命令行包装器。我们将更新此文档以直接构建命令行，并使用subprocess模块调用它。

大多数这些包装器都在`Bio.Align.Applications`模块中定义：

```
>>> 导入 Bio.Align.Applications
>>> dir(Bio.Align.Applications) ## doctest:+省略号
['ClustalOmegaCommandline', 'ClustalwCommandline', 'DialignCommandline', 'MSAProbsCommandline', 'MafftCommandline', 'MuscleCommandline', 'PrankCommandline', 'ProbconsCommandline', 'TCoffeeCommandline', ...]
```

（忽略以下划线开头的条目——这些在 Python 中具有特殊含义。）该模块`Bio.Emboss.Applications`具有一些[EMBOSS 套件的](https://translate.google.com/website?sl=auto&tl=zh-CN&hl=zh-CN&client=webapp&u=http://emboss.sourceforge.net/)包装器，包括needle和water，它们在下面的第[6.5.5](https://biopython-org.translate.goog/DIST/docs/tutorial/Tutorial.html?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN&_x_tr_pto=wapp&_x_tr_sch=http#sec%3Aemboss-needle-water)，以及 EMBOSS 包装器的包装器PHYLIP 工具的版本（EMBOSS 将其称为其 EMBASSY 软件包之一——具有 EMBOSS 样式界面的第三方工具）。我们不会在本节的此处探讨所有这些对齐工具，只是一个示例，但适用相同的原则。

### 6.5.1 ClustalW

ClustalW 是一种用于多序列比对的流行命令行工具（还有一个称为 ClustalX 的图形界面）。Biopython 的`Bio.Align.Applications`模块有这个对齐工具（和其他几个）的包装器。

在尝试从 Python 中使用 ClustalW 之前，您应该首先尝试在命令行手动运行 ClustalW 工具，以熟悉其他选项。您会发现 Biopython 包装器非常忠实于实际的命令行 API：

```
>>> 从 Bio.Align.Applications 导入 ClustalwCommandline
>>> 帮助（ClustalwCommandline）
```

对于最基本的用法，您只需要有一个 FASTA 输入文件，例如[opuntia.fasta](https://translate.google.com/website?sl=auto&tl=zh-CN&hl=zh-CN&client=webapp&u=https://raw.githubusercontent.com/biopython/biopython/master/Doc/examples/opuntia.fasta)（在线提供或在 Biopython 源代码的 Doc/examples 子目录中提供）。这是一个包含七个仙人掌 DNA 序列（来自仙人掌科*仙人掌*）的小型 FASTA 文件。

默认情况下，ClustalW 将生成一个对齐和引导树文件，其名称基于输入 FASTA 文件，在本例中为opuntia.aln和opuntia.dnd，但您可以覆盖它或使其明确：

```
>>> 从 Bio.Align.Applications 导入 ClustalwCommandline
>>> cline = ClustalwCommandline("clustalw2", infile="opuntia.fasta")
>>> 打印（克莱因）
clustalw2 -infile=opuntia.fasta
```

请注意，这里我们将可执行文件命名为clustalw2，表明我们安装了第二版，其文件名与第一版不同（clustalw，默认值）。幸运的是，这两个版本都支持命令行中的同一组参数（实际上，在功能上应该是相同的）。

您可能会发现，即使安装了 ClustalW，上述命令也不起作用——您可能会收到一条关于“找不到命令”的消息（尤其是在 Windows 上）。这表明 ClustalW 可执行文件不在您的 PATH（环境变量，要搜索的目录列表）中。您可以更新您的 PATH 设置以包括您的 ClustalW 工具副本的位置（您如何执行此操作将取决于您的操作系统），或者只需键入该工具的完整路径。例如：

```
>>> 导入操作系统
>>> 从 Bio.Align.Applications 导入 ClustalwCommandline
>>> clustalw_exe = r"C:\Program Files\new clustal\clustalw2.exe"
>>> clustalw_cline = ClustalwCommandline(clustalw_exe, infile="opuntia.fasta")
>>> assert os.path.isfile(clustalw_exe), "Clustal W executable missing"
>>> 标准输出，标准错误 = clustalw_cline()
```

请记住，在 Python 字符串中`\n`，and`\t`在默认情况下被解释为一个新行和一个制表符——这就是为什么我们在未以这种方式翻译的原始字符串的开头放置一个字母“r”。这通常是指定 Windows 样式文件名时的好习惯。

在内部，这使用了`subprocess`现在推荐的在 Python 中运行另一个程序的模块。这取代了旧的选项，如`os.system()`和`os.popen*`功能。

现在，了解命令行工具如何“工作”会有所帮助。当您在命令行运行工具时，它通常会将文本输出直接打印到屏幕上。该文本可以通过两个“管道”捕获或重定向，称为标准输出（正常结果）和标准错误（用于错误消息和调试消息）。还有标准输入，即输入该工具的任何文本。这些名称缩短为 stdin、stdout 和 stderr。当工具完成时，它有一个返回代码（一个整数），按照惯例，返回代码为零表示成功。

当您通过 Biopython 包装器运行这样的命令行工具时，它将等待它完成，并检查返回代码。如果这是非零（表示错误），则会引发异常。然后包装器返回两个字符串，stdout 和 stderr。

对于 ClustalW，当在命令行运行时，所有重要的输出都直接写入输出文件。在您等待时（通过 stdout 或 stderr）通常打印到屏幕上的所有内容都很无聊，可以忽略（假设它有效）。

我们关心的是两个输出文件，alignment 和 guide tree。我们没有告诉 ClustalW 使用什么文件名，但它默认根据输入文件选择名称。在这种情况下，输出应该在文件中`opuntia.aln`。`Bio.AlignIO`您现在应该能够弄清楚如何读取对齐方式：

```
>>> 从 Bio 导入 AlignIO
>>> align = AlignIO.read("opuntia.aln", "clustal")
>>> 打印（对齐）
对齐 7 行 906 列
TATACATTAAAGAAGGGGGATGCGGATAAATGGAAAGGCGAAAG...AGA gi|6273285|gb|AF191659.1|AF191
TATACATTAAAGAAGGGGGATGCGGATAAATGGAAAGGCGAAAG...AGA gi|6273284|gb|AF191658.1|AF191
TATACATTAAAGAAGGGGGATGCGGATAAATGGAAAGGCGAAAG...AGA gi|6273287|gb|AF191661.1|AF191
TATACATAAAAGAAGGGGGATGCGGATAAATGGAAAGGCGAAAG...AGA gi|6273286|gb|AF191660.1|AF191
TATACATTAAAGGAGGGGGATGCGGATAAATGGAAAGGCGAAAG...AGA gi|6273290|gb|AF191664.1|AF191
TATACATTAAAGGAGGGGGATGCGGATAAATGGAAAGGCGAAAG...AGA gi|6273289|gb|AF191663.1|AF191
TATACATTAAAGGAGGGGGATGCGGATAAATGGAAAGGCGAAAG...AGA gi|6273291|gb|AF191665.1|AF191
```

如果您有兴趣（这与本章的主旨不同）， ClustalW 创建的opuntia.dnd文件只是一个标准的 Newick 树文件，并且`Bio.Phylo`可以解析这些文件：

```
>>> 从 Bio 导入 Phylo
>>> tree = Phylo.read("opuntia.dnd", "newick")
>>> Phylo.draw_ascii（树）
                             ____________ gi|6273291|gb|AF191665.1|AF191665
  __________________________|
 | | ______ gi|6273290|gb|AF191664.1|AF191664
 | |__|
 | |_____ gi|6273289|gb|AF191663.1|AF191663
 |
_|________________ gi|6273287|gb|AF191661.1|AF191661
 |
 |__________ gi|6273286|gb|AF191660.1|AF191660
 |
 | __ gi|6273285|gb|AF191659.1|AF191659
 |___|
     | gi|6273284|gb|AF191658.1|AF191658
<空白>
```

[第13](https://biopython-org.translate.goog/DIST/docs/tutorial/Tutorial.html?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN&_x_tr_pto=wapp&_x_tr_sch=http#chapter%3Aphylo)章更深入地介绍了 Biopython 对系统发育树的支持。

### 6.5.2 肌肉

MUSCLE 是比 ClustalW 更新的多序列比对工具，Biopython 模块下也有它的包装器`Bio.Align.Applications`。和以前一样，我们建议您先尝试在命令行中使用 MUSCLE，然后再在 Python 中尝试它，因为 Biopython 包装器非常忠实于实际的命令行 API：

```
>>> 从 Bio.Align.Applications 导入 MuscleCommandline
>>> 帮助（肌肉命令行）
```

对于最基本的用法，您只需要有一个 FASTA 输入文件，例如[opuntia.fasta](https://translate.google.com/website?sl=auto&tl=zh-CN&hl=zh-CN&client=webapp&u=https://raw.githubusercontent.com/biopython/biopython/master/Doc/examples/opuntia.fasta)（在线提供或在 Biopython 源代码的 Doc/examples 子目录中提供）。然后你可以告诉 MUSCLE 读入这个 FASTA 文件，并将比对写入输出文件：

```
>>> 从 Bio.Align.Applications 导入 MuscleCommandline
>>> cline = MuscleCommandline(input="opuntia.fasta", out="opuntia.txt")
>>> 打印（克莱因）
肌肉-in opuntia.fasta -out opuntia.txt
```

请注意，MUSCLE 使用“-in”和“-out”，但在 Biopython 中，我们必须使用“input”和“out”作为关键字参数或属性名称。这是因为“in”是 Python 中的保留字。

默认情况下，MUSCLE 会将比对输出为 FASTA 文件（使用间隙序列）。该`Bio.AlignIO`模块应该能够使用format="fasta"读取此对齐方式。您还可以请求类似 ClustalW 的输出：

```
>>> 从 Bio.Align.Applications 导入 MuscleCommandline
>>> cline = MuscleCommandline(input="opuntia.fasta", out="opuntia.aln", clw=True)
>>> 打印（克莱因）
肌肉-in opuntia.fasta -out opuntia.aln -clw
```

或者，使用原始 ClustalW 标题行以实现最大兼容性的严格 ClustalW 输出：

```
>>> 从 Bio.Align.Applications 导入 MuscleCommandline
>>> cline = MuscleCommandline(input="opuntia.fasta", out="opuntia.aln", clwstrict=True)
>>> 打印（克莱因）
肌肉-in opuntia.fasta -out opuntia.aln -clwstrict
```

该`Bio.AlignIO`模块应该能够使用format="clustal"读取这些对齐方式。

MUSCLE 也可以以 GCG MSF 格式输出（使用msf参数），但 Biopython 目前无法解析它，或者使用 HTML 来提供人类可读的网页（不适合解析）。

您还可以设置其他可选参数，例如最大迭代次数。有关详细信息，请参阅内置帮助。

然后，您将运行上面针对 ClustalW 描述的 MUSCLE 命令行字符串，并解析输出`Bio.AlignIO`以获取对齐对象。

### 6.5.3 使用标准输出的肌肉

使用上面示例中的 MUSCLE 命令行会将比对写入文件。这意味着不会有重要信息写入标准输出 (stdout) 或标准错误 (stderr) 句柄。但是，默认情况下 MUSCLE 会将比对写入标准输出 (stdout)。我们可以利用这一点来避免使用临时输出文件！例如：

```
>>> 从 Bio.Align.Applications 导入 MuscleCommandline
>>> muscle_cline = MuscleCommandline(input="opuntia.fasta")
>>> 打印（muscle_cline）
增肌仙人掌
```

如果我们通过包装器运行它，我们将以字符串形式返回输出。为了解析它，我们可以使用`StringIO`将它变成一个句柄。请记住，MUSCLE 默认使用 FASTA 作为输出格式：

```
>>> 从 Bio.Align.Applications 导入 MuscleCommandline
>>> muscle_cline = MuscleCommandline(input="opuntia.fasta")
>>> 标准输出，标准错误 = muscle_cline()
>>> 从 io 导入 StringIO
>>> 从 Bio 导入 AlignIO
>>> align = AlignIO.read(StringIO(stdout), "fasta")
>>> 打印（对齐）
对齐 7 行 906 列
TATACATTAAAGGAGGGGGATGCGGATAAATGGAAAGGCGAAAG...AGA gi|6273289|gb|AF191663.1|AF191663
TATACATTAAAGGAGGGGGATGCGGATAAATGGAAAGGCGAAAG...AGA gi|6273291|gb|AF191665.1|AF191665
TATACATTAAAGGAGGGGGATGCGGATAAATGGAAAGGCGAAAG...AGA gi|6273290|gb|AF191664.1|AF191664
TATACATTAAAGAAGGGGGATGCGGATAAATGGAAAGGCGAAAG...AGA gi|6273287|gb|AF191661.1|AF191661
TATACATAAAAGAAGGGGGATGCGGATAAATGGAAAGGCGAAAG...AGA gi|6273286|gb|AF191660.1|AF191660
TATACATTAAAGAAGGGGGATGCGGATAAATGGAAAGGCGAAAG...AGA gi|6273285|gb|AF191659.1|AF191659
TATACATTAAAGAAGGGGGATGCGGATAAATGGAAAGGCGAAAG...AGA gi|6273284|gb|AF191658.1|AF191658
```

上面的方法相当简单，但是如果您正在处理非常大的输出文本，那么所有 stdout 和 stderr 都作为字符串加载到内存中的事实可能是一个潜在的缺点。使用该`subprocess`模块，我们可以直接使用句柄来代替：

```
>>> 导入子流程
>>> 从 Bio.Align.Applications 导入 MuscleCommandline
>>> muscle_cline = MuscleCommandline(input="opuntia.fasta")
>>> child = subprocess.Popen(
... 海峡（肌肉倾斜），
...标准输出=子进程.PIPE，
... stderr=子进程.PIPE,
...文本=真，
...外壳=（sys.platform！=“win32”），
...）
>>> 从 Bio 导入 AlignIO
>>> align = AlignIO.read(child.stdout, "fasta")
>>> 打印（对齐）
对齐 7 行 906 列
TATACATTAAAGGAGGGGGATGCGGATAAATGGAAAGGCGAAAG...AGA gi|6273289|gb|AF191663.1|AF191663
TATACATTAAAGGAGGGGGATGCGGATAAATGGAAAGGCGAAAG...AGA gi|6273291|gb|AF191665.1|AF191665
TATACATTAAAGGAGGGGGATGCGGATAAATGGAAAGGCGAAAG...AGA gi|6273290|gb|AF191664.1|AF191664
TATACATTAAAGAAGGGGGATGCGGATAAATGGAAAGGCGAAAG...AGA gi|6273287|gb|AF191661.1|AF191661
TATACATAAAAGAAGGGGGATGCGGATAAATGGAAAGGCGAAAG...AGA gi|6273286|gb|AF191660.1|AF191660
TATACATTAAAGAAGGGGGATGCGGATAAATGGAAAGGCGAAAG...AGA gi|6273285|gb|AF191659.1|AF191659
TATACATTAAAGAAGGGGGATGCGGATAAATGGAAAGGCGAAAG...AGA gi|6273284|gb|AF191658.1|AF191658
```

### 6.5.4 使用标准输入和标准输出的肌肉

我们实际上不需要*在*文件中准备我们的 FASTA 输入序列，因为默认情况下 MUSCLE 将从标准输入读取输入序列！请注意，这有点更高级和繁琐，所以除非您需要，否则不要费心使用此技术。

首先，我们需要内存中的一些未对齐序列作为`SeqRecord`对象。对于这个演示，我将使用原始 FASTA 文件的过滤版本（使用生成器表达式），只使用七个序列中的六个：

```
>>> 从 Bio 导入 SeqIO
>>> records = (r for r in SeqIO.parse("opuntia.fasta", "fasta") if len(r) < 900)
```

然后我们创建 MUSCLE 命令行，将输入和输出保留为默认值（stdin 和 stdout）。对于输出，我还将要求使用严格的 ClustalW 格式。

```
>>> 从 Bio.Align.Applications 导入 MuscleCommandline
>>> muscle_cline = 肌肉命令行(clwstrict=True)
>>> 打印（muscle_cline）
肌肉收缩
```

`subprocess`现在对于使用模块、stdin 和 stdout 的繁琐位：

```
>>> 导入子流程
>>> 导入系统
>>> child = subprocess.Popen(
...海峡（克莱恩），
...标准输入=子进程.PIPE，
...标准输出=子进程.PIPE，
... stderr=子进程.PIPE,
...文本=真，
...外壳=（sys.platform！=“win32”），
...）
```

这应该启动 MUSCLE，但它将等待其 FASTA 输入序列，我们必须通过其标准输入句柄提供：

```
>>> SeqIO.write(records, child.stdin, "fasta")
6个
>>> child.stdin.close()
```

将六个序列写入句柄后，MUSCLE 仍将等待查看是否是所有 FASTA 序列——因此我们必须通过关闭句柄来表示这是所有输入数据。此时 MUSCLE 应该开始运行，我们可以请求输出：

```
>>> 从 Bio 导入 AlignIO
>>> align = AlignIO.read(child.stdout, "clustal")
>>> 打印（对齐）
6 行 900 列对齐
TATACATTAAAGGAGGGGGATGCGGATAAATGGAAAGGCGAAAG...AGA gi|6273290|gb|AF191664.1|AF19166
TATACATTAAAGGAGGGGGATGCGGATAAATGGAAAGGCGAAAG...AGA gi|6273289|gb|AF191663.1|AF19166
TATACATTAAAGAAGGGGGATGCGGATAAATGGAAAGGCGAAAG...AGA gi|6273287|gb|AF191661.1|AF19166
TATACATAAAAGAAGGGGGATGCGGATAAATGGAAAGGCGAAAG...AGA gi|6273286|gb|AF191660.1|AF19166
TATACATTAAAGAAGGGGGATGCGGATAAATGGAAAGGCGAAAG...AGA gi|6273285|gb|AF191659.1|AF19165
TATACATTAAAGAAGGGGGATGCGGATAAATGGAAAGGCGAAAG...AGA gi|6273284|gb|AF191658.1|AF19165
```

哇！我们只有六个记录的新比对，没有创建临时 FASTA 输入文件或临时比对输出文件。但是，请注意：使用这种调用外部程序的方式处理错误要复杂得多。诊断问题也变得更加困难，因为您不能尝试在 Biopython 之外手动运行 MUSCLE（因为您没有要提供的输入文件）。还可能存在微妙的跨平台问题（例如 Windows 与 Linux），并且您运行脚本的方式也会产生影响（例如在命令行、从 IDLE 或 IDE，或者作为 GUI 脚本）。不过，这些都是通用的 Python 问题，并不特定于 Biopython。

如果您发现像这样直接使用子流程很可怕，那么还有一个选择。如果您使用muscle_cline()执行该工具，您可以提供任何标准输入作为大字符串muscle_cline(stdin=...)。因此，如果您的数据不是很大，您可以使用StringIO将内存中的 FASTA 输入准备为字符串（参见第[23.1](https://biopython-org.translate.goog/DIST/docs/tutorial/Tutorial.html?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN&_x_tr_pto=wapp&_x_tr_sch=http#sec%3Aappendix-handles)）：

```
>>> 从 Bio 导入 SeqIO
>>> records = (r for r in SeqIO.parse("opuntia.fasta", "fasta") if len(r) < 900)
>>> 从 io 导入 StringIO
>>> 句柄 = StringIO()
>>> SeqIO.write(records, handle, "fasta")
6个
>>> 数据 = handle.getvalue()
```

然后您可以运行该工具并按如下方式解析对齐：

```
>>> stdout, stderr = muscle_cline(标准输入=数据)
>>> 从 Bio 导入 AlignIO
>>> align = AlignIO.read(StringIO(stdout), "clustal")
>>> 打印（对齐）
6 行 900 列对齐
TATACATTAAAGGAGGGGGATGCGGATAAATGGAAAGGCGAAAG...AGA gi|6273290|gb|AF191664.1|AF19166
TATACATTAAAGGAGGGGGATGCGGATAAATGGAAAGGCGAAAG...AGA gi|6273289|gb|AF191663.1|AF19166
TATACATTAAAGAAGGGGGATGCGGATAAATGGAAAGGCGAAAG...AGA gi|6273287|gb|AF191661.1|AF19166
TATACATAAAAGAAGGGGGATGCGGATAAATGGAAAGGCGAAAG...AGA gi|6273286|gb|AF191660.1|AF19166
TATACATTAAAGAAGGGGGATGCGGATAAATGGAAAGGCGAAAG...AGA gi|6273285|gb|AF191659.1|AF19165
TATACATTAAAGAAGGGGGATGCGGATAAATGGAAAGGCGAAAG...AGA gi|6273284|gb|AF191658.1|AF19165
```

您可能会发现这更容易，但它确实需要更多内存 (RAM) 来存储用于输入 FASTA 和输出 Clustal 格式数据的字符串。

### 6.5.5 压花针和水

[EMBOSS](https://translate.google.com/website?sl=auto&tl=zh-CN&hl=zh-CN&client=webapp&u=http://emboss.sourceforge.net/)套件包括用于 Smith-Waterman 算法局部对齐和 Needleman-Wunsch 全局对齐的水和针工具。这些工具共享相同样式的界面，因此在两者之间切换是微不足道的——我们在这里只使用needle。

假设你想在两个序列之间进行全局成对比对，以 FASTA 格式准备如下：

```
>HBA_人类
MVLSPADKTNVKAAWGKVGAHAGEYGAEALERMFLSFPTTKTYFPHFDLSHGSAQVKGHG
KKVADALTNAVAHVDDMPNALSALSDLHAHKLRVDPVNFKLLSHCLLVTLAAHLPAEFTP
AVHASLDKFLASVSTVLTSKYR
```

在文件alpha.faa中，其次在文件beta.faa中：

```
>HBB_HUMAN
MVHLTPEEKSAVTALWGKVNVDEVGGEALGRLLVVYPWTQRFFESFGDLSTPDAVMGNPK
VKAHGKKVLGAFSDGLAHLDNLKGTFATLSELHCDKLHVDPENFRLLGNVLVCVLAHHFG
KEFTPPVQAAYQKVVAGVANALAHKYH
```

您可以在该目录下找到这些示例文件的副本以及 Biopython 源代码`Doc/examples/`。

让我们从一次性创建一个完整的needle命令行对象开始：

```
>>> 从 Bio.Emboss.Applications 导入 NeedleCommandline
>>> needle_cline = NeedleCommandline(
...序列=“alpha.faa”，
... bsequence="beta.faa",
... 缺口 = 10，
... gapextend = 0.5，
...输出文件=“针.txt”，
...）
>>> 打印（needle_cline）
needle -outfile=needle.txt -asequence=alpha.faa -bsequence=beta.faa -gapopen=10 -gapextend=0.5
```

为什么不尝试在命令提示符下手动运行它呢？您应该看到它进行了成对比较并将输出记录在文件needle.txt中（采用默认的 EMBOSS 比对文件格式）。

即使您安装了 EMBOSS，运行此命令也可能无法正常工作——您可能会收到有关“找不到命令”的消息（尤其是在 Windows 上）。这可能意味着 EMBOSS 工具不在您的 PATH 环境变量中。您可以更新您的 PATH 设置，或者简单地告诉 Biopython 该工具的完整路径，例如：

```
>>> 从 Bio.Emboss.Applications 导入 NeedleCommandline
>>> needle_cline = NeedleCommandline(
... r"C:\EMBOSS\needle.exe",
...序列=“alpha.faa”，
... bsequence="beta.faa",
... 缺口 = 10，
... gapextend = 0.5，
...输出文件=“针.txt”，
...）
```

请记住，在 Python 中，对于默认字符串`\n`或`\t`表示换行或制表符——这就是为什么我们在原始字符串的开头放置字母“r”的原因。

此时尝试在命令行手动运行 EMBOSS 工具可能会有所帮助，以熟悉其他选项并将它们与 Biopython 帮助文本进行比较：

```
>>> 从 Bio.Emboss.Applications 导入 NeedleCommandline
>>> 帮助（NeedleCommandline）
```

请注意，您还可以指定（或更改或查看）这样的设置：

```
>>> 从 Bio.Emboss.Applications 导入 NeedleCommandline
>>> needle_cline = NeedleCommandline()
>>> needle_cline.asequence = "alpha.faa"
>>> needle_cline.bsequence = "beta.faa"
>>> needle_cline.gapopen = 10
>>> needle_cline.gapextend = 0.5
>>> needle_cline.outfile = "needle.txt"
>>> 打印（needle_cline）
needle -outfile=needle.txt -asequence=alpha.faa -bsequence=beta.faa -gapopen=10 -gapextend=0.5
>>> 打印（needle_cline.outfile）
针.txt
```

接下来我们要使用 Python 为我们运行这个命令。如上所述，为了完全控制，我们建议您使用内置的 Python 子进程模块，但为了简单使用，包装对象通常就足够了：

```
>>> 标准输出，标准错误 = needle_cline()
>>> 打印（标准输出 + 标准错误）
两个序列的 Needleman-Wunsch 全局比对
```

`Bio.AlignIO`接下来我们可以加载本章前面讨论的输出文件，作为浮雕格式：

```
>>> 从 Bio 导入 AlignIO
>>> align = AlignIO.read("needle.txt", "emboss")
>>> 打印（对齐）
2 行 149 列对齐
MV-LSPADKTNVKAAWGKVGAHAGEYGAEALERMFLSFPTTKTY...KYR HBA_HUMAN
MVHLTPEEKSAVTALWGKV--NVDEVGGEALGRLLVVYPWTQRF...KYH HBB_HUMAN
```

在这个例子中，我们告诉 EMBOSS 将输出写入一个文件，但你*可以*告诉它把输出写入 stdout（如果你不想删除临时输出文件很有用——使用stdout=True而不是outfile参数），以及读取来自 stdin 的输入之一（例如*asequence* = "stdin"，很像上一节中的 MUSCLE 示例）。

这只是触及了您可以用针和水做的事情的表面。一个有用的技巧是第二个文件可以包含多个序列（比如五个），然后 EMBOSS 将进行五个成对比对。

## 6.6 成对序列比对



成对序列比对是通过优化两个序列之间的相似性得分来将它们相互比对的过程。该`Bio.Align`模块包含`PairwiseAligner`使用 Needleman-Wunsch、Smith-Waterman、Gotoh（三态）和 Waterman-Smith-Beyer 全局和局部成对对齐算法进行全局和局部对齐的类，并具有用于更改对齐参数的多种选项。我们指的是 Durbin*等*人。[ [16](https://biopython-org.translate.goog/DIST/docs/tutorial/Tutorial.html?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN&_x_tr_pto=wapp&_x_tr_sch=http#durbin1998) ] 有关序列比对算法的深入信息。

### 6.6.1 基本用法



要生成成对比对，首先创建一个`PairwiseAligner`对象：

```
>>> 从 Bio 导入 Align
>>> 对齐器 = Align.PairwiseAligner()
```

该`PairwiseAligner`对象`aligner`（参见第[6.6.2](https://biopython-org.translate.goog/DIST/docs/tutorial/Tutorial.html?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN&_x_tr_pto=wapp&_x_tr_sch=http#sec%3Apairwise-aligner)）存储用于成对比对的比对参数。

这些属性可以在对象的构造函数中设置，也可以在创建对象之后设置。

```
>>> aligner = Align.PairwiseAligner(match_score=1.0)
```

或者，等效地：

```
>>> aligner.match_score = 1.0
```

使用该`aligner.score`方法计算两个序列之间的比对分数：

```
>>>目标=“GAACT”
>>> 查询 = "GAT"
>>> score = aligner.score(目标，查询)
>>> 分数
3.0
```

要查看实际对齐方式，请使用该`aligner.align`方法并迭代`Alignment`返回的对象：

```
>>> alignments = aligner.align(目标, 查询)
>>> 用于对齐对齐：
...打印（对齐）
...
目标 0 GAACT 5
                  0 ||--| 5个
查询 0 GA--T 3
<空白>
目标 0 GAACT 5
                  0 |-|-| 5个
查询 0 GAT 3
<空白>
```

默认情况下，执行全局成对比对，它会在`target`和的整个长度上找到最佳比对`query`。相反，局部比对将找到具有最高比对分数的`target`子序列。可以通过设置`query`为生成局部对齐：`aligner.mode``"local"`

```
>>> aligner.mode = "本地"
>>> 目标 = "AGAACTC"
>>>查询=“GAACT”
>>> score = aligner.score(目标，查询)
>>> 分数
5.0
>>> alignments = aligner.align(目标, 查询)
>>> 用于对齐对齐：
...打印（对齐）
...
目标 1 GAACT 6
                  0 ||||| 5个
查询 0 GAACT 5
<空白>
```

请注意，如果可以将分数为 0 的片段添加到对齐中，则最佳局部对齐的定义存在一些歧义。[我们遵循 Waterman & Eggert [ 42](https://biopython-org.translate.goog/DIST/docs/tutorial/Tutorial.html?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN&_x_tr_pto=wapp&_x_tr_sch=http#waterman1987) ]的建议并禁止此类扩展。

### 6.6.2 成对对齐器对象



该`PairwiseAligner`对象存储用于成对比对的所有比对参数。要查看所有参数值的概览，请使用

```
>>> 打印（对准器）
带参数的成对序列比对器
  通配符：无
  匹配分数：1.000000
  不匹配分数：0.000000
  target_internal_open_gap_score：0.000000
  target_internal_extend_gap_score：0.000000
  target_left_open_gap_score：0.000000
  target_left_extend_gap_score：0.000000
  target_right_open_gap_score：0.000000
  target_right_extend_gap_score：0.000000
  query_internal_open_gap_score：0.000000
  query_internal_extend_gap_score：0.000000
  query_left_open_gap_score：0.000000
  query_left_extend_gap_score：0.000000
  query_right_open_gap_score: 0.000000
  query_right_extend_gap_score：0.000000
  模式：本地
<空白>
```

有关这些参数的定义，请参阅下面的[章节](https://biopython-org.translate.goog/DIST/docs/tutorial/Tutorial.html?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN&_x_tr_pto=wapp&_x_tr_sch=http#sec%3Apairwise-affine-gapscores)[‍6.6.3、6.6.4](https://biopython-org.translate.goog/DIST/docs/tutorial/Tutorial.html?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN&_x_tr_pto=wapp&_x_tr_sch=http#sec%3Apairwise-substitution-scores)和6.6.5 [。](https://biopython-org.translate.goog/DIST/docs/tutorial/Tutorial.html?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN&_x_tr_pto=wapp&_x_tr_sch=http#sec%3Apairwise-general-gapscores)属性（在上文[第 6.6.1](https://biopython-org.translate.goog/DIST/docs/tutorial/Tutorial.html?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN&_x_tr_pto=wapp&_x_tr_sch=http#sec%3Apairwise-basic)）可以设置为等于或分别指定全局或局部成对对齐。`mode``"global"``"local"`

根据间隙评分参数（参见第[6.6.4](https://biopython-org.translate.goog/DIST/docs/tutorial/Tutorial.html?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN&_x_tr_pto=wapp&_x_tr_sch=http#sec%3Apairwise-affine-gapscores)和[6.6.5](https://biopython-org.translate.goog/DIST/docs/tutorial/Tutorial.html?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN&_x_tr_pto=wapp&_x_tr_sch=http#sec%3Apairwise-general-gapscores)节）和模式，`PairwiseAligner`对象自动选择适当的算法用于成对序列比对。要验证所选算法，请使用

```
>>> aligner.算法
'史密斯 - 沃特曼'
```

该属性是只读的。

对象`PairwiseAligner`还存储对齐期间要使用的精度 є。є 的值存储在属性 中`aligner.epsilon`，默认情况下等于 10 −6：

```
>>> aligner.epsilon
1e-06
```

如果两个分数之间的绝对差小于 є，则出于比对的目的，两个分数将被视为彼此相等。

### 6.6.3 替补得分



当两个字母（核苷酸或氨基酸）相互对齐时，替换分数定义了要添加到总分中的值。`PairwiseAligner`可以通过两种方式指定要使用的替换分数：

- 通过为相同字母指定匹配分数，为不匹配字母指定不匹配分数。核苷酸序列比对通常基于匹配和错配分数。例如，默认情况下，BLAST [ 

  26

   ] 使用 +1 的匹配分数和 −2 的错配分数进行核苷酸比对

  ```
  megablast
  ```

  ，空位惩罚为 2.5（有关空位分数的更多信息，请参见第

  6.6.4节）。

  可以通过设置对象的

  ```
  match
  ```

  和属性来指定匹配和不匹配分数：

  ```
  mismatch
  ```

  

  ```
  PairwiseAligner
  ```

  

  ```
  >>> 从 Bio 导入 Align
  >>> 对齐器 = Align.PairwiseAligner()
  >>> aligner.match_score
  1.0
  >>> aligner.mismatch_score
  0.0
  >>> score = aligner.score("ACGT", "ACAT")
  >>> 打印（分数）
  3.0
  >>> aligner.match_score = 1.0
  >>> aligner.mismatch_score = -2.0
  >>> aligner.gap_score = -2.5
  >>> score = aligner.score("ACGT", "ACAT")
  >>> 打印（分数）
  1.0
  ```

  使用匹配和不匹配分数时，您可以为未知字母指定通配符（默认为 +None+）。无论匹配或不匹配分数的值如何，这些都将在比对中获得零分：

  ```
  >>> aligner.wildcard = "?"
  >>> score = aligner.score("ACGT", "AC?T")
  >>> 打印（分数）
  3.0
  ```

- 或者，您可以使用对象

  ```
  substitution_matrix
  ```

  的属性

  ```
  PairwiseAligner
  ```

  来指定替换矩阵。这允许您为不同的匹配和不匹配字母对应用不同的分数。这通常用于氨基酸序列比对。例如，默认情况下，BLAST [ 

  26

   ] 使用 BLOSUM62 替代矩阵进行蛋白质比对

  ```
  blastp
  ```

  。该替换矩阵可从 Biopython 获得：

  ```
  >>> 从 Bio.Align 导入替代矩阵
  >>> substitution_matrices.load() ## doctest: +ELLIPSIS
  ['BENNER22', 'BENNER6', 'BENNER74', 'BLASTN', 'BLASTP', 'BLOSUM45', 'BLOSUM50', 'BLOSUM62', ..., 'TRANS']
  >>> matrix = substitution_matrices.load("BLOSUM62")
  >>> print(matrix) ## 文档测试：+ELLIPSIS
  ## matblas 从 blosum62.iij 制作的矩阵
  ...
       阿诺德...
  一个 4.0 -1.0 -2.0 -2.0 0.0 -1.0 ...
  R -1.0 5.0 0.0 -2.0 -3.0 1.0 ...
  N -2.0 0.0 6.0 1.0 -3.0 0.0 ...
  D -2.0 -2.0 1.0 6.0 -3.0 0.0 ...
  C 0.0 -3.0 -3.0 -3.0 9.0 -3.0 ...
  Q -1.0 1.0 0.0 0.0 -3.0 5.0 ...
  ...
  >>> aligner.substitution_matrix = 矩阵
  >>> score = aligner.score("ACDQ", "ACDQ")
  >>> 分数
  24.0
  >>> score = aligner.score("ACDQ", "ACNQ")
  >>> 分数
  19.0
  ```

  使用替换矩阵时，`X`不被*解释*为未知字符。相反，将使用替换矩阵提供的分数：

  ```
  >>> 矩阵["D", "X"]
  -1.0
  >>> score = aligner.score("ACDQ", "ACXQ")
  >>> 分数
  17.0
  ```

默认情况下，`aligner.substitution_matrix`是`None`. 如果不是，则忽略属性`aligner.match_score`和。将or设置为有效值将重置为。`aligner.mismatch_score``aligner.substitution_matrix``None``aligner.match_score``aligner.mismatch_score``aligner.substitution_matrix``None`

### 6.6.4 仿射间隙分数



仿射差距分数由打开差距的分数和扩展现有差距的分数定义：

gap score = open gap score + ( *n* −1) × extend gap score,

其中*n*是间隙的长度。Biopython 的成对序列比对器允许通过指定对象的以下十二个属性来细粒度地控制空位评分方案`PairwiseAligner`：

> ------
>
> | **开场分数**                     | **扩展分数**                       |
> | -------------------------------- | ---------------------------------- |
> | `query_left_open_gap_score`      | `query_left_extend_gap_score`      |
> | `query_internal_open_gap_score`  | `query_internal_extend_gap_score`  |
> | `query_right_open_gap_score`     | `query_right_extend_gap_score`     |
> | `target_left_open_gap_score`     | `target_left_extend_gap_score`     |
> | `target_internal_open_gap_score` | `target_internal_extend_gap_score` |
> | `target_right_open_gap_score`    | `target_right_extend_gap_score`    |
>
> ------

这些属性允许内部间隙和序列两端的不同间隙分数，如本例所示：

> ------
>
> | **目标** | **询问** | **分数**                     |
> | -------- | -------- | ---------------------------- |
> | A        | -        | 查询左开差距分数             |
> | C        | -        | 查询左延伸差距得分           |
> | C        | -        | 查询左延伸差距得分           |
> | G        | G        | 比赛得分                     |
> | G        | 吨       | 错配分数                     |
> | G        | -        | 查询内部开放差距分数         |
> | A        | -        | 查询内部扩展差距分数         |
> | A        | -        | 查询内部扩展差距分数         |
> | 吨       | 吨       | 比赛得分                     |
> | A        | A        | 比赛得分                     |
> | G        | -        | 查询内部开放差距分数         |
> | C        | C        | 比赛得分                     |
> | -        | C        | 目标内部开放差距分数         |
> | -        | C        | 目标内部扩展差距分数         |
> | C        | C        | 比赛得分                     |
> | 吨       | G        | 错配分数                     |
> | C        | C        | 比赛得分                     |
> | -        | C        | 目标内部开放差距分数         |
> | A        | A        | 比赛得分                     |
> | -        | 吨       | 目标右侧空隙分数             |
> | -        | A        | Target right extend gap 分数 |
> | -        | A        | Target right extend gap 分数 |
>
> ------

为方便起见，`PairwiseAligner`对象具有额外的属性，这些属性共同引用这些值中的许多值，如表[6.1](https://biopython-org.translate.goog/DIST/docs/tutorial/Tutorial.html?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN&_x_tr_pto=wapp&_x_tr_sch=http#table%3Aalign-meta-attributes)。

> ------
>
> 表 6.1：成对对齐器对象的元属性。
>
> | **元属性**                    | **它映射到的属性**                                           |
> | ----------------------------- | ------------------------------------------------------------ |
> | `gap_score`                   | `target_gap_score`,`query_gap_score`                         |
> | `open_gap_score`              | `target_open_gap_score`,`query_open_gap_score`               |
> | `extend_gap_score`            | `target_extend_gap_score`,`query_extend_gap_score`           |
> | `internal_gap_score`          | `target_internal_gap_score`,`query_internal_gap_score`       |
> | `internal_open_gap_score`     | `target_internal_open_gap_score`,`query_internal_open_gap_score` |
> | `internal_extend_gap_score`   | `target_internal_extend_gap_score`,`query_internal_extend_gap_score` |
> | `end_gap_score`               | `target_end_gap_score`,`query_end_gap_score`                 |
> | `end_open_gap_score`          | `target_end_open_gap_score`,`query_end_open_gap_score`       |
> | `end_extend_gap_score`        | `target_end_extend_gap_score`,`query_end_extend_gap_score`   |
> | `left_gap_score`              | `target_left_gap_score`,`query_left_gap_score`               |
> | `right_gap_score`             | `target_right_gap_score`,`query_right_gap_score`             |
> | `left_open_gap_score`         | `target_left_open_gap_score`,`query_left_open_gap_score`     |
> | `left_extend_gap_score`       | `target_left_extend_gap_score`,`query_left_extend_gap_score` |
> | `right_open_gap_score`        | `target_right_open_gap_score`,`query_right_open_gap_score`   |
> | `right_extend_gap_score`      | `target_right_extend_gap_score`,`query_right_extend_gap_score` |
> | `target_open_gap_score`       | `target_internal_open_gap_score`, `target_left_open_gap_score`, |
> |                               | `target_right_open_gap_score`                                |
> | `target_extend_gap_score`     | `target_internal_extend_gap_score`, `target_left_extend_gap_score`, |
> |                               | `target_right_extend_gap_score`                              |
> | `target_gap_score`            | `target_open_gap_score`,`target_extend_gap_score`            |
> | `query_open_gap_score`        | `query_internal_open_gap_score`, `query_left_open_gap_score`, |
> |                               | `query_right_open_gap_score`                                 |
> | `query_extend_gap_score`      | `query_internal_extend_gap_score`, `query_left_extend_gap_score`, |
> |                               | `query_right_extend_gap_score`                               |
> | `query_gap_score`             | `query_open_gap_score`,`query_extend_gap_score`              |
> | `target_internal_gap_score`   | `target_internal_open_gap_score`,`target_internal_extend_gap_score` |
> | `target_end_gap_score`        | `target_end_open_gap_score`,`target_end_extend_gap_score`    |
> | `target_end_open_gap_score`   | `target_left_open_gap_score`,`target_right_open_gap_score`   |
> | `target_end_extend_gap_score` | `target_left_extend_gap_score`,`target_right_extend_gap_score` |
> | `target_left_gap_score`       | `target_left_open_gap_score`,`target_left_extend_gap_score`  |
> | `target_right_gap_score`      | `target_right_open_gap_score`,`target_right_extend_gap_score` |
> | `query_end_gap_score`         | `query_end_open_gap_score`,`query_end_extend_gap_score`      |
> | `query_end_open_gap_score`    | `query_left_open_gap_score`,`query_right_open_gap_score`     |
> | `query_end_extend_gap_score`  | `query_left_extend_gap_score`,`query_right_extend_gap_score` |
> | `query_internal_gap_score`    | `query_internal_open_gap_score`,`query_internal_extend_gap_score` |
> | `query_left_gap_score`        | `query_left_open_gap_score`,`query_left_extend_gap_score`    |
> | `query_right_gap_score`       | `query_right_open_gap_score`,`query_right_extend_gap_score`  |
>
> 
>
> ------

### 6.6.5 一般差距分数



为了更精细地控制差距分数，您可以指定差距评分函数。例如，下面的空位评分函数不允许在查询序列中的两个核苷酸后出现空位：

```
>>> 从 Bio 导入 Align
>>> 对齐器 = Align.PairwiseAligner()
>>> def my_gap_score_function（开始，长度）：
... 如果开始 == 2：
...返回-1000
... 别的：
... 返回 -1 * 长度
...
>>> aligner.query_gap_score = my_gap_score_function
>>> alignments = aligner.align("AACTT", "AATT")
>>> 用于对齐对齐：
...打印（对齐）
...
目标 0 AACTT 5
                  0 -|。|| 5个
查询 0 -AATT 4
<空白>
目标 0 AACTT 5
                  0 |-.|| 5个
查询 0 A-ATT 4
<空白>
目标 0 AACTT 5
                  0 ||.-| 5个
查询 0 AAT-T 4
<空白>
目标 0 AACTT 5
                  0 ||.|- 5
查询 0 AATT- 4
<空白>
```

### 6.6.6 使用预定义的替代矩阵和差距分数



默认情况下，`PairwiseAligner`对象初始化为匹配分数为 +1.0，不匹配分数为 0.0，所有间隙分数等于 0.0，虽然这是一个简单的评分方案，但通常它不会提供最佳性能. 相反，您可以在初始化对象时使用参数`scoring`来选择预定义的评分方案`PairwiseAligner`。目前提供的评分方案有`blastn`和`megablast`，适用于核苷酸比对， 和`blastp`，适用于蛋白质比对。选择这些评分方案会将`PairwiseAligner`对象初始化为 BLASTN、MegaBLAST 和 BLASTP 分别使用的默认评分参数。

```
>>> 从 Bio 导入 Align
>>> aligner = Align.PairwiseAligner(scoring="blastn")
>>> print(aligner) ## doctest:+省略号
带参数的成对序列比对器
  substitution_matrix: <Array object at ...>
  target_internal_open_gap_score：-7.000000
  target_internal_extend_gap_score：-2.000000
  target_left_open_gap_score：-7.000000
  target_left_extend_gap_score：-2.000000
  target_right_open_gap_score：-7.000000
  target_right_extend_gap_score：-2.000000
  query_internal_open_gap_score：-7.000000
  query_internal_extend_gap_score：-2.000000
  query_left_open_gap_score：-7.000000
  query_left_extend_gap_score：-2.000000
  query_right_open_gap_score：-7.000000
  query_right_extend_gap_score：-2.000000
  模式：全球
<空白>
>>> 打印（aligner.substitution_matrix[:, :]）
     ATGCSWRYKMBVHDN
A 2.0 -3.0 -3.0 -3.0 -3.0 -1.0 -1.0 -3.0 -3.0 -1.0 -3.0 -1.0 -1.0 -1.0 -2.0
T -3.0 2.0 -3.0 -3.0 -3.0 -1.0 -3.0 -1.0 -1.0 -3.0 -1.0 -3.0 -1.0 -1.0 -2.0
G -3.0 -3.0 2.0 -3.0 -1.0 -3.0 -1.0 -3.0 -1.0 -3.0 -1.0 -1.0 -3.0 -1.0 -2.0
C -3.0 -3.0 -3.0 2.0 -1.0 -3.0 -3.0 -1.0 -3.0 -1.0 -1.0 -1.0 -1.0 -3.0 -2.0
S -3.0 -3.0 -1.0 -1.0 -1.0 -3.0 -1.0 -1.0 -1.0 -1.0 -1.0 -1.0 -1.0 -1.0 -2.0
W -1.0 -1.0 -3.0 -3.0 -3.0 -1.0 -1.0 -1.0 -1.0 -1.0 -1.0 -1.0 -1.0 -1.0 -2.0
R -1.0 -3.0 -1.0 -3.0 -1.0 -1.0 -1.0 -3.0 -1.0 -1.0 -1.0 -1.0 -1.0 -1.0 -2.0
Y -3.0 -1.0 -3.0 -1.0 -1.0 -1.0 -3.0 -1.0 -1.0 -1.0 -1.0 -1.0 -1.0 -1.0 -2.0
K -3.0 -1.0 -1.0 -3.0 -1.0 -1.0 -1.0 -1.0 -1.0 -3.0 -1.0 -1.0 -1.0 -1.0 -2.0
M -1.0 -3.0 -3.0 -1.0 -1.0 -1.0 -1.0 -1.0 -3.0 -1.0 -1.0 -1.0 -1.0 -1.0 -2.0
B -3.0 -1.0 -1.0 -1.0 -1.0 -1.0 -1.0 -1.0 -1.0 -1.0 -1.0 -1.0 -1.0 -1.0 -2.0
V -1.0 -3.0 -1.0 -1.0 -1.0 -1.0 -1.0 -1.0 -1.0 -1.0 -1.0 -1.0 -1.0 -1.0 -2.0
H -1.0 -1.0 -3.0 -1.0 -1.0 -1.0 -1.0 -1.0 -1.0 -1.0 -1.0 -1.0 -1.0 -1.0 -2.0
D -1.0 -1.0 -1.0 -3.0 -1.0 -1.0 -1.0 -1.0 -1.0 -1.0 -1.0 -1.0 -1.0 -1.0 -2.0
N -2.0 -2.0 -2.0 -2.0 -2.0 -2.0 -2.0 -2.0 -2.0 -2.0 -2.0 -2.0 -2.0 -2.0 -2.0
<空白>
```

### 6.6.7 遍历对齐

返回`alignments`的`aligner.align`是一种不可变的可迭代对象（类似于`range`）。`tuple`虽然它们看起来与对象的 a或`list`of相似`Alignment`，但它们的不同之处在于每个`Alignment`对象都是在需要时动态创建的。选择这种方法是因为比对的数量可能非常大，特别是对于较差的比对（参见第[6.6.10](https://biopython-org.translate.goog/DIST/docs/tutorial/Tutorial.html?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN&_x_tr_pto=wapp&_x_tr_sch=http#sec%3Apairwise-examples)的示例）。

您可以对 执行以下操作`alignments`：

- ```
  len(alignments)
  ```

  返回存储的对齐数。这个函数返回很快，即使对齐的数量很大。如果对齐数非常大（通常大于 9,223,372,036,854,775,807，这是

  ```
  long int
  ```

  64 位机器上可以存储为 a 的最大整数），

  ```
  len(alignments)
  ```

  将引发一个

  ```
  OverflowError
  ```

  . 大量比对表明比对质量低。

  ```
  >>> 从 Bio 导入 Align
  >>> 对齐器 = Align.PairwiseAligner()
  >>> alignments = aligner.align("AAA", "AA")
  >>> len（对齐方式）
  3个
  ```

- 您可以通过索引提取特定的对齐方式：

  ```
  >>> 从 Bio 导入 Align
  >>> 对齐器 = Align.PairwiseAligner()
  >>> alignments = aligner.align("AAA", "AA")
  >>> 打印（对齐[2]）
  目标 0 AAA 3
                    0 -|| 3个
  查询 0 -AA 2
  <空白>
  >>> 打印（对齐[0]）
  目标 0 AAA 3
                    0 ||- 3
  查询 0 AA- 2
  <空白>
  ```

- 您可以迭代对齐方式，例如

  ```
  >>> 用于对齐对齐：
  ...打印（对齐）
  ...
  ```

  请注意，

  ```
  alignments
  ```

  可以重复使用，即您可以多次迭代对齐：

  ```
  >>> 从 Bio 导入 Align
  >>> 对齐器 = Align.PairwiseAligner()
  >>> alignments = aligner.align("AAA", "AA")
  >>> 用于对齐对齐：
  ...打印（对齐）
  ...
  目标 0 AAA 3
                    0 ||- 3
  查询 0 AA- 2
  <空白>
  目标 0 AAA 3
                    0 |-| 3个
  查询 0 AA 2
  <空白>
  目标 0 AAA 3
                    0 -|| 3个
  查询 0 -AA 2
  <空白>
  >>> 用于对齐对齐：
  ...打印（对齐）
  ...
  目标 0 AAA 3
                    0 ||- 3
  查询 0 AA- 2
  <空白>
  目标 0 AAA 3
                    0 |-| 3个
  查询 0 AA 2
  <空白>
  目标 0 AAA 3
                    0 -|| 3个
  查询 0 -AA 2
  <空白>
  ```

  您还可以将`alignments`迭代器转换为`list`or `tuple`：

  ```
  >>> 对齐方式 = 列表（对齐方式）
  ```

  `len(alignments)`在尝试调用`list(alignments)`以将所有对齐方式保存为列表之前，通过调用检查对齐方式的数量是明智的。

- 比对分数（对于每个比对具有相同的值

  ```
  alignments
  ```

  ）被存储为一个属性。这允许您在继续提取单个比对之前检查比对分数：

  ```
  >>> 打印（对齐方式。分数）
  2.0
  ```

### 6.6.8 对齐对象

该`aligner.align`方法返回`Alignment`对象，每个对象代表两个序列之间的一个比对。

```
>>> 从 Bio 导入 Align
>>> 对齐器 = Align.PairwiseAligner()
>>>目标=“GAACT”
>>> 查询 = "GAT"
>>> alignments = aligner.align(目标, 查询)
>>>对齐=对齐[0]
>>> 比对#doctest: +ELLIPSIS
<Alignment object (2 rows x 5 columns) at ...>
```

每个对齐存储对齐分数：

```
>>> alignment.score
3.0
```

以及指向对齐序列的指针：

```
>>> alignment.target
'GAACT'
>>> alignment.query
'盖特'
```

打印`Alignment`对象以明确显示对齐方式：

```
>>> 打印（对齐）
目标 0 GAACT 5
                  0 ||--| 5个
查询 0 GA--T 3
<空白>
```

在内部，比对是根据序列坐标存储的：

```
>>> alignment.coordinates
阵列（[[0, 2, 4, 5],
       [0, 2, 2, 3]])
```

这里，两行指的是目标和查询序列。这些坐标表明对齐由以下三个块组成：

- `target[0:2]`对齐到`query[0:2]`；
- `target[2:4]`对齐到一个间隙，因为`query[2:2]`是一个空字符串；
- `target[4:5]`对齐到`query[2:3]`.

对齐的长度定义为对齐序列的数量，对于成对对齐始终为 2：

```
>>> len（对齐）
2个
```

该`shape`属性返回一个元组，其中包含对齐的长度和打印的对齐中的列数：

```
>>> alignment.shape
(2, 5)
```

对于局部对齐，未对齐的部分不计入列数：

```
>>> aligner.mode = "本地"
>>> local_alignments = aligner.align("TGAACT", "GAC")
>>> local_alignment = local_alignments[0]
>>> 打印（局部对齐）
目标 1 GAAC 5
                  0 ||-| 4个
查询 0 GA-C 3
<空白>
>>> local_alignment.shape
(2, 4)
```

使用该`aligned`属性查找目标和查询序列中相互对齐的子序列的开始和结束索引。通常，如果目标 (t) 和查询 (q) 之间的对齐由*N个块组成，您将得到一个维度为 2 ×* *N* × 2的 numpy 数组：

```
(
    ((t_start1, t_end1), (t_start2, t_end2), ..., (t_startN, t_endN)),
    ((q_start1, q_end1), (q_start2, q_end2), ..., (q_startN, q_endN)),
)
```

在当前示例中，`alignment.aligned`返回两个长度为 2 的元组：

```
>>> alignment.aligned
阵列（[[[0, 2],
        [4, 5]],
<空白>
       [[0, 2],
        [2, 3]]])
```

而对于替代对齐方式，返回两个长度为 3 的元组：

```
>>>对齐=对齐[1]
>>> 打印（对齐）
目标 0 GAACT 5
                  0 |-|-| 5个
查询 0 GAT 3
<空白>
>>> alignment.aligned
阵列（[[[0, 1],
        [2, 3],
        [4, 5]],
<空白>
       [[0, 1],
        [1, 2],
        [2, 3]]])
```

请注意，不同的比对可能具有彼此对齐的相同子序列。特别是，如果对齐仅在间隙位置方面彼此不同，则可能会发生这种情况：

```
>>> aligner.mode = "全局"
>>> aligner.mismatch_score = -10
>>> alignments = aligner.align("AAACAAA", "AAAGAAA")
>>> len（对齐方式）
2个
>>> 打印（对齐[0]）
目标 0 AAAC-AAA 7
                  0 |||--||| 8个
查询 0 AAA-GAAA 7
<空白>
>>> 对齐[0].对齐
阵列（[[[0, 3],
        [4, 7]],
<空白>
       [[0, 3],
        [4, 7]]])
>>> 打印（对齐[1]）
目标 0 AAA-CAAA 7
                  0 |||--||| 8个
查询 0 AAAG-AAA 7
<空白>
>>> 对齐[1].对齐
阵列（[[[0, 3],
        [4, 7]],
<空白>
       [[0, 3],
        [4, 7]]])
```

该`aligned`属性可用于识别在其比对序列方面彼此相同的比对。

该`sort`方法对比对序列进行排序。默认情况下，如果可用，则根据`id`每个序列的属性进行排序，否则根据序列内容进行排序。

```
>>> 打印（局部对齐）
目标 1 GAAC 5
                  0 ||-| 4个
查询 0 GA-C 3
<空白>
>>> local_alignment.sort()
>>> 打印（局部对齐）
目标 0 GA-C 3
                  0 ||-| 4个
查询 1 GAAC 5
<空白>
```

或者，您可以提供一个`key`函数来确定排序顺序。例如，您可以通过增加 GC 含量来对序列进行排序：

```
>>> 从 Bio.SeqUtils 导入 gc_fraction
>>> local_alignment.sort(key=gc_fraction)
>>> 打印（局部对齐）
目标 1 GAAC 5
                  0 ||-| 4个
查询 0 GA-C 3
<空白>
```

该`reverse`参数允许您反转排序顺序以获得 GC 内容递减的序列：

```
>>> local_alignment.sort（key=gc_fraction，reverse=True）
>>> 打印（局部对齐）
目标 0 GA-C 3
                  0 ||-| 4个
查询 1 GAAC 5
<空白>
```

使用该`substitutions`方法找出每对核苷酸之间的替换数：

```
>>>目标=“AAAAAAAACCCCCCCCGGGGGGGTTTTTTTTT”
>>> query = "AAAAAAACCCTCCCCGGCCGGGTTTAGTTT"
>>> alignments = aligner.align(目标, 查询)
>>> aligner.mismatch_score = -1
>>> aligner.gap_score = -1
>>> alignments = aligner.align(目标, 查询)
>>> len（对齐方式）
8个
>>> 打印（对齐[0]）
目标 0 AAAAAAAACCCCCCCCCGGGGGGGTTTTTTTTT 32
                  0 |||||||-|||。||||||..|||||||..||| 32
查询 0 AAAAAAA-CCCTCCCCGGCCGGGGTTTAGTTT 31
<空白>
>>> m = 对齐[0].替换
>>> 打印（米）
    ACGT
一个 7.0 0.0 0.0 0.0
C 0.0 7.0 0.0 1.0
G 0.0 2.0 6.0 0.0
T 1.0 0.0 1.0 6.0
<空白>
```

请注意，矩阵不是对称的：行对应于目标序列，列对应于查询序列。例如，目标序列中与查询序列中的 C 对齐的 G 的数量是

```
>>> 米[“G”，“C”]
2.0
```

并且查询序列中与查询序列中的 T 对齐的 C 的数量是

```
>>> m["C", "G"]
0.0
```

要获得对称矩阵，请使用

```
>>> m += m.transpose()
>>> 米 /= 2.0
>>> 打印（米）
    ACGT
一个 7.0 0.0 0.0 0.5
C 0.0 7.0 1.0 0.5
G 0.0 1.0 6.0 0.5
T 0.5 0.5 0.5 6.0
<空白>
>>> 米[“G”，“C”]
1.0
>>> m["C", "G"]
1.0
```

比对中 C 和 G 之间的替换总数为 1.0 + 1.0 = 2。

该`map`方法可以应用于成对对齐，`alignment1`以找到查询的成对对齐`alignment2`到的目标`alignment1`，其中目标`alignment2`和查询`alignment1`相同。一个典型的例子是哪里`alignment1`是染色体和转录本之间的成对比对，`alignment2`是转录本和序列（例如，RNA-seq read）之间的成对比对，我们想要找到序列与染色体的比对：

```
>>> aligner.mode = "本地"
>>> aligner.open_gap_score = -1
>>> aligner.extend_gap_score = 0
>>>染色体=“AAAAAAAACCCCCCAAAAAAAAAAAGGGGGGAAAAAAAA”
>>> 成绩单 = "CCCCCCCGGGGGG"
>>> alignments1 = aligner.align（染色体，转录本）
>>> len（对齐1）
1个
>>> alignment1 = alignments1[0]
>>> 打印（对齐1）
目标 8 CCCCCCAAAAAAAAAAAGGGGGG 32
                  0 |||||||------------|||||| 24
查询 0 CCCCCCC------------GGGGGG 13
<空白>
>>> 序列 = "CCCCGGGG"
>>> alignments2 = aligner.align(转录本，序列)
>>> len（对齐方式2）
1个
>>> alignment2 = alignments2[0]
>>> 打印（对齐2）
目标 3 CCCCGGGG 11
                  0 |||||||| 8个
查询 0 CCCCGGGG 8
<空白>
>>> mapped_alignment = alignment1.map(alignment2)
>>> 打印（映射对齐）
目标 11 CCCCAAAAAAAAAAAGGGG 30
                  0 ||||------------|||| 19
查询 0 CCCC------------GGGG 8
<空白>
>>> 格式（映射对齐，“psl”）
'8\t0\t0\t0\t0\t0\t1\t11\t+\tquery\t8\t0\t8\ttarget\t40\t11\t30\t2\t4,4,\t0,4,\t11,26 ,\n'
```

比对映射不依赖于序列内容。如果我们删除序列内容，在 PSL 格式中会发现相同的比对（尽管我们显然失去了打印序列比对的能力）：

```
>>> 从 Bio.Seq 导入 Seq
>>> alignment1.target = Seq(None, len(alignment1.target))
>>> alignment1.query = Seq(None, len(alignment1.query))
>>> alignment2.target = Seq(None, len(alignment2.target))
>>> alignment2.query = Seq(None, len(alignment2.query))
>>> mapped_alignment = alignment1.map(alignment2)
>>> 格式（映射对齐，“psl”）
'8\t0\t0\t0\t0\t0\t1\t11\t+\tquery\t8\t0\t8\ttarget\t40\t11\t30\t2\t4,4,\t0,4,\t11,26 ,\n'
```

###### 切片和索引成对对齐

形式的切片`alignment[k, i:j]`，其中`k`是一个整数，并且`i`是`j`整数或不存在，返回一个字符串，显示目标（if `k=0`）或查询（if ）的对齐序列（包括间隙），该字符串仅包含打印对齐中的`k=1`列.`i``j`

为了说明这一点，在以下示例中，打印的对齐方式有 5 列：

```
>>> 打印（对齐）
目标 0 GAACT 5
                  0 |-|-| 5个
查询 0 GAT 3
<空白>
```

要单独获取对齐的序列字符串，请使用

```
>>> 对齐[0]
'GAACT'
>>> 对齐[1]
'盖特'
>>> 对齐[0, :]
'GAACT'
>>> 对齐[1, :]
'盖特'
>>> 对齐[0, 1:-1]
'AAC'
>>> 对齐[1, 1:-1]
'-A-'
```

也可以使用整数上的迭代来选择要包含的列：

```
>>> 对齐[0, (1, 3, 4)]
'行为'
>>> 对齐[1, 范围(0, 5, 2)]
'盖特'
```

要获取对齐中的特定列，请使用

```
>>> 对齐[:, 0]
'GG'
>>> 对齐[:, 1]
'A-'
>>> 对齐[:, 2]
'AA'
```

形式的切片`alignment[:, i:j]`，其中`i`和`j`是整数或不存在，返回一个新对象，该对象仅包括打印对齐中的`Alignment`列。`i``j`

为上面的示例对齐提取前 4 列给出：

```
>>> 对齐方式[:, :4] ## doctest:+ELLIPSIS
<Alignment object (2 rows x 4 columns) at ...>
>>> 打印（对齐[:, :4]）
目标 0 GAAC 4
                  0 |-|- 4
查询 0 GA- 2
<空白>
```

在这里，最终的`T`核苷酸仍然显示，但它们没有相互对齐。请注意，这`alignment`是全局比对，但`alignment[:, :4]`它是局部比对。

同样，提取最后 3 列给出：

```
>>> alignment[:, -3:] ## doctest:+ELLIPSIS
<Alignment object (2 rows x 3 columns) at ...>
>>> 打印（对齐方式[:, -3:]）
目标 2 ACT 5
                  0 |-| 3个
查询 1 AT 3
<空白>
```

`GA`现在这也是局部比对，目标中的初始核苷酸和`G`查询中的核苷酸彼此不对齐。

列索引也可以是整数的可迭代：

```
>>> alignment[:, -3:] ## doctest:+ELLIPSIS
<Alignment object (2 rows x 3 columns) at ...>
>>> 打印（对齐方式[:, (1, 3, 0)]）
目标 0 ACG 3
                  0 --| 3个
查询 0 --G 1
<空白>
```

###### 导出路线

使用该`format`方法以各种文件格式创建对齐的字符串表示形式。`fmt`此方法采用指定文件格式的参数，并且可能采用其他关键字参数，具体取决于文件类型。`fmt`支持以下值：

- `""`（空字符串；默认）：创建对齐的人类可读表示（与`print`对齐时相同）。

- ```
  "SAM"
  ```

  : 创建一条代表序列比对/地图 (SAM) 格式比对的线：

  ```
  >>> alignment.format("山姆")
  '查询\t0\ttarget\t1\t255\t1M1D1M1D1M\t*\t0\t0\tGAT\t*\tAS:i:3\n'
  ```

- ```
  "BED"
  ```

  ：创建一条线，代表浏览器可扩展数据 (BED) 文件格式中的比对：

  ```
  >>> alignment.format("床")
  '目标\t0\t5\tquery\t3.0\t+\t0\t5\t0\t3\t1,1,1,\t0,2,4,\n'
  ```

- ```
  "PSL"
  ```

  

  ：创建一条线，表示 BLAT [ 29

   ]生成的模式空间布局 (PSL) 文件格式中的对齐方式。

  ```
  >>> alignment.format("psl")
  '3\t0\t0\t0\t0\t0\t2\t2\t+\tquery\t3\t0\t3\ttarget\t5\t0\t5\t3\t1,1,1,\t0,1,2, \t0,2,4,\n'
  ```

  PSL 输出中的前四列包含匹配和不匹配字符的数量、重复区域的匹配数量以及未知核苷酸的匹配数量。目标序列中的重复区域通过将序列屏蔽为小写或大写字符来指示，如关键字参数的以下值所定义

  ```
  mask
  ```

  ：

  - `False`（默认）：不单独计算与屏蔽序列的匹配；
  - `"lower"`：计算并报告小写字符的匹配作为重复区域的匹配；
  - `"upper"`：计算并报告大写字符的匹配作为重复区域的匹配；

  用于未知核苷酸的字符由参数定义

  ```
  wildcard
  ```

  。

  ```
  "N"
  ```

  为了与 BLAT 保持一致，默认使用通配符。

  ```
  wildcard=None
  ```

  如果您不想单独计算与任何未知核苷酸的匹配，请使用。

  ```
  >>> 从 Bio 导入 Align
  >>> 对齐器 = Align.PairwiseAligner()
  >>> aligner.mismatch_score = -1
  >>> aligner.internal_gap_score = -5
  >>> aligner.wildcard = "N"
  >>> 目标 = "AAAAAAAggggGGNGAAAAAA"
  >>> 查询 = "GGTGGGGG"
  >>> alignments = aligner.align(target.upper(), 查询)
  >>> 打印（len（对齐方式））
  1个
  >>>对齐=对齐[0]
  >>> 打印（对齐）
  目标 0 AAAAAAAGGGGGGNGAAAAAA 20
                    0 ------||.|||.|----- 20
  查询 0 ------GGTGGGGG----- 8
  <空白>
  >>> alignment.score
  5.0
  >>> alignment.target
  'AAAAAAAGGGGGGNGAAAAAA'
  >>> alignment.target = 目标
  >>> alignment.target
  'AAAAAAAAggggGGNGAAAAAA'
  >>> 打印（对齐）
  目标 0 AAAAAAAggggGGNGAAAAAA 20
                    0 ------..||.|----- 20
  查询 0 ------GGTGGGGG----- 8
  <空白>
  >>> print(alignment.format("psl")) ## 文档测试：+NORMALIZE_WHITESPACE
  6 1 0 1 0 0 0 0 + 查询 8 0 8 目标 20 7 15 1 8, 0, 7,
  >>> print(alignment.format("psl", mask="lower")) ## 文档测试：+NORMALIZE_WHITESPACE
  3 1 3 1 0 0 0 0 + 查询 8 0 8 目标 20 7 15 1 8, 0, 7,
  >>> 打印(
  ... alignment.format("psl", mask="lower", wildcard=None)
  ... ) ## doctest: +NORMALIZE_WHITESPACE
  3 2 3 0 0 0 0 0 + 查询 8 0 8 目标 20 7 15 1 8, 0, 7,
  ```

除了该`format`方法，您还可以使用 Python 的内置`format`函数：

```
>>> print(format(alignment, "psl")) ## 文档测试：+NORMALIZE_WHITESPACE
6 1 0 1 0 0 0 0 + 查询 8 0 8 目标 20 7 15 1 8, 0, 7,
```

允许`Alignment`在 Python 中的格式化 (f-) 字符串中使用对象：

```
>>> 打印(
... f“PSL 格式的对齐方式是‘{alignment:psl}’。”
... ) ## doctest: +NORMALIZE_WHITESPACE
PSL格式的对齐是'6 1 0 1 0 0 0 0 + query 8 0 8 target 20 7 15 1 8, 0, 7,
'
```

请注意，可选关键字参数不能与函数或格式化字符串一起使用`format`。

### 6.6.9 与反向链比对



默认情况下，成对对齐器将查询的正向链与目标的正向链对齐。`query`要计算与的反向链的比对分数`target`，请使用`strand="-"`：

```
>>> 从 Bio 导入 Align
>>> 从 Bio.Seq 导入 reverse_complement
>>> 目标 = "AAAACCC"
>>>查询=“AACC”
>>> 对齐器 = Align.PairwiseAligner()
>>> aligner.mismatch_score = -1
>>> aligner.internal_gap_score = -1
>>> aligner.score(target, query) ## 链默认为“+”
4.0
>>> aligner.score(target, reverse_complement(query), strand="-")
4.0
>>> aligner.score（目标，查询，链=“-”）
0.0
>>> aligner.score(target, reverse_complement(query))
0.0
```

`strand="-"`可以通过在调用时指定来获得针对反向链的比对`aligner.align`：

```
>>> alignments = aligner.align(目标, 查询)
>>> len（对齐方式）
1个
>>> 打印（对齐[0]）
目标 0 AAAACCC 7
                  0 --||||- 7
查询 0 --AACC- 4
<空白>
>>> print(alignments[0].format("bed")) ## 文档测试：+NORMALIZE_WHITESPACE
目标 2 6 查询 4.0 + 2 6 0 1 4, 0,
<空白>
>>> alignments = aligner.align(目标, reverse_complement(query), strand="-")
>>> len（对齐方式）
1个
>>> 打印（对齐[0]）
目标 0 AAAACCC 7
                  0 --||||- 7
查询 4 --AACC- 0
<空白>
>>> print(alignments[0].format("bed")) ## 文档测试：+NORMALIZE_WHITESPACE
目标 2 6 查询 4.0 - 2 6 0 1 4, 0,
<空白>
>>> alignments = aligner.align(目标, 查询, strand="-")
>>> len（对齐方式）
2个
>>> 打印（对齐[0]）
目标 0 AAAACCC---- 7
                  0 ---------- 11
查询 4 ------GGTT 0
<空白>
>>> 打印（对齐[1]）
目标 0 ----AAAACCC 7
                  0 ---------- 11
查询 4 GGTT------ 0
<空白>
```

`query`请注意，如果左右间隙分数`target`不同，则与反向链对齐的分数可能与将反向互补链`query`与`target`正向链对齐的分数不同：

```
>>> aligner.left_gap_score = -0.5
>>> aligner.right_gap_score = -0.2
>>> aligner.score（目标，查询）
2.8
>>> alignments = aligner.align(目标, 查询)
>>> len（对齐方式）
1个
>>> 打印（对齐[0]）
目标 0 AAAACCC 7
                  0 --||||- 7
查询 0 --AACC- 4
<空白>
>>> aligner.score(target, reverse_complement(query), strand="-")
3.1
>>> alignments = aligner.align(目标, reverse_complement(query), strand="-")
>>> len（对齐方式）
1个
>>> 打印（对齐[0]）
目标 0 AAAACCC 7
                  0 --||||- 7
查询 4 --AACC- 0
<空白>
```

### 6.6.10 例子



假设您想在存储在alpha.faa和beta.faa中的相同的两个血红蛋白序列（ HBA_HUMAN、HBB_HUMAN ）之间进行全局成对比对：

```
>>> 从 Bio 导入 Align
>>> 从 Bio 导入 SeqIO
>>> seq1 = SeqIO.read("alpha.faa", "fasta")
>>> seq2 = SeqIO.read("beta.faa", "fasta")
>>> 对齐器 = Align.PairwiseAligner()
>>> score = aligner.score(seq1.seq, seq2.seq)
>>> 打印（分数）
72.0
```

显示对齐分数为 72.0。要查看各个对齐方式，请执行

```
>>> 比对 = aligner.align(seq1.seq, seq2.seq)
```

在这个例子中，最优对齐的总数是巨大的（超过 4 × 10 37），并且调用`len(alignments)`将引发`OverflowError`：

```
>>> len（对齐方式）
追溯（最近一次通话）：
...
OverflowError：最佳比对数大于 9223372036854775807
```

让我们看一下第一个对齐方式：

```
>>>对齐=对齐[0]
```

对齐对象存储对齐分数，以及对齐本身：

```
>>> 打印（对齐。分数）
72.0
>>> 打印（对齐）
目标 0 MV-LS-PAD--KTN--VK-AA-WGKV-----GAHAGEYGAEALE-RMFLSF----P-TTK
                  0 ||-|--|----|----|--|--||||-----|---||--|--|--|--| ------|-|--
查询 0 MVHL-TP--EEK--SAV-TA-LWGKVNVDEVG---GE--A--L-GR--L--LVVYPWT--
<空白>
目标 41 TY--FPHF----DLSHGS---AQVK-G------HGKKV--A--DA-LTNAVAHV-DDMPN
                 60 ----|--|----|||------|-|--|------|||||--|--|--|-- |--|--|---|
查询 39 --QRF--FESFGDLS---TPDA-V-MGNPKVKAHGKKVLGAFSD-GL--A--H-LD---N
<空白>
目标 79 ALS----A-LSD-LHAH--KLR-VDPV-NFK-LLSHC---LLVT--LAAHLPA----EFT
                120 -|-----|-||--||----||--|||--||--||------|-|---||- |--------|||
查询 81 -L-KGTFATLS-ELH--CDKL-HVDP-ENF-RLL---GNVL-V-CVLA-H---HFGKEFT
<空白>
目标 119 PA-VH-ASLDKFLAS---VSTV------LTS--KYR- 142
                180 |--|--|------|----|--|------|----||-- 217
查询 124 P-PV-QA------A-YQKV--VAGVANAL--AHKY-H 147
<空白>
```

更好的对齐通常通过惩罚间隙来获得：打开间隙的成本更高，扩展现有间隙的成本更低。对于氨基酸序列，匹配分数通常编码在PAM或BLOSUM等矩阵中。因此，通过使用 BLOSUM62 矩阵以及 10 的空位开放惩罚和 0.5 的空位扩展惩罚，可以获得对我们的示例更有意义的比对：

```
>>> 从 Bio 导入 Align
>>> 从 Bio 导入 SeqIO
>>> 从 Bio.Align 导入替代矩阵
>>> seq1 = SeqIO.read("alpha.faa", "fasta")
>>> seq2 = SeqIO.read("beta.faa", "fasta")
>>> 对齐器 = Align.PairwiseAligner()
>>> aligner.open_gap_score = -10
>>> aligner.extend_gap_score = -0.5
>>> aligner.substitution_matrix = substitution_matrices.load("BLOSUM62")
>>> score = aligner.score(seq1.seq, seq2.seq)
>>> 打印（分数）
292.5
>>> 比对 = aligner.align(seq1.seq, seq2.seq)
>>> len（对齐方式）
2个
>>> 打印（比对[0].分数）
292.5
>>> 打印（对齐[0]）
目标 0 MV-LSPADKTNVKAAWGKVGAHAGEYGAEALERMFLSFPTTKTYFPHF-DLS-----HGS
                  0 ||-|.|..|..|.|.||||--...|.|.|||.|......|.|...|..|- |||-----.|。
查询 0 MVHLTPEEKSAVTALWGKV--NVDEVGGEALGRLLVVYPWTQRFFESFGDLSTPDAVMGN
<空白>
目标 53 AQVKGHGKKVADALTNAVAHVDDMPNALSALSDLHAHKLRVDPVNFKLLSHCLLVTLAAH
                 60 ..||.|||||..|.....||.|..|||.||..||.|||.||.|| ...|...||.|
查询 58 PKVKAHGKKVLGAFSDGLAHLDNLKGTFATLSELHCDKLHVDPENFRLLGNVLVCVLAHH
<空白>
目标 113 LPAEFTPAVHASLDKFLASVSTVLTSKYR 142
                120 ...||||.|.|...|..|.|...|..||。149
查询 118 FGKEFTPPVQAAYQKVVAGVANALAHKYH 147
<空白>
```

该比对与我们之前使用相同序列和相同参数使用 EMBOSS 针获得的分数相同。

要执行局部对齐，请设置`aligner.mode`为`'local'`：

```
>>> aligner.mode = "本地"
>>> aligner.open_gap_score = -10
>>> aligner.extend_gap_score = -1
>>> alignments = aligner.align("LSPADKTNVKAA", "PEEKSAV")
>>> 打印（len（对齐方式））
1个
>>>对齐=对齐[0]
>>> 打印（对齐）
目标 2 PADKTNV 9
                  0 |..|..| 7
查询 0 PEEKSAV 7
<空白>
>>> 打印（对齐。分数）
16.0
```

### 6.6.11 广义成对比对



在大多数情况下，`PairwiseAligner`用于执行`Seq`由单字母核苷酸或氨基酸组成的序列（字符串或对象）的比对。更一般地，`PairwiseAligner`也可以应用于任意对象的列表或元组。本节将描述此类广义成对比对的一些示例。

###### 使用替换矩阵和字母表的广义成对比对

施耐德*等人。*[ [36](https://biopython-org.translate.goog/DIST/docs/tutorial/Tutorial.html?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN&_x_tr_pto=wapp&_x_tr_sch=http#schneider2005) ] 创建了一个用于对齐三核苷酸密码子的替换矩阵（有关更多信息，请参见[下面的第](https://biopython-org.translate.goog/DIST/docs/tutorial/Tutorial.html?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN&_x_tr_pto=wapp&_x_tr_sch=http#codonmatrix)[6.7](https://biopython-org.translate.goog/DIST/docs/tutorial/Tutorial.html?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN&_x_tr_pto=wapp&_x_tr_sch=http#sec%3Asubstitution_matrices)节）。该替换矩阵与由所有三字母密码子组成的字母表相关联：

```
>>> 从 Bio.Align 导入替代矩阵
>>> m = substitution_matrices.load("SCHNEIDER")
>>> m.alphabet #doctest: +ELLIPSIS
('AAA', 'AAC', 'AAG', 'AAT', 'ACA', 'ACC', 'ACG', 'ACT', ..., 'TTG', 'TTT')
```

我们可以使用此矩阵将密码子序列彼此对齐：

```
>>> 从 Bio 导入 Align
>>> 对齐器 = Align.PairwiseAligner()
>>> aligner.substitution_matrix = m
>>> aligner.gap_score = -1.0
>>> s1 = ("AAT", "CTG", "TTT", "TTT")
>>> s2 = ("AAT", "TTA", "TTT")
>>> 对齐方式 = aligner.align(s1, s2)
>>> len（对齐方式）
2个
>>> 打印（对齐[0]）
AAT CTG TTT TTT
||| ... ||| ---
AAT TTA TTT ---
<空白>
>>> 打印（对齐[1]）
AAT CTG TTT TTT
||| ... --- |||
AAT TTA --- TTT
<空白>
```

请注意对齐`TTT`到`TTA`，如本例所示：

```
AAT CTG TTT TTT
||| --- ... |||
AAT---TTA TTT
```

会得到低得多的分数：

```
>>> 打印(m["CTG", "TTA"])
7.6
>>> 打印(m["TTT", "TTA"])
-0.3
```

大概是因为`CTG`和`TTA`都编码亮氨酸，而`TTT`编码苯丙氨酸。三字母密码子替换矩阵还揭示了代表相同氨基酸的密码子之间的偏好。例如，与preferred 相比`TTA`有偏好，尽管所有三个代码都是亮氨酸：`CTG``CTC`

```
>>> s1 = ("AAT", "CTG", "CTC", "TTT")
>>> s2 = ("AAT", "TTA", "TTT")
>>> 对齐方式 = aligner.align(s1, s2)
>>> len（对齐方式）
1个
>>> 打印（对齐[0]）
AAT CTG CTC TTT
||| ... --- |||
AAT TTA --- TTT
<空白>
>>> 打印（m[“CTC”，“TTA”]）
6.5
```

###### 使用匹配/不匹配分数和字母表的广义成对比对

使用三个字母的氨基酸符号，上面的序列转换为

```
>>> s1 = ("Asn", "Leu", "Leu", "Phe")
>>> s2 = ("Asn", "Leu", "Phe")
```

我们可以使用三个字母的氨基酸字母表将这些序列直接相互对齐：

```
>>> 从 Bio 导入 Align
>>> 对齐器 = Align.PairwiseAligner()
>>> aligner.alphabet = ['Ala', 'Arg', 'Asn', 'Asp', 'Cys',
... 'Gln', 'Glu', 'Gly', 'His', 'Ile',
... 'Leu', 'Lys', 'Met', 'Phe', 'Pro',
... 'Ser', 'Thr', 'Trp', 'Tyr', 'Val'] ## fmt: skip
...
```

我们使用 +6/-1 匹配和不匹配分数作为 BLOSUM62 矩阵的近似值，并将这些序列相互对齐：

```
>>> aligner.match = +6
>>> aligner.mismatch = -1
>>> 对齐方式 = aligner.align(s1, s2)
>>> 打印（len（对齐方式））
2个
>>> 打印（对齐[0]）
Asn Leu Leu Phe
||| ||| --- |||
Asn Leu --- Phe
<空白>
>>> 打印（对齐[1]）
Asn Leu Leu Phe
||| --- ||| |||
Asn --- 亮氨酸
<空白>
>>> 打印（对齐方式。分数）
18.0
```

###### 使用匹配/不匹配分数和整数序列的广义成对比对

在内部，执行比对的第一步是用整数数组替换两个序列，整数数组由与比对器关联的字母表中每个序列中每个字母的索引组成。可以通过直接传递整数数组来绕过这一步：

```
>>> 导入 numpy
>>> 从 Bio 导入 Align
>>> 对齐器 = Align.PairwiseAligner()
>>> s1 = numpy.array([2, 10, 10, 13], numpy.int32)
>>> s2 = numpy.array([2, 10, 13], numpy.int32)
>>> aligner.match = +6
>>> aligner.mismatch = -1
>>> 对齐方式 = aligner.align(s1, s2)
>>> 打印（len（对齐方式））
2个
>>> 打印（对齐[0]）
2 10 10 13
| || -- ||
2 10 -- 13
<空白>
>>> 打印（对齐[1]）
2 10 10 13
| -- || ||
2 -- 10 13
<空白>
>>> 打印（对齐方式。分数）
18.0
```

请注意，索引应由 32 位整数组成，如本例中指定的那样`numpy.int32`。

通过定义通配符并使用相应的 Unicode 代码点编号作为索引，可以再次包含未知字母：

```
>>> aligner.wildcard = "?"
>>> ord(aligner.wildcard)
63
>>> s2 = numpy.array([2, 63, 13], numpy.int32)
>>> aligner.gap_score = -3
>>> 对齐方式 = aligner.align(s1, s2)
>>> 打印（len（对齐方式））
2个
>>> 打印（对齐[0]）
2 10 10 13
| .. -- ||
2 63 -- 13
<空白>
>>> 打印（对齐[1]）
2 10 10 13
| -- .. ||
2 -- 63 13
<空白>
>>> 打印（对齐方式。分数）
9.0
```

###### 使用替换矩阵和整数序列的广义成对比对

整数序列也可以使用替换矩阵进行对齐，在本例中是一个没有与之关联的字母表的 numpy 方形数组。在这种情况下，所有索引值都必须是非负的，并且小于替换矩阵的大小：

```
>>> 从 Bio 导入 Align
>>> 导入 numpy
>>> 对齐器 = Align.PairwiseAligner()
>>> m = numpy.eye(5)
>>> m[0, 1:] = m[1:, 0] = -2
>>> 米 [2, 2] = 3
>>> 打印（米）
[[ 1.-2. -2。-2。-2.]
 [-2。1. 0. 0. 0.]
 [-2。0. 3. 0. 0.]
 [-2。0. 0. 1. 0.]
 [-2。0. 0. 0. 1.]]
>>> aligner.substitution_matrix = m
>>> aligner.gap_score = -1
>>> s1 = numpy.array([0, 2, 3, 4], numpy.int32)
>>> s2 = numpy.array([0, 3, 2, 1], numpy.int32)
>>> 对齐方式 = aligner.align(s1, s2)
>>> 打印（len（对齐方式））
2个
>>> 打印（对齐[0]）
0 - 2 3 4
| - | . -
0 3 2 1 -
<空白>
>>> 打印（对齐[1]）
0 - 2 3 4
| - | - 。
0 3 2 - 1
<空白>
>>> 打印（对齐方式。分数）
2.0
```

## 6.7 替换矩阵



`Array`中的类是`Bio.Align.substitution_matrices`numpy 数组的子类，支持按整数和特定字符串进行索引。实例`Array`可以是一维数组或方形二维数组。例如，一维`Array`对象可用于存储 DNA 序列的核苷酸频率，而二维对象`Array`可用于表示序列比对的评分矩阵。

### 6.7.1 创建数组对象

要创建一维`Array`，只需指定允许字母的字母表：

```
>>> 从 Bio.Align.substitution_matrices 导入数组
>>> 计数 = 数组（“ACGT”）
>>> 打印（计数）
一个 0.0
C 0.0
克0.0
0.0
<空白>
```

允许的字母存储在`alphabet`属性中：

```
>>> 计数.alphabet
'ACGT'
```

该属性是只读的；修改底层`_alphabet`属性可能会导致意外结果。可以通过字母和整数索引访问元素：

```
>>> 计数[“C”] = -3
>>> 计数[2] = 7
>>> 打印（计数）
一个 0.0
C -3.0
7.0
0.0
<空白>
>>> 计数[1]
-3.0
```

使用不在字母表中的字母或超出范围的索引将导致`IndexError`：

```
>>> 计数[“U”]
追溯（最近一次通话）：
    ...
索引错误：'U'
>>> 计数["X"] = 6
追溯（最近一次通话）：
    ...
索引错误：'X'
>>> 计数[7]
追溯（最近一次通话）：
    ...
IndexError：索引 7 超出尺寸为 4 的轴 0 的范围
```

`Array`可以通过指定创建二维`dims=2`：

```
>>> 从 Bio.Align.substitution_matrices 导入数组
>>> counts = Array("ACGT", 暗淡=2)
>>> 打印（计数）
    ACGT
一个 0.0 0.0 0.0 0.0
C 0.0 0.0 0.0 0.0
G 0.0 0.0 0.0 0.0
T 0.0 0.0 0.0 0.0
<空白>
```

同样，字母和整数都可用于索引，指定不在字母表中的字母将导致`IndexError`：

```
>>> 计数["A", "C"] = 12.0
>>> 计数[2, 1] = 5.0
>>> 计数[3, "T"] = -2
>>> 打印（计数）
    ACGT
一个 0.0 12.0 0.0 0.0
C 0.0 0.0 0.0 0.0
G 0.0 5.0 0.0 0.0
T 0.0 0.0 0.0 -2.0
<空白>
>>> 计数["X", 1]
追溯（最近一次通话）：
    ...
索引错误：'X'
>>> 计数["A", 5]
追溯（最近一次通话）：
    ...
IndexError：索引 5 超出了大小为 4 的轴 1 的范围
```

从二维数组中选择一行或一列将返回一个一维的`Array`：

```
>>> counts = Array("ACGT", 暗淡=2)
>>> 计数["A", "C"] = 12.0
>>> 计数[2, 1] = 5.0
>>> 计数[3, "T"] = -2
>>> 计数["G"]
数组([0., 5., 0., 0.],
      字母表='ACGT')
>>> 计数[:, "C"]
数组([12., 0., 5., 0.],
      字母表='ACGT')
```

`Array`因此，对象可以用作数组和字典。它们可以转换为普通的 numpy 数组或普通的字典对象：

```
>>> 导入 numpy
>>> x = 数组("ACGT")
>>> x["C"] = 5
>>> x
数组([0., 5., 0., 0.],
      字母表='ACGT')
>>> a = numpy.array(x) ## 创建一个普通的 numpy 数组
>>> 一个
阵列（[0.，5.，0.，0.]）
>>> d = dict(x) ## 创建一个普通字典
>>> 天
{'A': 0.0, 'C': 5.0, 'G': 0.0, 'T': 0.0}
```

虽然 an 的字母表`Array`通常是字符串，但您也可以使用（不可变）对象的元组。这用于例如[密码子替换矩阵](https://biopython-org.translate.goog/DIST/docs/tutorial/Tutorial.html?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN&_x_tr_pto=wapp&_x_tr_sch=http#codonmatrix)，其中键不是单个核苷酸或氨基酸，而是三核苷酸密码子。

虽然`alphabet`an 的属性是不可变的，但您可以通过从字母表中选择您感兴趣的字母来`Array`创建一个新对象。`Array`例如，

```
>>> a = Array("ABCD", dims=2, data=numpy.arange(16).reshape(4, 4))
>>> 打印（一）
     A B C D
一个 0.0 1.0 2.0 3.0
B 4.0 5.0 6.0 7.0
C 8.0 9.0 10.0 11.0
D 12.0 13.0 14.0 15.0
<空白>
>>> b = a.select("CAD")
>>> 打印(b)
     计算机辅助设计
C 10.0 8.0 11.0
一个 2.0 0.0 3.0
D 14.0 12.0 15.0
<空白>
```

请注意，这还允许您重新排序字母表。

在字母表中找不到的字母数据设置为零：

```
>>> c = a.select("十二月")
>>> 打印(c)
     十二月公司
D 15.0 0.0 14.0
E 0.0 0.0 0.0
C 11.0 0.0 10.0
<空白>
```

### 6.7.2 从成对序列比对计算替换矩阵

作为`Array`numpy 数组的子类，您可以`Array`以几乎相同的方式对对象应用数学运算。*在这里，我们通过根据大肠杆菌*和*枯草芽孢杆菌*的 16S 核糖体 RNA 基因序列的比对计算得分矩阵来说明这一点。首先，我们创建一个`PairwiseAligner`并使用 所使用的默认分数对其进行初始化`blastn`：

```
>>> 从 Bio.Align 导入 PairwiseAligner
>>> 对齐器 = PairwiseAligner()
>>> aligner.mode = "本地"
>>> aligner.match_score = 2
>>> aligner.mismatch_score = -3
>>> aligner.open_gap_score = -7
>>> aligner.extend_gap_score = -2
```

接下来，我们读入*大肠杆菌*和*枯草芽孢杆菌*的 16S 核糖体 RNA 基因序列（在`Tests/scoring_matrices/ecoli.fa`和中提供`Tests/scoring_matrices/bsubtilis.fa`），并将它们相互比对：

```
>>> 从 Bio 导入 SeqIO
>>> sequence1 = SeqIO.read("ecoli.fa", "fasta")
>>> sequence2 = SeqIO.read("bsubtilis.fa", "fasta")
>>> 比对 = aligner.align(sequence1.seq, sequence2.seq)
```

生成的对齐数量非常大：

```
>>> len（对齐方式）
1990656
```

然而，由于它们彼此之间的差异很小，我们任意选择第一个比对，并计算每个替换的数量：

```
>>>对齐=对齐[0]
>>> 从 Bio.Align.substitution_matrices 导入数组
>>> 频率 = Array("ACGT", dims=2)
>>> 用于 zip(*alignment.aligned) 中的 (start1, end1), (start2, end2)：
... seq1 = sequence1[start1:end1]
... seq2 = sequence2[start2:end2]
...对于 zip 中的 c1、c2（seq1、seq2）：
... 频率 [c1, c2] += 1
...
>>> 打印（频率）
      ACGT
一个 307.0 19.0 34.0 19.0
C 15.0 280.0 25.0 29.0
克 34.0 24.0 401.0 20.0
吨 24.0 36.0 20.0 228.0
<空白>
```

我们对总数进行归一化以找到每个替换的概率，并创建一个对称矩阵：

```
>>> 导入 numpy
>>> 概率 = 频率 / numpy.sum(频率)
>>> 概率 = (概率 + probabilities.transpose()) / 2.0
>>> 打印（概率。格式（“%.4f”））
       ACGT
0.2026 0.0112 0.0224 0.0142
C 0.0112 0.1848 0.0162 0.0215
G 0.0224 0.0162 0.2647 0.0132
T 0.0142 0.0215 0.0132 0.1505
<空白>
```

背景概率是分别在每个序列中找到 A、C、G 或 T 核苷酸的概率。这可以计算为每行或每列的总和：

```
>>> 背景 = numpy.sum(概率, 0)
>>> 打印（背景格式（“%.4f”））
0.2505
C 0.2337
G 0.3165
T 0.1993
<空白>
```

随机预期的替换次数只是背景分布与其自身的乘积：

```
>>> expected = numpy.dot(背景[:, 无], 背景[无, :])
>>> 打印（预期格式（“%.4f”））
       ACGT
0.0627 0.0585 0.0793 0.0499
C 0.0585 0.0546 0.0740 0.0466
G 0.0793 0.0740 0.1002 0.0631
T 0.0499 0.0466 0.0631 0.0397
<空白>
```

然后可以将评分矩阵计算为观察到的概率和预期概率的优势比的对数：

```
>>> 赔率 = 概率 / 预期
>>> scoring_matrix = numpy.log2(oddsratios)
>>> 打印（评分矩阵）
     ACGT
1.7 -2.4 -1.8 -1.8
C -2.4 1.8 -2.2 -1.1
G -1.8 -2.2 1.4 -2.3
T -1.8 -1.1 -2.3 1.9
<空白>
```

该矩阵可用于设置成对对齐器的替换矩阵：

```
>>> aligner.substitution_matrix = scoring_matrix
```

如果出现在数学运算中的对象具有不同的字母表，`ValueError`则触发A ：`Array`

```
>>> 从 Bio.Align.substitution_matrices 导入数组
>>> d = 数组("ACGT")
>>> r = Array("ACGU")
>>> d + r
追溯（最近一次通话）：
    ...
ValueError：字母表不一致
```

### 6.7.3 从文件中读取数组对象

`Bio.Align.substitution_matrices`包括一个解析器，用于从文件中读取一维和二维`Array`对象。一维数组由简单的双列格式表示，第一列包含键，第二列包含相应的值。例如，该文件`hg38.chrom.sizes`（从 UCSC 获得）位于`Tests/Align`Biopython 分布的子目录中，包含人类基因组装配 hg38 中每条染色体的核苷酸大小：

```
chr1 248956422
CHR2 242193529
CHR3 198295559
chr4 190214555
...
chrUn_KI270385v1 990
chrUn_KI270423v1 981
chrUn_KI270392v1 971
chrUn_KI270394v1 970
```

要解析此文件，请使用

```
>>> 从 Bio.Align 导入替代矩阵
>>> 以 open("hg38.chrom.sizes") 作为句柄：
... 表 = substitution_matrices.read（句柄）
...
>>> print(table) ## 文档测试：+ELLIPSIS
chr1 248956422.0
chr2 242193529.0
chr3 198295559.0
chr4 190214555.0
...
chrUn_KI270423v1 981.0
chrUn_KI270392v1 971.0
chrUn_KI270394v1 970.0
<空白>
```

用于`dtype=int`将值读取为整数：

```
>>> 以 open("hg38.chrom.sizes") 作为句柄：
... table = substitution_matrices.read(handle, int)
...
>>> print(table) ## 文档测试：+ELLIPSIS
chr1 248956422
CHR2 242193529
CHR3 198295559
chr4 190214555
...
chrUn_KI270423v1 981
chrUn_KI270392v1 971
chrUn_KI270394v1 970
<空白>
```

对于二维数组，我们遵循 NCBI 提供的替换矩阵文件格式。例如，NCBI 的蛋白质-蛋白质 BLAST [ [26](https://biopython-org.translate.goog/DIST/docs/tutorial/Tutorial.html?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN&_x_tr_pto=wapp&_x_tr_sch=http#altschul1990) ] 程序的默认替换矩阵 BLOSUM62 矩阵`blastp`存储如下：

```
## matblas 从 blosum62.iij 制作的矩阵
## * 列使用最低分数
## 以 1/2 位为单位的 BLOSUM 聚类评分矩阵
## 区块数据库 = /data/blocks_5.0/blocks.dat
## 集群百分比：>= 62
## 熵 = 0.6979，预期 = -0.5209
   ARNDCQEGHILKMFPSTWYVB ZX *
A 4 -1 -2 -2 0 -1 -1 0 -2 -1 -1 -1 -1 -2 -1 1 0 -3 -2 0 -2 -1 0 -4
R -1 5 0 -2 -3 1 0 -2 0 -3 -2 2 -1 -3 -2 -1 -1 -3 -2 -3 -1 0 -1 -4
N -2 0 6 1 -3 0 0 0 1 -3 -3 0 -2 -3 -2 1 0 -4 -2 -3 3 0 -1 -4
D -2 -2 1 6 -3 0 2 -1 -1 -3 -4 -1 -3 -3 -1 0 -1 -4 -3 -3 4 1 -1 -4
C 0 -3 -3 -3 9 -3 -4 -3 -3 -1 -1 -3 -1 -2 -3 -1 -1 -2 -2 -1 -3 -3 -2 -4
Q -1 1 0 0 -3 5 2 -2 0 -3 -2 1 0 -3 -1 0 -1 -2 -1 -2 0 3 -1 -4
E -1 0 0 2 -4 2 5 -2 0 -3 -3 1 -2 -3 -1 0 -1 -3 -2 -2 1 4 -1 -4
G 0 -2 0 -1 -3 -2 -2 6 -2 -4 -4 -2 -3 -3 -2 0 -2 -2 -3 -3 -1 -2 -1 -4
H -2 0 1 -1 -3 0 0 -2 8 -3 -3 -1 -2 -1 -2 -1 -2 -2 2 -3 0 0 -1 -4
...
```

该文件包含在 Biopython 发行版中的`Bio/Align/substitution_matrices/data`. 要解析此文件，请使用

```
>>> 从 Bio.Align 导入替代矩阵
>>> 以 open("BLOSUM62") 作为句柄：
... 矩阵 = substitution_matrices.read（句柄）
...
>>> 打印（矩阵字母表）
ARNDCQEGHILKMFPSTWYVBZX*
>>> 打印（矩阵[“A”，“D”]）
-2.0
```

开头的标题行`#`存储在属性中`header`：

```
>>> 矩阵.header[0]
'由来自 blosum62.iij 的 matblas 制作的矩阵'
```

我们现在可以使用这个矩阵作为对齐器对象的替换矩阵：

```
>>> 从 Bio.Align 导入 PairwiseAligner
>>> 对齐器 = PairwiseAligner()
>>> aligner.substitution_matrix = 矩阵
```

要保存 Array 对象，请先创建一个字符串：

```
>>> 文本 = 海峡（矩阵）
>>> print(text) ## 文档测试：+ELLIPSIS
## matblas 从 blosum62.iij 制作的矩阵
## * 列使用最低分数
## 以 1/2 位为单位的 BLOSUM 聚类评分矩阵
## 区块数据库 = /data/blocks_5.0/blocks.dat
## 集群百分比：>= 62
## 熵 = 0.6979，预期 = -0.5209
     ARNDCQEGHILKMFPS ...
4.0 -1.0 -2.0 -2.0 0.0 -1.0 -1.0 0.0 -2.0 -1.0 -1.0 -1.0 -1.0 -2.0 -1.0 1.0 ...
R -1.0 5.0 0.0 -2.0 -3.0 1.0 0.0 -2.0 0.0 -3.0 -2.0 2.0 -1.0 -3.0 -2.0 -1.0 ...
N -2.0 0.0 6.0 1.0 -3.0 0.0 0.0 0.0 1.0 -3.0 -3.0 0.0 -2.0 -3.0 -2.0 1.0 ...
D -2.0 -2.0 1.0 6.0 -3.0 0.0 2.0 -1.0 -1.0 -3.0 -4.0 -1.0 -3.0 -3.0 -1.0 0.0 ...
C 0.0 -3.0 -3.0 -3.0 9.0 -3.0 -4.0 -3.0 -3.0 -1.0 -1.0 -3.0 -1.0 -2.0 -3.0 -1.0 ...
...
```

并将其写入`text`文件。

### 6.7.4 加载预定义的替换矩阵

Biopython 包含大量文献中定义的替换矩阵，包括 BLOSUM（块替换矩阵）[ [24](https://biopython-org.translate.goog/DIST/docs/tutorial/Tutorial.html?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN&_x_tr_pto=wapp&_x_tr_sch=http#henikoff1992) ] 和 PAM（点接受突变）矩阵 [ [14](https://biopython-org.translate.goog/DIST/docs/tutorial/Tutorial.html?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN&_x_tr_pto=wapp&_x_tr_sch=http#dayhoff1978) ]。这些矩阵在目录中作为平面文件提供，并且可以使用子模块中的函数`Bio/Align/scoring_matrices/data`加载到 Python 中。例如，可以通过运行来加载 BLOSUM62 矩阵`load``scoring_matrices`

```
>>> 从 Bio.Align 导入替代矩阵
>>> m = substitution_matrices.load("BLOSUM62")
```

这个替换矩阵有一个字母表，由遗传密码中使用的 20 个氨基酸、三个不明确的氨基酸 B（天冬酰胺或天冬氨酸）、Z（谷氨酰胺或谷氨酸）和 X（代表任何氨基酸）和用星号表示的终止密码子：

```
>>> m.alphabet
'ARNDCQEGHILKMFPSTWYVBZX*'
```

要获得可用替换矩阵的完整列表，请`load`不带参数使用：

```
>>> substitution_matrices.load() ## doctest: +ELLIPSIS
['BENNER22', 'BENNER6', 'BENNER74', 'BLASTN', 'BLASTP', 'BLOSUM45', 'BLOSUM50', ..., 'TRANS']
```

请注意，Schneider 等人提供的替代矩阵*。*[36] 使用由三核苷酸密码子组成的字母表：

```
>>> m = substitution_matrices.load("SCHNEIDER")
>>> m.alphabet #doctest: +ELLIPSIS
('AAA', 'AAC', 'AAG', 'AAT', 'ACA', 'ACC', 'ACG', 'ACT', ..., 'TTG', 'TTT')
```

## 6.8 使用 pairwise2 进行成对比对



**请注意，Bio.pairwise2 在 1.80 版中已弃用。**作为替代方案，请考虑使用`Bio.Align.PairwiseAligner`（在[‍ 6.6](https://biopython-org.translate.goog/DIST/docs/tutorial/Tutorial.html?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN&_x_tr_pto=wapp&_x_tr_sch=http#sec%3Apairwise)）。

```
Bio.pairwise2`[包含与EMBOSS套件（见上文）中的](https://translate.google.com/website?sl=auto&tl=zh-CN&hl=zh-CN&client=webapp&u=http://emboss.sourceforge.net/)水（局部）和针（全局）基本相同的算法，并且应该返回相同的结果。该模块最近在速度和内存消耗方面进行了一些优化（Biopython 版本 >1.67），因此对于短序列（全局比对：~2000 个残基，局部比对~600 个残基）使用起来比调用 EMBOSS 更快（或同样快）水或针通过命令行工具。`pairwise2``pairwise2
```

假设您想在存储在alpha.faa和beta.faa中的相同的两个血红蛋白序列（ HBA_HUMAN、HBB_HUMAN ）之间进行全局成对比对：

```
>>> 从 Bio 导入 pairwise2
>>> 从 Bio 导入 SeqIO
>>> seq1 = SeqIO.read("alpha.faa", "fasta")
>>> seq2 = SeqIO.read("beta.faa", "fasta")
>>> 比对 = pairwise2.align.globalxx(seq1.seq, seq2.seq)
```

如您所见，我们将对齐函数称为`align.globalxx`。棘手的部分是函数名称的最后两个字母（此处为：xx），用于解码匹配（和不匹配）和间隙的分数和惩罚。第一个字母解码匹配分数，例如x表示匹配计为 1，而不匹配则没有成本。使用m可以定义匹配或不匹配的一般值（有关更多选项，请参阅[Biopython 的 API](https://biopython-org.translate.goog/docs/1.77/api/Bio.pairwise2.html?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN&_x_tr_pto=wapp&_x_tr_sch=http)）。第二个字母解码了差距的成本；x表示完全没有间隙成本，可以分配打开和扩展间隙的不同惩罚。因此，`globalxx`意味着只计算两个序列之间的匹配项。

我们的变量对齐现在包含一个对齐列表（至少一个），它们在给定条件下具有相同的最佳分数。在我们的示例中，这是 80 个不同的比对，分数为 72（`Bio.pairwise2`将返回最多 1000 个比对）。看看这些对齐方式之一：

```
>>> len（对齐方式）
80
>>> print(alignments[0]) ## doctest:+省略号
比对(seqA='MV-LSPADKTNV---KA--A-WGKVGAHAG...YR-', seqB='MVHL-----T--PEEKSAVTALWGKV----...YH', score=72.0 , 开始=0, 结束=217)
```

每个比对都是一个命名的元组，由两个比对序列、分数、比对的开始和结束位置组成（在全局比对中，开始始终为 0，结束为比对的长度）。`Bio.pairwise2`有一个更好的打印输出的功能`format_alignment`：

```
>>> print(pairwise2.format_alignment(*alignments[0])) ## doctest:+ELLIPSIS
MV-LSPADKTNV---KA--A-WGKVGAHAG---EY-GA-EALE-RMFLSF----PTTK-TY--F...YR-
|| | | | | | |||| | | ||| | | | | |...|  
MVHL-----T--PEEKSAVTALWGKV-----NVDE-VG-GEAL-GR--L--LVVYP---WT-QRF...YH
  得分=72
<空白>
```

从 Biopython 1.77 开始，所需的参数可以用关键字提供。最后一个例子现在也可以写成：

```
>>> 比对 = pairwise2.align.globalxx(sequenceA=seq1.seq, sequenceB=seq2.seq)
```

更好的对齐通常通过惩罚间隙来获得：打开间隙的成本更高，扩展现有间隙的成本更低。对于氨基酸序列，匹配分数通常编码在PAM或BLOSUM等矩阵中。`globalds`因此，通过使用 BLOSUM62 矩阵以及 10 的空位开放惩罚和 0.5 的空位扩展惩罚（使用），可以获得对我们的示例更有意义的比对：

```
>>> 从 Bio 导入 pairwise2
>>> 从 Bio 导入 SeqIO
>>> 从 Bio.Align 导入替代矩阵
>>> blosum62 = substitution_matrices.load("BLOSUM62")
>>> seq1 = SeqIO.read("alpha.faa", "fasta")
>>> seq2 = SeqIO.read("beta.faa", "fasta")
>>> alignments = pairwise2.align.globalds(seq1.seq, seq2.seq, blosum62, -10, -0.5)
>>> len（对齐方式）
2个
>>> print(pairwise2.format_alignment(*alignments[0]))
MV-LSPADKTNVKAAWGKVGAHAGEYGAEALERMFLSFPTTKTY...KYR
|| |.|..|..|.|.|||| ......|......|.......||。
MVHLTPEEKSAVTALWGKV-NVDEVGGEALGRLLVVYPWTQRFF...KYH
  分数=292.5
```

该比对与我们之前使用相同序列和相同参数使用 EMBOSS 针获得的分数相同。

局部比对的调用与函数类似`align.localXX`，其中 XX 再次代表匹配和间隙函数的两个字母代码：

```
>>> 从 Bio 导入 pairwise2
>>> 从 Bio.Align 导入替代矩阵
>>> blosum62 = substitution_matrices.load("BLOSUM62")
>>> alignments = pairwise2.align.localds("LSPADKTNVKAA", "PEEKSAV", blosum62, -10, -1)
>>> print(pairwise2.format_alignment(*alignments[0]))
3 PADKTNV
  |..|..|
1 皮克萨夫
  分数=16
<空白>
```

在最近的 Biopython 版本中，`format_alignment`将只打印局部对齐的对齐部分（连同以 1 为基础的符号的起始位置，如上例所示）。如果您也对序列的非对齐部分感兴趣，请使用关键字参数`full_sequences=True`：

```
>>> 从 Bio 导入 pairwise2
>>> 从 Bio.Align 导入替代矩阵
>>> blosum62 = substitution_matrices.load("BLOSUM62")
>>> alignments = pairwise2.align.localds("LSPADKTNVKAA", "PEEKSAV", blosum62, -10, -1)
>>> print(pairwise2.format_alignment(*alignments[0], full_sequences=True))
LSPADKTNVKAA
  |..|..|   
--皮克萨夫---
  分数=16
<空白>
```

请注意，根据 Smith & Waterman 的定义，局部比对必须具有正分数 (>0)。因此，`pairwise2`如果没有获得 >0 的分数，则可能不返回对齐。此外，`pairwise2`不会报告由于在任一站点上添加零分扩展而导致的对齐。在下一个示例中，丝氨酸/天冬氨酸 (S/D) 和赖氨酸/天冬酰胺 (K/N) 对的匹配分数均为 0。如您所见，对齐的部分尚未扩展：

```
>>> 从 Bio 导入 pairwise2
>>> 从 Bio.Align 导入替代矩阵
>>> blosum62 = substitution_matrices.load("BLOSUM62")
>>> alignments = pairwise2.align.localds("LSSPADKTNVKKAA", "DDPEEKSAVNN", blosum62, -10, -1)
>>> print(pairwise2.format_alignment(*alignments[0]))
4 PADKTNV
  |..|..|
3 皮克萨夫
  分数=16
<空白>
```

匹配代码m不是提供完整的匹配/不匹配矩阵，而是允许轻松定义一般匹配/不匹配值。下一个示例使用 5/-4 的匹配/不匹配分数和 2/0.5 的间隙惩罚（打开/扩展）使用`localms`：

```
>>> alignments = pairwise2.align.localms("AGAACT", "GAC", 5, -4, -2, -0.5)
>>> print(pairwise2.format_alignment(*alignments[0]))
2 公认会计准则
  | ||
1 克交流电
  分数=13
<空白>
```

函数的一个有用的关键字参数`Bio.pairwise2.align`是score_only。当设置为True时，它只会返回最佳比对的分数，但在更短的时间内。它还将允许在出现内存错误之前对齐更长的序列。另一个有用的关键字参数是one_alignment_only=True，它也会带来一些速度增益。

不幸的是，`Bio.pairwise2`不适用于 Biopython 的多序列比对对象（目前）。但是，该模块具有一些有趣的高级功能：您可以定义自己的匹配和间隙函数（对测试仿射对数间隙成本感兴趣？），两个序列的间隙惩罚和结束间隙惩罚可以不同，序列可以作为列表提供（如果您有由多个字符编码的残基，则很有用）等。这些功能很难（如果有的话）用其他比对工具实现。[有关详细信息，请参阅Biopython 的 API](https://biopython-org.translate.goog/docs/1.81/api/Bio.pairwise2.html?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN&_x_tr_pto=wapp&_x_tr_sch=http)中的模块文档。