Entrez ( [https://www.ncbi.nlm.nih.gov/Web/Search/entrezfs.html](https://translate.google.com/website?sl=auto&tl=zh-CN&hl=zh-CN&client=webapp&u=https://www.ncbi.nlm.nih.gov/Web/Search/entrezfs.html) ) 是一个数据检索系统，用户可以通过它访问 NCBI 的数据库，例如 PubMed、GenBank、GEO 等。您可以从 Web 浏览器访问 Entrez 以手动输入查询，或者您可以使用 Biopython 的`Bio.Entrez`模块以编程方式访问 Entrez。例如，后者允许您从 Python 脚本中搜索 PubMed 或下载 GenBank 记录。

该`Bio.Entrez`模块使用 Entrez Programming Utilities（也称为 EUtils），该实用程序由八个工具组成，在 NCBI 的页面上有详细描述，网址为[https://www.ncbi.nlm.nih.gov/books/NBK25501/](https://translate.google.com/website?sl=auto&tl=zh-CN&hl=zh-CN&client=webapp&u=https://www.ncbi.nlm.nih.gov/books/NBK25501/)。这些工具中的每一个都对应于`Bio.Entrez`模块中的一个 Python 函数，如下面的部分所述。该模块确保将正确的 URL 用于查询，并确保遵循 NCBI 负责任的数据访问指南。

Entrez Programming Utilities 返回的输出通常为 XML 格式。要解析此类输出，您有多种选择：

1. 使用`Bio.Entrez`的解析器将 XML 输出解析为 Python 对象；
2. 使用 Python 标准库中可用的 XML 解析器之一；
3. 将 XML 输出读取为原始文本，并通过字符串搜索和操作对其进行解析。

有关 Python 标准库中 XML 解析器的描述，请参阅 Python 文档。在这里，我们讨论 Biopython 模块中的解析器`Bio.Entrez`。该解析器可用于解析通过 的`Bio.Entrez`编程访问函数提供给 Entrez 的数据，但也可用于解析存储在文件中的来自 NCBI Entrez 的 XML 数据。在后一种情况下，XML 文件应该以二进制模式（例如 ）打开，`open("myfile.xml", "rb")`以便 XML 解析器`Bio.Entrez`正常工作。

NCBI 使用 DTD（文档类型定义）文件来描述 XML 文件中包含的信息结构。NCBI 使用的大多数 DTD 文件都包含在 Biopython 发行版中。解析器`Bio.Entrez`在解析 NCBI Entrez 返回的 XML 文件时使用 DTD 文件。

有时，您可能会发现与特定 XML 文件关联的 DTD 文件在 Biopython 发行版中丢失。特别是，当 NCBI 更新其 DTD 文件时，可能会发生这种情况。如果发生这种情况，`Entrez.read`将显示一条警告消息，其中包含丢失的 DTD 文件的名称和 URL。解析器将继续通过 Internet 访问丢失的 DTD 文件，从而允许继续解析 XML 文件。但是，如果 DTD 文件在本地可用，则解析器会快得多。为此，请从警告消息中的 URL 下载 DTD 文件并将其放置在`...site-packages/Bio/Entrez/DTDs`包含其他 DTD 文件的目录中。如果您对该目录没有写权限，您也可以将 DTD 文件放在 中`~/.biopython/Bio/Entrez/DTDs`，其中`~`代表您的主目录。由于此目录在目录之前被读取`...site-packages/Bio/Entrez/DTDs`，因此如果其中的 DTD 文件已`...site-packages/Bio/Entrez/DTDs`过时，您还可以将较新版本的 DTD 文件放在那里。或者，如果您从源代码安装 Biopython，您可以将 DTD 文件添加到源代码目录`Bio/Entrez/DTDs`，然后重新安装 Biopython。这会将新的 DTD 文件与其他 DTD 文件一起安装在正确的位置。

Entrez 编程实用程序还可以生成其他格式的输出，例如序列数据库的 Fasta 或 GenBank 文件格式，或文献数据库的 MedLine 格式，在第[9.13](https://biopython-org.translate.goog/DIST/docs/tutorial/Tutorial.html?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN&_x_tr_pto=wapp&_x_tr_sch=http#sec%3Aentrez-specialized-parsers)。

因此， 的解析器中的函数`Bio.Entrez`以二进制格式或文本格式返回数据，具体取决于请求的数据类型。在大多数情况下，这些函数在假设编码为 UTF-8 的情况下，将从 NCBI Entrez 获得的数据解码为 Python 字符串，从而以文本格式返回数据。但是，XML 数据以二进制格式返回。这样做的原因是编码是在 XML 文档本身中指定的，这意味着在我们开始解析文件之前我们不知道要使用的正确编码。`Bio.Entrez`的解析器因此接受二进制格式的数据，从 XML 中提取编码，并使用它将 XML 文档中的所有文本解码为 Python 字符串，确保所有文本（特别是英语以外的其他语言）都被正确解释。这也是为什么当您想使用 的`Bio.Entrez`解析器解析文件时应该以二进制模式打开 XML 文件的原因。

## 9.1 企业指南

在使用 Biopython 访问 NCBI 的在线资源（通过`Bio.Entrez`或某些其他模块）之前，请阅读[NCBI 的 Entrez 用户要求](https://translate.google.com/website?sl=auto&tl=zh-CN&hl=zh-CN&client=webapp&u=https://www.ncbi.nlm.nih.gov/books/NBK25497/)。如果 NCBI 发现您在滥用他们的系统，他们可以并且将会禁止您访问！

换句话说：

- 对于超过 100 个请求的任何系列，请在周末或美国高峰时段以外执行此操作。这取决于你服从。

- 使用[https://eutils.ncbi.nlm.nih.gov](https://translate.google.com/website?sl=auto&tl=zh-CN&hl=zh-CN&client=webapp&u=https://eutils.ncbi.nlm.nih.gov)地址，而不是标准的 NCBI 网址。Biopython 使用这个网址。

- 如果您使用的是 API 密钥，则每秒最多可以进行 10 次查询，否则每秒最多进行 3 次查询。这是由 Biopython 自动执行的。包含

  ```
  api_key="MyAPIkey"
  ```

  在参数列表中或将其设置为模块级变量：

  ```
  >>> 从 Bio 导入 Entrez
  >>> Entrez.api_key = "MyAPIkey"
  ```

- 使用可选的电子邮件参数，以便 NCBI 可以在出现问题时与您联系。您可以在每次调用 Entrez 时将其显式设置为参数（例如，在参数列表中包含

  email="ANOther@example.com" ），或者您可以设置一个全局电子邮件地址：

  

  ```
  >>> 从 Bio 导入 Entrez
  >>> Entrez.email = "ANOther@example.com"
  ```

  Bio.Entrez将在每次致电 Entrez 时使用此电子邮件地址。example.com地址是专门用于文档 (RFC 2606)的保留域名。请不要使用随机电子邮件 - 最好不要提供电子邮件。自 2010 年 6 月 1 日起，电子邮件参数是强制性的。如果过度使用，NCBI 将尝试通过阻止访问电子实用程序之前提供的电子邮件地址联系用户。

- 如果你在一些更大的软件套件中使用 Biopython，请使用 tool 参数来指定它。您可以在每次调用 Entrez 时将工具名称显式设置为参数（例如，在参数列表中包含

  tool="MyLocalScript" ），或者您可以设置全局工具名称：

  

  ```
  >>> 从 Bio 导入 Entrez
  >>> Entrez.tool = "MyLocalScript"
  ```

  工具参数将默认为 Biopython。

- 对于大型查询，NCBI 还建议使用他们的会话历史功能（WebEnv 会话 cookie 字符串，请参阅第[‍9.16](https://biopython-org.translate.goog/DIST/docs/tutorial/Tutorial.html?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN&_x_tr_pto=wapp&_x_tr_sch=http#sec%3Aentrez-webenv)）。这只是稍微复杂一点。

总之，对您的使用水平保持理智。如果您计划下载大量数据，请考虑其他选项。例如，如果您想轻松访问所有人类基因，请考虑通过 FTP 将每个染色体作为 GenBank 文件获取，并将它们导入您自己的 BioSQL 数据库（参见第[20.5](https://biopython-org.translate.goog/DIST/docs/tutorial/Tutorial.html?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN&_x_tr_pto=wapp&_x_tr_sch=http#sec%3ABioSQL)。

## 9.2 EInfo：获取关于 Entrez 数据库的信息

EInfo 为每个 NCBI 数据库提供字段索引术语计数、最后更新和可用链接。此外，您可以使用 EInfo 获取可通过 Entrez 实用程序访问的所有数据库名称的列表：

```
>>> 从 Bio 导入 Entrez
>>> Entrez.email = "ANOther@example.com" ## 总是告诉 NCBI 你是谁
>>> 句柄 = Entrez.einfo()
>>> 结果 = handle.read()
>>> handle.close()
```

该变量`result`现在包含 XML 格式的数据库列表：

```
>>> 打印（结果）
<?xml version="1.0"?>
<!DOCTYPE eInfoResult PUBLIC "-//NLM//DTD eInfoResult，2002 年 5 月 11 日//EN"
 “https://www.ncbi.nlm.nih.gov/entrez/query/DTD/eInfo_020511.dtd”>
<eInfoResult>
<数据库列表>
        <DbName>已发布</DbName>
        <DbName>蛋白质</DbName>
        <DbName>核苷酸</DbName>
        <DbName>核芯</DbName>
        <DbName>nucgss</DbName>
        <DbName>nucest</DbName>
        <DbName>结构</DbName>
        <DbName>基因组</DbName>
        <DbName>书籍</DbName>
        <DbName>癌症染色体</DbName>
        <DbName>cdd</DbName>
        <DbName>差距</DbName>
        <DbName>域</DbName>
        <DbName>基因</DbName>
        <DbName>基因组学</DbName>
        <DbName>生成卫星</DbName>
        <DbName>地理</DbName>
        <DbName>gds</DbName>
        <DbName>同源</DbName>
        <DbName>期刊</DbName>
        <DbName>网格</DbName>
        <DbName>ncbisearch</DbName>
        <DbName>nlm目录</DbName>
        <DbName>omia</DbName>
        <DbName>omim</DbName>
        <DbName>pmc</DbName>
        <DbName>弹出集</DbName>
        <DbName>探测</DbName>
        <DbName>蛋白质簇</DbName>
        <DbName>pcassay</DbName>
        <DbName>pccompound</DbName>
        <DbName>pcsubstance</DbName>
        <DbName>snp</DbName>
        <DbName>分类法</DbName>
        <DbName>工具包</DbName>
        <DbName>unigene</DbName>
        <DbName>单位</DbName>
</DbList>
</eInfoResult>
```

由于这是一个相当简单的 XML 文件，我们可以通过字符串搜索简单地提取其中包含的信息。使用`Bio.Entrez`的解析器，我们可以直接将这个 XML 文件解析为 Python 对象：

```
>>> 从 Bio 导入 Entrez
>>> 句柄 = Entrez.einfo()
>>> 记录 = Entrez.read（句柄）
```

现在`record`是一本只有一个键的字典：

```
>>> 记录键（）
dict_keys(['DbList'])
```

此键中存储的值是上面 XML 中显示的数据库名称列表：

```
>>> 记录["DbList"]
['pubmed', 'protein', 'nucleotide', 'nuccore', 'nucgss', 'nucest',
 '结构'，'基因组'，'书籍'，'癌症染色体'，'cdd'，'差距'，
 'domains', 'gene', 'genomeprj', 'gensat', 'geo', 'gds', 'homologene',
 '期刊'，'网格'，'ncbisearch'，'nlmcatalog'，'omia'，'omim'，'pmc'，
 'popset', 'probe', 'proteinclusters', 'pcassay', 'pccompound',
 'pcsubstance', 'snp', '分类法', '工具包', 'unigene', 'unists']
```

对于其中的每一个数据库，我们都可以再次使用 EInfo 来获取更多信息：

```
>>> 从 Bio 导入 Entrez
>>> Entrez.email = "ANOther@example.com" ## 总是告诉 NCBI 你是谁
>>> handle = Entrez.einfo(db="pubmed")
>>> 记录 = Entrez.read（句柄）
>>> 记录["DbInfo"]["描述"]
'PubMed 书目记录'
>>> 记录["DbInfo"]["计数"]
'17989604'
>>> 记录["DbInfo"]["LastUpdate"]
'2008/05/24 06:45'
```

尝试`record["DbInfo"].keys()`查找此记录中存储的其他信息。最有用的一个是可用于 ESearch 的搜索字段列表：

```
>>> 记录中的字段["DbInfo"]["FieldList"]：
... print("%(Name)s, %(FullName)s, %(Description)s" % field)
...
ALL、所有字段、所有可搜索字段中的所有术语
UID，UID，分配给发布的唯一编号
FILT，过滤，限制记录
TITL，标题，出版物标题中的单词
WORD、文本 Word、与出版物相关的自由文本
MESH、MeSH 术语、分配给出版物的医学主题词
MAJR, MeSH Major Topic, MeSH terms of major importance to publishing
AUTH、作者、出版作者
JOUR, Journal, 刊物的期刊缩写
AFFL、隶属关系、作者的机构隶属关系和地址
...
```

这是一个很长的列表，但它间接地告诉您，对于 PubMed 数据库，您可以执行类似Jones[AUTH]的操作来搜索作者字段，或使用Sanger[AFFL]来限制 Sanger 中心的作者。这可能非常方便——尤其是当您对特定数据库不太熟悉时。

## 9.3 ESearch：搜索 Entrez 数据库

要搜索这些数据库中的任何一个，我们使用`Bio.Entrez.esearch()`. 例如，让我们在 PubMed 中搜索标题中包含 Biopython 的出版物：

```
>>> 从 Bio 导入 Entrez
>>> Entrez.email = "ANOther@example.com" ## 总是告诉 NCBI 你是谁
>>> handle = Entrez.esearch(db="pubmed", term="biopython[title]", retmax="40")
>>> 记录 = Entrez.read（句柄）
>>> 记录[“IdList”]中的“19304878”
真的
>>> 打印（记录[“IdList”]）
['22909249', '19304878']
```

在此输出中，您会看到 PubMed ID（包括 19304878，它是 Biopython 应用笔记的 PMID），可以通过 EFetch 检索（参见第[9.6](https://biopython-org.translate.goog/DIST/docs/tutorial/Tutorial.html?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN&_x_tr_pto=wapp&_x_tr_sch=http#sec%3Aefetch)节）。

您还可以使用 ESearch 来搜索 GenBank。在这里，我们将快速搜索*Cypripedioideae*兰花中的*matK*基因（参见第[9.2](https://biopython-org.translate.goog/DIST/docs/tutorial/Tutorial.html?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN&_x_tr_pto=wapp&_x_tr_sch=http#sec%3Aentrez-einfo)关于 EInfo 的一种方法，以找出您可以在每个 Entrez 数据库中搜索哪些字段）：

```
>>> handle = Entrez.esearch(
... db="nucleotide", term="Cypripedioideae[Orgn] 和 matK[Gene]", idtype="acc"
...）
>>> 记录 = Entrez.read（句柄）
>>> 记录[“计数”]
'348'
>>> 记录["IdList"]
['JQ660909.1', 'JQ660908.1', 'JQ660907.1', 'JQ660906.1', ..., 'JQ660890.1']
```

每个 ID（JQ660909.1、JQ660908.1、JQ660907.1、……）都是一个 GenBank 标识符（登录号）。有关如何实际下载这些 GenBank 记录的信息，请参阅[第 9.6。](https://biopython-org.translate.goog/DIST/docs/tutorial/Tutorial.html?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN&_x_tr_pto=wapp&_x_tr_sch=http#sec%3Aefetch)

请注意，您可以使用 NCBI 分类单元标识符来限制搜索，而不是像Cypripedioideae[Orgn]这样的物种名称，这里是txid158330[Orgn]。ESearch 帮助页面上目前没有记录这一点——NCBI 在回复电子邮件查询时解释了这一点。您通常可以通过使用 Entrez 网络界面来推断搜索词格式。例如，在基因组搜索中包含complete[prop]仅限于完整的基因组。

作为最后一个例子，让我们得到一个计算期刊标题的列表：

```
>>> handle = Entrez.esearch(db="nlmcatalog", term="computational[Journal]", retmax="20")
>>> 记录 = Entrez.read（句柄）
>>> print("{} 找到计算期刊".format(record["Count"]))
找到 117 个计算期刊
>>> print("前20个是\n{}".format(record["IdList"]))
['101660833', '101664671', '101661657', '101659814', '101657941',
 '101653734', '101669877', '101649614', '101647835', '101639023',
 '101627224', '101647801', '101589678', '101585369', '101645372',
 '101586429', '101582229', '101574747', '101564639', '101671907']
```

同样，我们可以使用 EFetch 获取每个期刊 ID 的更多信息。

ESearch 有许多有用的选项——请参阅[ESearch 帮助页面](https://translate.google.com/website?sl=auto&tl=zh-CN&hl=zh-CN&client=webapp&u=https://www.ncbi.nlm.nih.gov/books/NBK25499/%23chapter4.ESearch)了解更多信息。

## 9.4 EPost：上传标识符列表

易邮上传UI列表，用于后续搜索策略；有关详细信息，请参阅[EPost 帮助页面。](https://translate.google.com/website?sl=auto&tl=zh-CN&hl=zh-CN&client=webapp&u=https://www.ncbi.nlm.nih.gov/books/NBK25499/%23chapter4.EPost)它可以通过`Bio.Entrez.epost()`函数从 Biopython 获得。

举例说明这何时有用，假设您有一长串要使用 EFetch 下载的 ID（可能是序列，可能是引文 - 任何东西）。当您使用 EFetch 发出请求时，您的 ID 列表、数据库等都会变成一个长 URL 发送到服务器。如果您的 ID 列表很长，则此 URL 会变长，而长 URL 可能会中断（例如，某些代理不能很好地应对）。

相反，您可以将其分为两个步骤，首先使用 EPost 上传 ID 列表（这在内部使用“HTML post”，而不是“HTML get”，绕过长 URL 问题）。有了历史支持，您就可以参考这个长长的 ID 列表，并使用 EFetch 下载相关数据。

让我们看一个简单的例子来了解 EPost 是如何工作的——上传一些 PubMed 标识符：

```
>>> 从 Bio 导入 Entrez
>>> Entrez.email = "ANOther@example.com" ## 总是告诉 NCBI 你是谁
>>> id_list = ["19304878", "18606172", "16403221", "16377612", "14871861", "14630660"]
>>> print(Entrez.epost("pubmed", id=",".join(id_list)).read())
<?xml version="1.0"?>
<!DOCTYPE ePostResult PUBLIC "-//NLM//DTD ePostResult, 11 May 2002//EN"
 “https://www.ncbi.nlm.nih.gov/entrez/query/DTD/ePost_020511.dtd”>
<电子邮寄结果>
 <查询键>1</查询键>
 <WebEnv>NCID_01_206841095_130.14.22.101_9001_1242061629</WebEnv>
</ePostResult>
```

返回的 XML 包括两个重要的字符串，`QueryKey`它们`WebEnv`共同定义了您的历史会话。您将提取这些值以用于另一个 Entrez 调用，例如 EFetch：

```
>>> 从 Bio 导入 Entrez
>>> Entrez.email = "ANOther@example.com" ## 总是告诉 NCBI 你是谁
>>> id_list = ["19304878", "18606172", "16403221", "16377612", "14871861", "14630660"]
>>> search_results = Entrez.read(Entrez.epost("pubmed", id=",".join(id_list)))
>>> webenv = search_results["WebEnv"]
>>> query_key = search_results["QueryKey"]
```

章节[‍ 9.16](https://biopython-org.translate.goog/DIST/docs/tutorial/Tutorial.html?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN&_x_tr_pto=wapp&_x_tr_sch=http#sec%3Aentrez-webenv)展示了如何使用历史功能。

## 9.5 ESummary：从主 ID 中检索摘要

ESummary 从主要 ID 列表中检索文档摘要（有关更多信息，请参阅[ESummary 帮助页面）。](https://translate.google.com/website?sl=auto&tl=zh-CN&hl=zh-CN&client=webapp&u=https://www.ncbi.nlm.nih.gov/books/NBK25499/%23chapter4.ESummary)在 Biopython 中，ESummary 作为`Bio.Entrez.esummary()`. 使用上面的搜索结果，我们可以找到更多关于 ID 为 30367 的期刊：

```
>>> 从 Bio 导入 Entrez
>>> Entrez.email = "ANOther@example.com" ## 总是告诉 NCBI 你是谁
>>> handle = Entrez.esummary(db="nlmcatalog", id="101660833")
>>> 记录 = Entrez.read（句柄）
>>> info = record[0]["TitleMainList"][0]
>>> print("期刊信息\nid: {}\n标题: {}".format(record[0]["Id"], info["Title"]))
期刊信息
编号：101660833
标题：关于计算成像的 IEEE 事务。
```

## 9.6 EFetch：从 Entrez 下载完整记录



当您想从 Entrez 检索完整记录时，您可以使用 EFetch。这涵盖了几个可能的数据库，如主要[EFetch 帮助页面](https://translate.google.com/website?sl=auto&tl=zh-CN&hl=zh-CN&client=webapp&u=https://www.ncbi.nlm.nih.gov/books/NBK3837/)中所述。

对于他们的大多数数据库，NCBI 支持多种不同的文件格式。从 Entrez 请求特定文件格式`Bio.Entrez.efetch()`需要指定`rettype`和/或`retmode`可选参数。[在链接到NCBI efetch 网页的](https://translate.google.com/website?sl=auto&tl=zh-CN&hl=zh-CN&client=webapp&u=https://www.ncbi.nlm.nih.gov/books/NBK25499/%23chapter4.EFetch)页面上，针对每种数据库类型描述了不同的组合。

一种常见的用法是以 FASTA 或 GenBank/GenPept 纯文本格式下载序列（然后可以使用 解析`Bio.SeqIO`，参见章节[‍ 5.3.1](https://biopython-org.translate.goog/DIST/docs/tutorial/Tutorial.html?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN&_x_tr_pto=wapp&_x_tr_sch=http#sec%3ASeqIO_GenBank_Online)和[‍ 9.6](https://biopython-org.translate.goog/DIST/docs/tutorial/Tutorial.html?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN&_x_tr_pto=wapp&_x_tr_sch=http#sec%3Aefetch)）。从上面的*Cypripedioideae*示例中，我们可以使用以下命令下载 GenBank 记录 EU490707 `Bio.Entrez.efetch`：

```
>>> 从 Bio 导入 Entrez
>>> Entrez.email = "ANOther@example.com" ## 总是告诉 NCBI 你是谁
>>> handle = Entrez.efetch(db="核苷酸", id="EU490707", rettype="gb", retmode="text")
>>> 打印（处理。读取（））
LOCUS EU490707 1302 bp DNA 线性 PLN 26-JUL-2016
定义 Selenipedium aequinoctiale 成熟酶 K (matK) 基因，部分 cds；
            叶绿体。
加入 EU490707
版本 EU490707.1
关键词。
来源叶绿体 Selenipedium aequinoctale
  有机物 Selenipedium aequinoctale
            真核生物；绿色植物科；链藻门；有胚植物；气管植物；
            种子植物；木兰科；百合科；芦笋; 兰科；
            鲤亚科；硒脚。
参考文献 1（碱基 1 至 1302）
  作者 Neubig,KM, Whitten,WM, Carlsward,BS, Blanco,MA, Endara,L.,
            Williams, NH 和 Moore, M。
  标题 ycf1 在兰花中的系统发育效用：质体基因 更多
            比 matK 可变
  期刊植物系统。进化。277 (1-2), 75-84 (2009)
参考文献 2（碱基 1 至 1302）
  作者 Neubig,KM, Whitten,WM, Carlsward,BS, Blanco,MA,
            Endara,CL, Williams,NH 和 Moore,MJ
  TITLE 直接提交
  期刊已提交（2008 年 2 月 14 日）植物学系，University of
            佛罗里达州，220 Bartram Hall，盖恩斯维尔，FL 32611-8526，美国
特征 位置/限定词
     来源 1..1302
                     /organism="Selenipedium aequinoctiale"
                     /organelle="质体:叶绿体"
                     /mol_type="基因组 DNA"
                     /specimen_voucher="FLAS:布兰科 2475"
                     /db_xref="分类单元：256374"
     基因 <1..>1302
                     /基因=“matK”
     光盘 <1..>1302
                     /基因=“matK”
                     /codon_start=1
                     /翻译表=11
                     /product="成熟酶 K"
                     /protein_id="ACC99456.1"
                     /translation="IFYEPVEIFGYDNKSSLVLVKRLITRMYQQNFLISSVNDSNQKG
                     FWGHKHFFSSHFSSQMVSEGFGVILEIPFSSQLVSSLEEKKIPKYQNLRSIHSIFPFL
                     EDKFLHLNYVSDLIPPHPIHLEILVQILQCRIKDVPSLHLLRLLFHEYHNLNSLITSK
                     KFIYAFSKRKKRFLWLLYNSYVYECEYLFQFLRKQSSYLRSTSSGVFLERTHLYVKIE
                     HLLVVCCNSFQRILCFLKDPFMHYVRYQGKAILASKGTLILMKKWKFHLVNFWQSYFH
                     FWSQPYRIHIKQLSNYSFFLGYFSSVLENHLVVRNQMLENSFIINLLTKKFDTIAPV
                     ISLIGSLSKAQFCTVLGHPISKPIWTDSDSDILDRFCRICRNLCRYHSGSSKKQVLY
                     RIKYILRLSCARTLARKHKSTVRTFMRRLGSGLLEEFFMEEE”
起源      
        1 attttttacg aacctgtgga aattttggt tatgacaata aatctagttt agtacttgtg
       第61话
      第121话
      第181话
      第241章
      第301话
      第361话
      第421章
      第481话
      第541章
      第601话
      第661章
      第721章
      第781章
      第841章
      第901章
      第961章
     第1021章
     第1081章
     第1141章
     1201 tcgtgtgcta gaactttggc acggaaacat aaaagtacag tacgcacttt tatgcgaaga
     第1261章
//
<空白>
<空白>
```

请注意，自 2016 年 10 月起，GI 标识符已停用，取而代之的是登录号。您仍然可以根据它们的 GI 获取序列，但新序列不再被赋予此标识符。您应该像示例中那样通过“登录号”来引用它们。

参数`rettype="gb"`，`retmode="text"`让我们以 GenBank 格式下载此记录。

请注意，直到 2009 年复活节，Entrez EFetch API 允许您使用“genbank”作为返回类型，但是 NCBI 现在坚持使用官方返回类型“gb”或“gbwithparts”（或蛋白质的“gp”），如前所述在网上。另请注意，直到 2012 年 2 月，Entrez EFetch API 将默认返回纯文本文件，但现在默认为 XML。

或者，您可以使用例如`rettype="fasta"`获取 Fasta 格式；有关其他选项，请参阅[EFetch 序列帮助页面。](https://translate.google.com/website?sl=auto&tl=zh-CN&hl=zh-CN&client=webapp&u=https://www.ncbi.nlm.nih.gov/books/NBK25499/%23chapter4.EFetch)请记住 - 可用格式取决于您从哪个数据库下载 - 请参阅主[EFetch 帮助页面](https://translate.google.com/website?sl=auto&tl=zh-CN&hl=zh-CN&client=webapp&u=https://www.ncbi.nlm.nih.gov/books/NBK25499/%23chapter4.EFetch)。

`Bio.SeqIO`如果您以（参见第[5](https://biopython-org.translate.goog/DIST/docs/tutorial/Tutorial.html?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN&_x_tr_pto=wapp&_x_tr_sch=http#chapter%3Aseqio)）接受的格式之一获取记录，则可以直接将其解析为`SeqRecord`：

```
>>> 从 Bio 导入 SeqIO
>>> 从 Bio 导入 Entrez
>>> Entrez.email = "ANOther@example.com" ## 总是告诉 NCBI 你是谁
>>> handle = Entrez.efetch(db="核苷酸", id="EU490707", rettype="gb", retmode="text")
>>> record = SeqIO.read(handle, “genbank”)
>>> handle.close()
>>> 打印（记录.id）
EU490707.1
>>> 打印（记录名称）
EU490707
>>> 打印（记录.描述）
Selenipedium aequinoctiale 成熟酶 K (matK) 基因，部分 cds；叶绿体
>>> 打印（len（record.features））
3个
>>> 记录.seq
Seq('ATTTTTTACGAACCTGTGGAAATTTTTGGTTATGACAATAAATCTAGTTTAGTA...GAA')
```

请注意，更典型的用途是将序列数据保存到本地文件，*然后*使用`Bio.SeqIO`. 这可以避免您在处理脚本时不得不重复下载相同的文件，并减少 NCBI 服务器的负载。例如：

```
导入操作系统
从 Bio 导入 SeqIO
从 Bio 导入 Entrez

Entrez.email = "ANOther@example.com" ## 总是告诉 NCBI 你是谁
文件名 = "EU490707.gbk"
如果不是 os.path.isfile（文件名）：
    ## 正在下载...
    net_handle = Entrez.efetch(
        db="核苷酸", id="EU490707", rettype="gb", retmode="text"
    )
    out_handle = open(文件名, "w")
    out_handle.write(net_handle.read())
    out_handle.close()
    net_handle.close()
    打印（“已保存”）

print("正在解析...")
record = SeqIO.read（文件名，“genbank”）
打印（记录）
```

要获取 XML 格式的输出（您可以使用该`Bio.Entrez.read()`函数进行解析），请使用`retmode="xml"`：

```
>>> 从 Bio 导入 Entrez
>>> Entrez.email = "ANOther@example.com" ## 总是告诉 NCBI 你是谁
>>> handle = Entrez.efetch(db="核苷酸", id="EU490707", retmode="xml")
>>> 记录 = Entrez.read（句柄）
>>> handle.close()
>>> 记录[0]["GBSeq_definition"]
'Selenipedium aequinoctiale 成熟酶 K (matK) 基因，部分 cds；叶绿体'
>>> 记录[0]["GBSeq_source"]
'叶绿体 Selenipedium aequinoctale'
```

所以，这涉及到序列。有关解析特定于其他数据库的文件格式的示例（例如`MEDLINE`PubMed 中使用的格式），请参阅第[9.13](https://biopython-org.translate.goog/DIST/docs/tutorial/Tutorial.html?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN&_x_tr_pto=wapp&_x_tr_sch=http#sec%3Aentrez-specialized-parsers)。

如果你想用 执行搜索`Bio.Entrez.esearch()`，然后用 来下载记录`Bio.Entrez.efetch()`，你应该使用 WebEnv 历史记录功能——见第[9.16](https://biopython-org.translate.goog/DIST/docs/tutorial/Tutorial.html?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN&_x_tr_pto=wapp&_x_tr_sch=http#sec%3Aentrez-webenv)。

## 9.7 ELink：在 NCBI Entrez 中搜索相关项目



ELink，可从 Biopython 获得`Bio.Entrez.elink()`，可用于在 NCBI Entrez 数据库中查找相关项目。例如，您可以使用它来查找基因数据库中条目的核苷酸条目，以及其他很酷的东西。

我们用ELink找2009年发表在*Bioinformatics*上的Biopython应用笔记相关的文章，这篇文章的PubMed ID是19304878：

```
>>> 从 Bio 导入 Entrez
>>> Entrez.email = "ANOther@example.com" ## 总是告诉 NCBI 你是谁
>>> pmid = "19304878"
>>> record = Entrez.read(Entrez.elink(dbfrom="pubmed", id=pmid))
```

该`record`变量由一个 Python 列表组成，每个列表对应我们搜索的每个数据库。由于我们只指定了一个 PubMed ID 来搜索，因此`record`只包含一项。这个项目是一个字典，包含关于我们的搜索词的信息，以及所有找到的相关项目：

```
>>> 记录[0]["DbFrom"]
'发布'
>>> 记录[0]["IdList"]
['19304878']
```

键`"LinkSetDb"`包含搜索结果，存储为一个列表，每个目标数据库包含一个项目。在我们的搜索结果中，我们只找到 PubMed 数据库中的匹配项（尽管细分为类别）：

```
>>> len(记录[0]["LinkSetDb"])
8个
```

确切的数字应该随着时间的推移而增加：

```
>>> 记录 [0]["LinkSetDb"] 中的 linksetdb：
...打印（linksetdb [“DbTo”]，linksetdb [“LinkName”]，len（linksetdb [“链接”]））
...
pubmed pubmed_pubmed 284
pubmed pubmed_pubmed_alsoviewed 7
pubmed pubmed_pubmed_citedin 926
pubmed pubmed_pubmed_combined 6
pubmed pubmed_pubmed_five 6
pubmed pubmed_pubmed_refs 17
pubmed pubmed_pubmed_reviews 12
pubmed pubmed_pubmed_reviews_five 6
```

实际搜索结果存储在密钥下`"Link"`。

现在让我们来看第一个搜索结果：

```
>>> 记录[0]["LinkSetDb"][0]["Link"][0]
{'ID'：'19304878'}
```

这是我们搜索的文章，对我们帮助不大，再看第二条搜索结果：

```
>>> 记录[0]["LinkSetDb"][0]["Link"][1]
{'ID'：'14630660'}
```

这篇 PubMed ID 为 14630660 的论文是关于 Biopython PDB 解析器的。

我们可以使用循环打印出所有 PubMed ID：

```
>>> 记录[0]["LinkSetDb"][0]["Link"]中的链接：
...打印（链接[“Id”]）
...
19304878
14630660
18689808
17121776
16377612
12368254
……
```

这很好，但就我个人而言，我通常更感兴趣的是了解一篇论文是否被引用。好吧，ELink 也可以做到这一点——至少对于 Pubmed Central 中的期刊而言（参见章节[‍ 9.16.3](https://biopython-org.translate.goog/DIST/docs/tutorial/Tutorial.html?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN&_x_tr_pto=wapp&_x_tr_sch=http#sec%3Aelink-citations)）。

有关 ELink 的帮助，请参阅[ELink 帮助页面](https://translate.google.com/website?sl=auto&tl=zh-CN&hl=zh-CN&client=webapp&u=https://www.ncbi.nlm.nih.gov/books/NBK25499/%23chapter4.ELink)。[链接名称](https://translate.google.com/website?sl=auto&tl=zh-CN&hl=zh-CN&client=webapp&u=https://eutils.ncbi.nlm.nih.gov/corehtml/query/static/entrezlinks.html)有一个完整的子页面，描述了如何交叉引用不同的数据库。

## 9.8 EGQuery：全局查询——搜索词的计数

EGQuery 为每个 Entrez 数据库（即全局查询）中的搜索词提供计数。这对于找出您的搜索词在每个数据库中可以找到多少项目特别有用，而无需使用 ESearch 实际执行大量单独的搜索（参见下面[9.15.2](https://biopython-org.translate.goog/DIST/docs/tutorial/Tutorial.html?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN&_x_tr_pto=wapp&_x_tr_sch=http#sec%3Aentrez_example_genbank)中的示例）。

在此示例中，我们使用`Bio.Entrez.egquery()`获取“Biopython”的计数：

```
>>> 从 Bio 导入 Entrez
>>> Entrez.email = "ANOther@example.com" ## 总是告诉 NCBI 你是谁
>>> handle = Entrez.egquery(term="biopython")
>>> 记录 = Entrez.read（句柄）
>>> 记录中的行[“eGQueryResult”]：
...打印（行[“DbName”]，行[“计数”]）
...
发布 6
PMC 62
期刊 0
...
```

有关详细信息，请参阅[EGQuery 帮助页面。](https://translate.google.com/website?sl=auto&tl=zh-CN&hl=zh-CN&client=webapp&u=https://www.ncbi.nlm.nih.gov/books/NBK25499/%23chapter4.EGQuery)

## 9.9 ESpell：获取拼写建议

ESpell 检索拼写建议。在本例中，我们使用`Bio.Entrez.espell()`获取Biopython的正确拼写：

```
>>> 从 Bio 导入 Entrez
>>> Entrez.email = "ANOther@example.com" ## 总是告诉 NCBI 你是谁
>>> handle = Entrez.espell(term="biopythonoon")
>>> 记录 = Entrez.read（句柄）
>>> 记录["查询"]
'生物蟒'
>>> 记录["CorrectedQuery"]
'生物蟒蛇'
```

有关详细信息，请参阅[ESpell 帮助页面。](https://translate.google.com/website?sl=auto&tl=zh-CN&hl=zh-CN&client=webapp&u=https://www.ncbi.nlm.nih.gov/books/NBK25499/%23chapter4.ESpell)它的主要用途是让 GUI 工具为搜索词提供自动建议。

## 9.10 解析巨大的 Entrez XML 文件

该`Entrez.read`函数将 Entrez 返回的整个 XML 文件读取到一个保存在内存中的 Python 对象中。要解析太大而无法放入内存的 Entrez XML 文件，您可以使用函数`Entrez.parse`. 这是一个生成器函数，可以一条一条地读取 XML 文件中的记录。此函数仅在 XML 文件反映 Python 列表对象时才有用（换句话说，如果`Entrez.read`在具有无限内存资源的计算机上将返回 Python 列表）。

例如，您可以从 NCBI 的 ftp 站点以文件形式下载给定生物体的整个 Entrez Gene 数据库。这些文件可能非常大。例如，2009 年 9 月 4 日，`Homo_sapiens.ags.gz`包含人类 Entrez 基因数据库的文件大小为 116576 kB。可以使用 NCBI 的程序将此格式的文件`ASN`转换为 XML 文件`gene2xml`（有关更多信息，请参阅 NCBI 的 ftp 站点）：

```
$ gene2xml -b T -i Homo_sapiens.ags -o Homo_sapiens.xml
```

生成的 XML 文件大小为 6.1 GB。尝试`Entrez.read`此文件将导致`MemoryError`在许多计算机上出现。

XML 文件`Homo_sapiens.xml`由一系列 Entrez 基因记录组成，每个记录对应于人类中的一个 Entrez 基因。`Entrez.parse`一条一条地检索这些基因记录。然后，您可以通过遍历记录来打印或存储每条记录中的相关信息。例如，此脚本遍历 Entrez 基因记录并打印出所有当前基因的基因编号和名称：

```
>>> 从 Bio 导入 Entrez
>>> Entrez.email = "ANOther@example.com" ## 总是告诉 NCBI 你是谁
>>> handle = open("Homo_sapiens.xml", "b")
>>> 记录 = Entrez.parse(句柄)
>>> 备案备案：
... status = record["Entrezgene_track-info"]["Gene-track"]["Gene-track_status"]
...如果 status.attributes["value"] == "discontinued":
... 继续
... geneid = record["Entrezgene_track-info"]["Gene-track"]["Gene-track_geneid"]
... genename = record["Entrezgene_gene"]["Gene-ref"]["Gene-ref_locus"]
...打印（基因，基因名）
...
1 A1BG
2 A2M
3 A2MP
8 AA
9 NAT1
10 NAT2
11 有色人种协进会
12 塞皮娜3
13 AADAC
14 AAMP
15 阿纳特
16 美国退休人员协会
17 AAVS1
...
```

## 9.11 HTML 转义字符

Pubmed 记录可能包含 HTML 标签以指示例如下标、上标或斜体文本，以及通过 MathML 的数学符号。默认情况下，`Bio.Entrez`解析器将所有文本视为没有标记的纯文本；例如，Pubmed 记录摘要中的片段“ *P* < 0.05”，编码为

```
<i>P</i> 0.05
```

在 Entrez 返回的 XML 中，被转换为 Python 字符串

```
'<i>P</i> < 0.05'
```

由`Bio.Entrez`解析器。虽然这更易于人类阅读，但由于小于号，它不是有效的 HTML，并且使得通过 HTML 解析器等对文本进行进一步处理变得不切实际。要确保解析器返回的所有字符串都是有效的 HTML，请调用`Entrez.read`or`Entrez.parse`并将`escape`参数设置为`True`：

```
>>> 记录 = Entrez.read（句柄，转义=真）
```

然后，解析器将用 HTML 转义的等效字符替换 HTML 中不允许的所有字符；在上面的示例中，解析器将生成

```
'<i>P</i> <; 0.05'
```

这是一个有效的 HTML 片段。默认情况下，`escape`是`False`.

## 9.12 处理错误

#### 该文件不是 XML 文件

例如，如果您尝试将 Fasta 文件当作 XML 文件来解析，则会发生此错误：

```
>>> 从 Bio 导入 Entrez
>>> handle = open("NC_005816.fna", "rb") ## 一个 Fasta 文件
>>> 记录 = Entrez.read（句柄）
追溯（最近一次通话）：
  ...
Bio.Entrez.Parser.NotXMLError：无法解析 XML 数据（语法错误：第 1 行，第 0 列）。请确保输入数据为 XML 格式。
```

在这里，解析器没有找到`<?xml ...`XML 文件应该以其开头的标记，因此决定（正确地）该文件不是 XML 文件。

#### 文件过早结束或以其他方式损坏

当您的文件为 XML 格式但已损坏（例如，过早结束）时，解析器将引发 CorruptedXMLError。

下面是一个提前结束的 XML 文件的示例：

```
<?xml version="1.0"?>
<!DOCTYPE eInfoResult PUBLIC "-//NLM//DTD eInfoResult，2002 年 5 月 11 日//EN" "https://www.ncbi.nlm.nih.gov/entrez/query/DTD/eInfo_020511.dtd">
<eInfoResult>
<数据库列表>
        <DbName>已发布</DbName>
        <DbName>蛋白质</DbName>
        <DbName>核苷酸</DbName>
        <DbName>核芯</DbName>
        <DbName>nucgss</DbName>
        <DbName>nucest</DbName>
        <DbName>结构</DbName>
        <DbName>基因组</DbName>
        <DbName>书籍</DbName>
        <DbName>癌症染色体</DbName>
        <DbName>cdd</DbName>
```

这将生成以下追溯：

```
>>> Entrez.read（句柄）
追溯（最近一次通话）：
  ...
Bio.Entrez.Parser.CorruptedXMLError：解析 XML 数据失败（未找到元素：第 16 行，第 0 列）。请确保输入数据未损坏。
```

请注意，错误消息会告诉您在 XML 文件中的哪个位置检测到错误。

#### 该文件包含相关 DTD 中缺少的项目

这是一个 XML 文件的示例，其中包含在相应的 DTD 文件中没有描述的标签：

```
<?xml version="1.0"?>
<!DOCTYPE eInfoResult PUBLIC "-//NLM//DTD eInfoResult，2002 年 5 月 11 日//EN" "https://www.ncbi.nlm.nih.gov/entrez/query/DTD/eInfo_020511.dtd">
<eInfoResult>
        <数据库信息>
        <DbName>已发布</DbName>
        <MenuName>考研</MenuName>
        <Description>PubMed 书目记录</Description>
        <计数>20161961</计数>
        <上次更新>2010/09/10 04:52</上次更新>
        <字段列表>
                <字段>
...
                </字段>
        </字段列表>
        <文档列表>
                <文档>
                        <DsName>发布日期</DsName>
                        <DsType>4</DsType>
                        <DsTypeName>字符串</DsTypeName>
                </文档>
                <文档>
                        <DsName>EPubDate</DsName>
...
        </DbInfo>
</eInfoResult>
```

在这个文件中，出于某种原因，标记`<DocsumList>`（和其他几个）没有列在 DTD 文件中`eInfo_020511.dtd`，它在第二行指定为这个 XML 文件的 DTD。默认情况下，如果在 DTD 中找不到某个标记，解析器将停止并引发 ValidationError：

```
>>> 从 Bio 导入 Entrez
>>> handle = open("einfo3.xml", "rb")
>>> 记录 = Entrez.read（句柄）
追溯（最近一次通话）：
  ...
Bio.Entrez.Parser.ValidationError：无法在 DTD 中找到标记“DocsumList”。要跳过所有未在 DTD 中表示的标记，请调用 Bio.Entrez.read 或 Bio.Entrez.parse 并设置 validate=False。
```

或者，您可以指示解析器跳过此类标记，而不是引发 ValidationError。这是通过调用`Entrez.read`or`Entrez.parse`参数`validate`等于 False 来完成的：

```
>>> 从 Bio 导入 Entrez
>>> handle = open("einfo3.xml", "rb")
>>> 记录 = Entrez.read（句柄，验证=假）
>>> handle.close()
```

当然，包含在 XML 标签中但不在 DTD 中的信息不会出现在`Entrez.read`.

#### 该文件包含一条错误消息

例如，当您尝试访问不存在的 PubMed ID 的 PubMed 记录时，可能会发生这种情况。默认情况下，这将引发`RuntimeError`：

```
>>> 从 Bio 导入 Entrez
>>> Entrez.email = "ANOther@example.com" ## 总是告诉 NCBI 你是谁
>>> stream = Entrez.esummary(db="pubmed", id="99999999")
>>> 记录 = Entrez.read（流）
追溯（最近一次通话）：
...
RuntimeError: UID=99999999: 无法获取文档摘要
```

如果您正在访问多个 PubMed 记录，`RuntimeError`如果其中一个 PubMed ID 不正确，您将无法接收任何 PubMed 记录的结果。为了避免这种情况，您可以将`ignore_errors`参数设置为`True`. 这将为有效的 PubMed ID 返回请求的结果，并`ErrorElement`为不正确的 ID 返回：

```
>>> 从 Bio 导入 Entrez
>>> Entrez.email = "ANOther@example.com" ## 总是告诉 NCBI 你是谁
>>> stream = Entrez.esummary(db="pubmed", id="19304878,99999999,31278684")
>>> 记录 = Entrez.read（流，ignore_errors=True）
>>> 长度（记录）
3个
>>> 记录[0].tag
'文档总和'
>>> 记录[0]["标题"]
“Biopython：用于计算分子生物学和生物信息学的免费 Python 工具。”
>>> 记录[1].tag
'错误'
>>> 记录[1]
ErrorElement('UID=99999999: 无法获取文档摘要')
>>> 记录[2].tag
'文档总和'
>>> 记录[2]["标题"]
“在 Bio* 项目之间共享编程资源。”
```

## 9.13 专门的解析器



该`Bio.Entrez.read()`函数可以解析大部分（如果不是全部）Entrez 返回的 XML 输出。Entrez 通常允许您检索其他格式的记录，这些格式在可读性（或下载大小）方面与 XML 格式相比可能具有一些优势。

要从 Entrez 请求特定的文件格式，`Bio.Entrez.efetch()`需要指定`rettype`和/或`retmode`可选参数。[NCBI efetch 网页](https://translate.google.com/website?sl=auto&tl=zh-CN&hl=zh-CN&client=webapp&u=https://www.ncbi.nlm.nih.gov/books/NBK25499/%23chapter4.EFetch)上针对每种数据库类型描述了不同的组合。

一个明显的例子是您可能更喜欢下载 FASTA 或 GenBank/GenPept 纯文本格式的序列（然后可以使用 解析`Bio.SeqIO`，参见章节[‍5.3.1](https://biopython-org.translate.goog/DIST/docs/tutorial/Tutorial.html?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN&_x_tr_pto=wapp&_x_tr_sch=http#sec%3ASeqIO_GenBank_Online)和[‍9.6](https://biopython-org.translate.goog/DIST/docs/tutorial/Tutorial.html?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN&_x_tr_pto=wapp&_x_tr_sch=http#sec%3Aefetch)）。对于文献数据库，Biopython 包含一个`MEDLINE`用于 PubMed 格式的解析器。

### 9.13.1 解析 Medline 记录

您可以在 中找到 Medline 解析器`Bio.Medline`。`pubmed_result1.txt`假设我们要解析包含一条 Medline 记录的文件。你可以在 Biopython 的目录中找到这个文件`Tests\Medline`。该文件如下所示：

```
PMID- 12230038
拥有-NLM
统计医学线
DA-20020916
DCOM-20030606
LR-20041117
PUBM-打印
IS - 1467-5463（打印）
六-3
IP-3
DP - 2002 年 9 月
TI - Bio* 工具包——简要概述。
PG-296-302
AB - 生物信息学研究通常很难用商业软件来完成。这
      开源 BioPerl、BioPython 和 Biojava 项目提供工具包
...
```

我们先打开文件，然后解析它：

```
>>> 从 Bio 导入 Medline
>>> 以 open("pubmed_result1.txt") 作为句柄：
... 记录 = Medline.read（句柄）
...
```

现在`record`包含作为 Python 字典的 Medline 记录：

```
>>> 记录[“PMID”]
'12230038'
>>> 记录["AB"]
'生物信息学研究通常很难用商业软件来完成。
开源 BioPerl、BioPython 和 Biojava 项目提供工具包
多种功能，可以更轻松地创建自定义管道或
分析。这篇评论简要比较了底层语言的怪癖
以及功能、文档、实用程序和相对优势
生物同行，特别是从一开始的角度来看
生物学家程序员。
```

Medline 记录中使用的关键名称可能相当晦涩；使用

```
>>> 帮助（记录）
```

简要总结。

要解析包含多个 Medline 记录的文件，您可以改用`parse`以下函数：

```
>>> 从 Bio 导入 Medline
>>> 以 open("pubmed_result2.txt") 作为句柄：
... 记录在 Medline.parse(handle) 中：
...打印（记录[“TI”]）
...
用 python 实现的 SCOP 和 ASTRAL 的高级接口。
GenomeDiagram：用于可视化大规模基因组数据的 python 包。
开源集群软件。
用 Python 实现的 PDB 文件解析器和结构类。
```

除了解析存储在文件中的 Medline 记录，您还可以解析由`Bio.Entrez.efetch`. 例如，让我们看看 PubMed 中所有与 Biopython 相关的 Medline 记录：

```
>>> 从 Bio 导入 Entrez
>>> Entrez.email = "ANOther@example.com" ## 总是告诉 NCBI 你是谁
>>> handle = Entrez.esearch(db="pubmed", term="biopython")
>>> 记录 = Entrez.read（句柄）
>>> 记录["IdList"]
['19304878', '18606172', '16403221', '16377612', '14871861', '14630660', '12230038']
```

我们现在使用`Bio.Entrez.efetch`下载这些 Medline 记录：

```
>>> idlist = 记录["IdList"]
>>> handle = Entrez.efetch(db="pubmed", id=idlist, rettype="medline", retmode="文本")
```

在这里，我们指定`rettype="medline", retmode="text"`以纯文本 Medline 格式获取 Medline 记录。现在我们用来`Bio.Medline`解析这些记录：

```
>>> 从 Bio 导入 Medline
>>> 记录 = Medline.parse(句柄)
>>> 备案备案：
...打印（记录[“AU”]）
...
['Cock PJ', 'Antao T', 'Chang JT', 'Chapman BA', 'Cox CJ', 'Dalke A', ..., 'de Hoon MJ']
['Munteanu CR', 'Gonzalez-Diaz H', 'Magalhaes AL']
['Casbon JA', 'Crooks GE', 'Saqi MA']
['Pritchard L', 'White JA', 'Birch PR', 'Toth IK']
['de Hoon MJ'、'Imoto S'、'Nolan J'、'Miyano S']
['Hamelryck T'，'Manderick B']
['曼加拉姆 H']
```

为了比较，这里我们展示了一个使用 XML 格式的例子：

```
>>> handle = Entrez.efetch(db="pubmed", id=idlist, rettype="medline", retmode="xml")
>>> 记录 = Entrez.read(句柄)
>>> 记录在案 ["PubmedArticle"]：
...打印（记录[“MedlineCitation”] [“文章”] [“ArticleTitle”]）
...
Biopython：免费提供的用于计算分子生物学和
 生物信息学。
基于组成、序列的酶/非酶分类模型复杂性，
 3D 和拓扑索引。
用 python 实现的 SCOP 和 ASTRAL 的高级接口。
GenomeDiagram：用于可视化大规模基因组数据的 python 包。
开源集群软件。
用 Python 实现的 PDB 文件解析器和结构类。
Bio* 工具包——简要概述。
```

请注意，在这两个示例中，为简单起见，我们天真地组合了 ESearch 和 EFetch。在这种情况下，NCBI 希望您使用他们的历史记录功能，如第[9.16](https://biopython-org.translate.goog/DIST/docs/tutorial/Tutorial.html?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN&_x_tr_pto=wapp&_x_tr_sch=http#sec%3Aentrez-webenv)。

### 9.13.2 解析 GEO 记录

GEO（[Gene Expression Omnibus](https://translate.google.com/website?sl=auto&tl=zh-CN&hl=zh-CN&client=webapp&u=https://www.ncbi.nlm.nih.gov/geo/)）是高通量基因表达和杂交芯片数据的数据库。该`Bio.Geo`模块可用于解析 GEO 格式的数据。

以下代码片段显示了如何将示例 GEO 文件解析`GSE16.txt`为记录并打印记录：

```
>>> 从 Bio 导入 Geo
>>> handle = open("GSE16.txt")
>>> 记录 = Geo.parse(句柄)
>>> 备案备案：
...打印（记录）
...
```

您可以使用 ESearch 搜索“gds”数据库（GEO 数据集）：

```
>>> 从 Bio 导入 Entrez
>>> Entrez.email = "ANOther@example.com" ## 总是告诉 NCBI 你是谁
>>> handle = Entrez.esearch(db="gds", term="GSE16")
>>> 记录 = Entrez.read（句柄）
>>> handle.close()
>>> 记录[“计数”]
'27'
>>> 记录["IdList"]
['200000016', '100000028', ...]
```

从 Entrez 网站上看，UID“200000016”是 GDS16，而另一个“100000028”是关联平台 GPL28。不幸的是，在撰写本文时，NCBI 似乎不支持使用 Entrez 下载 GEO 文件（不是 XML，也不是简单*综合格式的文本*(SOFT) 格式）。

[然而，通过 FTP 从ftp://ftp.ncbi.nih.gov/pub/geo/](https://translate.google.com/website?sl=auto&tl=zh-CN&hl=zh-CN&client=webapp&u=ftp://ftp.ncbi.nih.gov/pub/geo/)下载 GEO 文件实际上非常直接。在这种情况下，您可能需要[ftp://ftp.ncbi.nih.gov/pub/geo/DATA/SOFT/by_series/GSE16/GSE16_family.soft.gz](https://translate.google.com/website?sl=auto&tl=zh-CN&hl=zh-CN&client=webapp&u=ftp://ftp.ncbi.nih.gov/pub/geo/DATA/SOFT/by_series/GSE16/GSE16_family.soft.gz)（压缩文件，请参阅 Python 模块 gzip）。

### 9.13.3 解析 UniGene 记录

UniGene 是转录组的 NCBI 数据库，每个 UniGene 记录显示与特定生物体中特定基因相关的转录本集。典型的 UniGene 记录如下所示：

```
ID Hs.2
标题 N-乙酰转移酶 2（芳胺 N-乙酰转移酶）
基因NAT2
细胞带8p22
基因编号 10
LOCUSLINK 10
是的
快递骨| 结缔组织| 肠道| 肝脏| 肝肿瘤| 正常| 软组织/肌肉组织肿瘤| 成人
RESTR_EXPR 成人
8号染色体
STS ACC=PMC310725P3 UNISTS=272646
STS ACC=WIAF-2120 UNISTS=44576
STS ACC=G59899 UNISTS=137181
...
STS ACC=GDB:187676 UNISTS=155563
PROTSIM 组织=10090；PROTGI=6754794；PROTID=NP_035004.1；厘=76.55；ALN=288
PROTSIM 组织=9796；PROTGI=149742490；PROTID=XP_001487907.1；厘=79.66；ALN=288
PROTSIM 组织=9986；PROTGI=126722851；PROTID=NP_001075655.1；厘=76.90；ALN=288
...
PROTSIM 组织=9598；PROTGI=114619004；PROTID=XP_519631.2；厘=98.28；ALN=288

数 38
序列 ACC=BC067218.1；NID=g45501306；PID=g45501307；序列类型=mRNA
序列 ACC=NM_000015.2；NID=g116295259；PID=g116295260；序列类型=mRNA
序列 ACC=D90042.1；NID=g219415；PID=g219416；序列类型=mRNA
序列 ACC=D90040.1；NID=g219411；PID=g219412；序列类型=mRNA
序列 ACC=BC015878.1；NID=g16198419；PID=g16198420；序列类型=mRNA
序列 ACC=CR407631.1；NID=g47115198；PID=g47115199；序列类型=mRNA
序列 ACC=BG569293.1；NID=g13576946；克隆=图像：4722596；结束=5'；盖子=6989；序列类型=EST；跟踪=44157214
...
序列 ACC=AU099534.1；NID=g13550663；克隆=HSI08034；结束=5'；盖子=8800；序列类型=EST
//
```

该特定记录显示了一组转录本（以线条显示`SEQUENCE`），这些转录本源自人类基因 NAT2，编码 en N-乙酰转移酶。线条`PROTSIM`显示与 NAT2 具有显着相似性的蛋白质，而`STS`线条显示基因组中相应的序列标记位点。

要解析 UniGene 文件，请使用`Bio.UniGene`模块：

```
>>> 从 Bio 导入 UniGene
>>> input = open("myunigenefile.data")
>>> 记录 = UniGene.read（输入）
```

返回`record`的`UniGene.read`是一个 Python 对象，其属性对应于 UniGene 记录中的字段。例如，

```
>>> 记录.ID
“Hs.2”
>>> 记录.title
“N-乙酰转移酶 2（芳胺 N-乙酰转移酶）”
```

和行存储为 Python 字符串列表`EXPRESS`：`RESTR_EXPR`

```
[
    “骨”，
    “结缔组织”，
    “肠”，
    “肝”，
    “肝肿瘤”，
    “普通的”，
    “软组织/肌肉组织肿瘤”，
    “成人”，
]
```

为`STS`、`PROTSIM`和`SEQUENCE`行返回专用对象，将每行中显示的键存储为属性：

```
>>> 记录.sts[0].acc
'PMC310725P3'
>>> record.sts[0].unists
'272646'
```

`PROTSIM`对于和行也是如此`SEQUENCE`。

要解析包含多个 UniGene 记录的文件，请使用`parse`以下函数`Bio.UniGene`：

```
>>> 从 Bio 导入 UniGene
>>> input = open("unigenerecords.data")
>>> 记录 = UniGene.parse(输入)
>>> 备案备案：
...打印（记录。ID）
...
```

## 9.14 使用代理

通常您不必担心使用代理，但如果这是您网络上的问题，请参阅此处的处理方法。在内部，`Bio.Entrez`使用标准 Python 库`urllib`访问 NCBI 服务器。`http_proxy`这将检查一个名为自动配置任何简单代理的环境变量。不幸的是，此模块不支持使用需要身份验证的代理。

您可以选择设置`http_proxy`一次环境变量（如何设置取决于您的操作系统）。或者，您可以在脚本开头的 Python 中设置它，例如：

```
导入操作系统

os.environ["http_proxy"] = "http://proxyhost.example.com:8080"
```

有关详细信息，请参阅[urllib 文档。](https://translate.google.com/website?sl=auto&tl=zh-CN&hl=zh-CN&client=webapp&u=https://docs.python.org/2/library/urllib.html)

## 9.15 例子



### 9.15.1 PubMed 和 Medline



如果您在医学领域或对人类问题感兴趣（很多时候即使您不感兴趣！），PubMed ( [https://www.ncbi.nlm.nih.gov/PubMed/](https://translate.google.com/website?sl=auto&tl=zh-CN&hl=zh-CN&client=webapp&u=https://www.ncbi.nlm.nih.gov/PubMed/) ) 是各种问题的极好来源好东西。所以像其他东西一样，我们希望能够从中获取信息并在 Python 脚本中使用它。

在此示例中，我们将查询 PubMed 以查找与兰花有关的所有文章（请参阅第[2.3](https://biopython-org.translate.goog/DIST/docs/tutorial/Tutorial.html?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN&_x_tr_pto=wapp&_x_tr_sch=http#sec%3Aorchids)我们的动机）。我们首先检查有多少这样的文章：

```
>>> 从 Bio 导入 Entrez
>>> Entrez.email = "ANOther@example.com" ## 总是告诉 NCBI 你是谁
>>> handle = Entrez.egquery(term="兰花")
>>> 记录 = Entrez.read（句柄）
>>> 记录中的行[“eGQueryResult”]：
...如果行 ["DbName"] == "pubmed"：
...打印（行[“计数”]）
...
463
```

现在我们使用`Bio.Entrez.efetch`函数下载这463篇文章的PubMed ID：

```
>>> 从 Bio 导入 Entrez
>>> Entrez.email = "ANOther@example.com" ## 总是告诉 NCBI 你是谁
>>> handle = Entrez.esearch(db="pubmed", term="orchid", retmax=463)
>>> 记录 = Entrez.read（句柄）
>>> handle.close()
>>> idlist = 记录["IdList"]
```

这将返回一个 Python 列表，其中包含与兰花相关的文章的所有 PubMed ID：

```
>>> 打印（idlist）
['18680603', '18665331', '18661158', '18627489', '18627452', '18612381',
'18594007', '18591784', '18589523', '18579475', '18575811', '18575690',
...
```

既然我们已经得到了它们，我们显然想要获得相应的 Medline 记录并从中提取信息。在这里，我们将下载 Medline 平面文件格式的 Medline 记录，并使用该`Bio.Medline`模块解析它们：

```
>>> 从 Bio 导入 Medline
>>> handle = Entrez.efetch(db="pubmed", id=idlist, rettype="medline", retmode="文本")
>>> 记录 = Medline.parse(句柄)
```

注意 - 我们刚刚在这里进行了单独的搜索和获取，NCBI 更希望您在这种情况下利用他们的历史支持。参见章节[‍ 9.16](https://biopython-org.translate.goog/DIST/docs/tutorial/Tutorial.html?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN&_x_tr_pto=wapp&_x_tr_sch=http#sec%3Aentrez-webenv)。

请记住这`records`是一个迭代器，因此您只能迭代记录一次。如果要保存记录，可以将它们转换为列表：

```
>>> 记录 = 列表（记录）
```

现在让我们遍历记录以打印出关于每条记录的一些信息：

```
>>> 备案备案：
...打印（“标题：”，record.get（“TI”，“？”））
...打印（“作者：”，record.get（“AU”，“？”））
...打印（“来源：”，record.get（“SO”，“？”））
... 打印（””）
...
```

这个输出看起来像：

```
标题：早期蜘蛛兰（ophrys sphegodes）中的性信息素模仿：
碳氢化合物的模式作为有性授粉的关键机制
欺骗 [引用中]
作者：['Schiestl FP', 'Ayasse M', 'Paulus HF', 'Lofstedt C', 'Hansson BS',
'Ibarra F', 'Francke W']
来源：J Comp Physiol [A] 2000 Jun；186(6):567-74
```

特别值得注意的是作者列表，它作为标准 Python 列表返回。这使得使用标准 Python 工具进行操作和搜索变得容易。例如，我们可以使用如下代码循环遍历一大堆条目来搜索特定作者：

```
>>> search_author = "等待 T"
>>> 备案备案：
...如果记录中不是“AU”：
... 继续
...如果 search_author 在记录 ["AU"] 中：
... print("找到作者 %s: %s" % (search_author, record["SO"]))
...
```

希望本节能让您了解 Entrez 和 Medline 界面的强大功能和灵活性，以及它们如何一起使用。

### 9.15.2 搜索、下载和解析 Entrez 核苷酸记录



这里我们将展示一个执行远程 Entrez 查询的简单示例。[在](https://biopython-org.translate.goog/DIST/docs/tutorial/Tutorial.html?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN&_x_tr_pto=wapp&_x_tr_sch=http#sec%3Aorchids)解析示例的第 2.3 节中，我们讨论了使用 NCBI 的 Entrez 网站在 NCBI 核苷酸数据库中搜索有关 Cypripedioideae 的信息，我们的朋友 lady slipper orchids。现在，我们将看看如何使用 Python 脚本自动执行该过程。在此示例中，我们将仅展示如何连接、获取结果并解析它们，而 Entrez 模块将完成所有工作。

首先，我们使用 EGQuery 在实际下载之前找出我们将获得的结果数量。EGQuery 会告诉我们在每个数据库中找到了多少搜索结果，但对于这个例子，我们只对核苷酸感兴趣：

```
>>> 从 Bio 导入 Entrez
>>> Entrez.email = "ANOther@example.com" ## 总是告诉 NCBI 你是谁
>>> handle = Entrez.egquery(term="Cypripedioideae")
>>> 记录 = Entrez.read（句柄）
>>> 记录中的行[“eGQueryResult”]：
...如果行 ["DbName"] == "nuccore"：
...打印（行[“计数”]）
...
4457
```

因此，我们预计会找到 4457 条 Entrez Nucleotide 记录（这比 2008 年的 814 条记录有所增加；未来可能会继续增加）。如果您发现一些高得离谱的点击率，您可能需要重新考虑是否真的要下载所有这些，这是我们的下一步。让我们使用`retmax`参数将检索到的最大记录数限制为 2008 年可用的数量：

```
>>> 从 Bio 导入 Entrez
>>> Entrez.email = "ANOther@example.com" ## 总是告诉 NCBI 你是谁
>>> handle = Entrez.esearch(
... db="nucleotide", term="Cypripedioideae", retmax=814, idtype="acc"
...）
>>> 记录 = Entrez.read（句柄）
>>> handle.close()
```

这`record`是一个包含搜索结果和一些辅助信息的 Python 字典。仅供参考，让我们看一下该字典中存储的内容：

```
>>> 打印（记录键（））
['Count', 'RetMax', 'IdList', 'TranslationSet', 'RetStart', 'QueryTranslation']
```

首先，让我们检查找到了多少结果：

```
>>> 打印（记录[“计数”]）
'4457'
```

您可能期望这是 814，这是我们要求检索的最大记录数。但是，`Count`表示可用于该搜索的记录总数，而不是检索到的记录数。检索到的记录存储在 中`record['IdList']`，其中应包含我们要求的总数：

```
>>> len(记录["IdList"])
814
```

让我们看看前五个结果：

```
>>> 记录["IdList"][:5]
['KX265015.1', 'KX265014.1', 'KX265013.1', 'KX265012.1', 'KX265011.1']
```

我们可以使用下载这些记录`efetch`。虽然您可以一条一条地下载这些记录，但为了减少 NCBI 服务器的负载，最好同时获取一堆记录，如下所示。然而，在这种情况下，您应该理想地使用稍后在[第 9.16](https://biopython-org.translate.goog/DIST/docs/tutorial/Tutorial.html?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN&_x_tr_pto=wapp&_x_tr_sch=http#sec%3Aentrez-webenv)。

```
>>> idlist = ",".join(记录["IdList"][:5])
>>> 打印（idlist）
KX265015.1, KX265014.1, KX265013.1, KX265012.1, KX265011.1]
>>> handle = Entrez.efetch(db="核苷酸", id=idlist, retmode="xml")
>>> 记录 = Entrez.read(句柄)
>>> len(记录)
5个
```

这些记录中的每一个对应于一个 GenBank 记录。

```
>>> 打印（记录[0].键（））
['GBSeq_moltype', 'GBSeq_source', 'GBSeq_sequence',
 'GBSeq_primary-accession', 'GBSeq_definition', 'GBSeq_accession-version',
 'GBSeq_topology', 'GBSeq_length', 'GBSeq_feature-table',
 'GBSeq_create-date', 'GBSeq_other-seqids', 'GBSeq_division',
 'GBSeq_taxonomy', 'GBSeq_references', 'GBSeq_update-date',
 'GBSeq_organism', 'GBSeq_locus', 'GBSeq_strandedness']

>>> 打印（记录[0][“GBSeq_primary-accession”]）
DQ110336

>>> 打印（记录[0][“GBSeq_other-seqids”]）
['gb|DQ110336.1|', 'gi|187237168']

>>> 打印（记录[0][“GBSeq_definition”]）
Cypripedium calceolus 凭证 Davis 03-03 成熟酶 (matR) 基因，部分 cds；
线粒体

>>> 打印（记录[0][“GBSeq_organism”]）
方盆花
```

您可以使用它来快速设置搜索——但对于大量使用，请参阅第[‍ 9.16](https://biopython-org.translate.goog/DIST/docs/tutorial/Tutorial.html?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN&_x_tr_pto=wapp&_x_tr_sch=http#sec%3Aentrez-webenv)。

### 9.15.3 GenBank记录的检索、下载、解析



GenBank 记录格式是一种非常流行的保存有关序列、序列特征和其他相关序列信息的方法。该格式是从 NCBI 数据库获取信息的好方法，网址为[https://www.ncbi.nlm.nih.gov/](https://translate.google.com/website?sl=auto&tl=zh-CN&hl=zh-CN&client=webapp&u=https://www.ncbi.nlm.nih.gov/)。

在这个例子中，我们将展示如何查询 NCBI 数据库，从查询中检索记录，然后使用`Bio.SeqIO`- [5.3.1](https://biopython-org.translate.goog/DIST/docs/tutorial/Tutorial.html?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN&_x_tr_pto=wapp&_x_tr_sch=http#sec%3ASeqIO_GenBank_Online)解析它们。为简单起见，此示例*未*利用 WebEnv 历史功能 - 请参阅第[9.16](https://biopython-org.translate.goog/DIST/docs/tutorial/Tutorial.html?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN&_x_tr_pto=wapp&_x_tr_sch=http#sec%3Aentrez-webenv)。

首先，我们要进行查询并找出要检索的记录的 ID。在这里，我们将快速搜索我们最喜欢的生物之一*Opuntia*（仙人掌）。我们可以进行快速搜索并取回所有相应记录的 GI（GenBank 标识符）。首先我们检查有多少条记录：

```
>>> 从 Bio 导入 Entrez
>>> Entrez.email = "ANOther@example.com" ## 总是告诉 NCBI 你是谁
>>> handle = Entrez.egquery(term="仙人掌和 rpl16")
>>> 记录 = Entrez.read（句柄）
>>> 记录中的行[“eGQueryResult”]：
...如果行 ["DbName"] == "nuccore"：
...打印（行[“计数”]）
...
9
```

现在我们下载 GenBank 标识符列表：

```
>>> handle = Entrez.esearch(db="nuccore", term="仙人掌和 rpl16")
>>> 记录 = Entrez.read（句柄）
>>> gi_list = 记录["IdList"]
>>> gi_list
['57240072', '57240071', '6273287', '6273291', '6273290', '6273289', '6273286',
'6273285', '6273284']
```

现在我们使用这些 GI 来下载 GenBank 记录——请注意，对于旧版本的 Biopython，您必须向 Entrez 提供一个逗号分隔的 GI 编号列表，从 Biopython 1.59 开始，您可以传递一个列表，并为您转换：

```
>>> gi_str = ",".join(gi_list)
>>> handle = Entrez.efetch(db="nuccore", id=gi_str, rettype="gb", retmode="文本")
```

如果你想查看原始 GenBank 文件，你可以从这个句柄中读取并打印出结果：

```
>>> 文本 = handle.read()
>>> 打印（文本）
LOCUS AY851612 892 bp DNA 线性 PLN 10-APR-2007
定义 仙人掌 rpl16 基因，内含子；叶绿体。
加入AY851612
版本 AY851612.1 GI:57240072
关键词。
来源叶绿体 Austrocylindropuntia subulata
  有机体 Austrocylindropuntia subulata
            真核生物；绿色植物科；链藻门；有胚植物；气管植物；
            种子植物；木兰植物；真子叶植物；核心真子叶植物；
            石竹目；仙人掌科；仙人掌科；Austrocylindropuntia。
参考文献 1（碱基 1 至 892）
  作者 Butterworth, CA 和 Wallace, RS
...
```

在这种情况下，我们只是获取原始记录。为了以更 Python 友好的形式获取记录，我们可以使用`Bio.SeqIO`将 GenBank 数据解析为`SeqRecord`对象，包括`SeqFeature`对象（参见第[‍5](https://biopython-org.translate.goog/DIST/docs/tutorial/Tutorial.html?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN&_x_tr_pto=wapp&_x_tr_sch=http#chapter%3Aseqio)）：

```
>>> 从 Bio 导入 SeqIO
>>> handle = Entrez.efetch(db="nuccore", id=gi_str, rettype="gb", retmode="文本")
>>> records = SeqIO.parse(handle, "gb")
```

我们现在可以逐步浏览记录并查看我们感兴趣的信息：

```
>>> 备案备案：
...打印（f“{record.name}，长度{len（record）}，具有{len（record.features）}特征”）
...
AY851612，长度892，具有3个特征
AY851611，长度881，具有3个特征
AF191661，长度895，具有3个特征
AF191665，长度902，具有3个特征
AF191664，长度899，具有3个特征
AF191663，长度899，具有3个特征
AF191660，长度893，具有3个特征
AF191659，长度894，具有3个特征
AF191658，长度896，具有3个特征
```

与手动操作相比，使用这些自动查询检索功能是一个很大的优势。尽管该模块应遵守 NCBI 的每秒最多三个查询规则，但 NCBI 还有其他建议，例如避免高峰时间。参见章节[‍ 9.1](https://biopython-org.translate.goog/DIST/docs/tutorial/Tutorial.html?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN&_x_tr_pto=wapp&_x_tr_sch=http#sec%3Aentrez-guidelines)。请特别注意，为简单起见，此示例未使用 WebEnv 历史记录功能。您应该将其用于任何重要的搜索和下载工作，请参阅第[‍ 9.16](https://biopython-org.translate.goog/DIST/docs/tutorial/Tutorial.html?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN&_x_tr_pto=wapp&_x_tr_sch=http#sec%3Aentrez-webenv)。

最后，如果打算重复你的分析，而不是从 NCBI 下载文件并立即解析它们（如本例所示），你应该只下载一次记录并保存到*你*的硬盘，然后解析本地文件.

### 9.15.4 寻找生物的谱系

继续以植物为例，现在让我们找出 Cypripedioideae 兰科植物的谱系。首先，我们在分类数据库中搜索 Cypripedioideae，它恰好产生一个 NCBI 分类标识符：

```
>>> 从 Bio 导入 Entrez
>>> Entrez.email = "ANOther@example.com" ## 总是告诉 NCBI 你是谁
>>> handle = Entrez.esearch(db="Taxonomy", term="Cypripedioideae")
>>> 记录 = Entrez.read（句柄）
>>> 记录["IdList"]
['158330']
>>> 记录["IdList"][0]
'158330'
```

现在，我们使用`efetch`在 Taxonomy 数据库中下载这个条目，然后解析它：

```
>>> handle = Entrez.efetch(db="Taxonomy", id="158330", retmode="xml")
>>> 记录 = Entrez.read(句柄)
```

同样，这条记录存储了大量信息：

```
>>> 记录[0].keys()
['沿袭', '部门', 'ParentTaxId', 'PubDate', 'LineageEx',
 'CreateDate', 'TaxId', 'Rank', 'GeneticCode', 'ScientificName',
 'MitoGeneticCode', 'UpdateDate']
```

我们可以直接从这个记录中得到谱系：

```
>>> 记录[0]["血统"]
'细胞生物; 真核生物；绿色植物科；链藻门；链霉菌；
 有胚植物；气管植物；真叶植物；种子植物；木兰科；
 百合科；芦笋; 兰科'
```

记录数据包含的不仅仅是此处显示的信息 - 例如，在“LineageEx”而不是“Lineage”下查看，您还将获得谱系条目的 NCBI 分类标识符。

## 9.16 使用历史和 WebEnv



通常您会想要进行一系列链接查询。最典型的是，运行搜索，可能优化搜索，然后检索详细的搜索结果。您*可以*通过对 Entrez 进行一系列单独调用来完成此操作。然而，NCBI 更希望您利用他们的历史支持——例如结合 ESearch 和 EFetch。

历史支持的另一个典型用途是结合 EPost 和 EFetch。您使用 EPost 上传标识符列表，这会启动一个新的历史会话。然后，您通过引用会话（而不是标识符）使用 EFetch 下载记录。

### 9.16.1 使用历史搜索和下载序列

假设我们要搜索和下载所有的*仙人掌*rpl16 核苷酸序列，并将它们存储在一个 FASTA 文件中。如[‍ 9.15.3](https://biopython-org.translate.goog/DIST/docs/tutorial/Tutorial.html?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN&_x_tr_pto=wapp&_x_tr_sch=http#sec%3Aentrez-search-fetch-genbank)，我们可以天真地组合`Bio.Entrez.esearch()`得到一个 Accession numbers 列表，然后调用`Bio.Entrez.efetch()`将它们全部下载。

但是，批准的方法是使用历史功能运行搜索。然后，我们可以通过参考搜索结果来获取结果——NCBI 可以预测并缓存这些结果。

为此，请`Bio.Entrez.esearch()`正常调用，但使用附加参数`usehistory="y"`,

```
>>> 从 Bio 导入 Entrez
>>> Entrez.email = "history.user@example.com" ## 总是告诉 NCBI 你是谁
>>> search_handle = Entrez.esearch(
... db="nucleotide", term="Opuntia[orgn] 和 rpl16", usehistory="y", idtype="acc"
...）
>>> search_results = Entrez.read（search_handle）
>>> search_handle.close()
```

和以前一样（参见章节[‍ 9.15.2](https://biopython-org.translate.goog/DIST/docs/tutorial/Tutorial.html?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN&_x_tr_pto=wapp&_x_tr_sch=http#sec%3Aentrez_example_genbank)），XML 输出包括第一个`retmax`搜索结果，`retmax`默认为 20：

```
>>> acc_list = search_results["IdList"]
>>> count = int(search_results["Count"])
>>> len(acc_list)
20
>>> 计数
28
```

您还会获得两条额外的信息，即WebEnv会话 cookie 和QueryKey：

```
>>> webenv = search_results["WebEnv"]
>>> query_key = search_results["QueryKey"]
```

将这些值存储在变量session_cookie和query_key中后，我们可以将它们用作参数，`Bio.Entrez.efetch()`而不是将 GI 编号作为标识符。

虽然对于小型搜索，一次下载所有内容可能没问题，但最好分批下载。您可以使用retstart和retmax参数指定要返回的搜索结果范围（使用从零开始计数的起始条目，以及要返回的最大结果数）。请注意，如果 Biopython 在与 NCBI 通信时遇到像 HTTP 500 响应这样的瞬时故障，它会自动重试几次。例如，

```
## 这假设您已经运行了如上所示的搜索，
## 并设置变量 count、webenv、query_key

batch_size = 3
out_handle = open("orchid_rpl16.fasta", "w")
从范围开始（0，计数，batch_size）：
    结束 = 分钟（计数，开始 + batch_size）
    print("要下载记录 %i 到 %i" % (start + 1, end))
    fetch_handle = Entrez.efetch(
        分贝=“核苷酸”，
        rettype="fasta",
        retmode="文本",
        重启=开始，
        retmax=batch_size,
        网络环境=网络环境，
        查询键=查询键，
        idtype="acc",
    )
    数据 = fetch_handle.read()
    fetch_handle.close()
    out_handle.write(数据)
out_handle.close()
```

出于说明目的，此示例分三批下载 FASTA 记录。除非您要下载基因组或染色体，否则您通常会选择更大的批量大小。

### 9.16.2 使用历史搜索和下载摘要

这是另一个历史示例，搜索去年发表的关于仙人掌的论文*，*然后将它们下载到 MedLine 格式的文件中：

```
从 Bio 导入 Entrez

Entrez.email = "history.user@example.com"
search_results = Entrez.read(
    Entrez.esearch(
        db="pubmed", term="Opuntia[ORGN]", reldate=365, datetype="pdat", usehistory="y"
    )
)
count = int(search_results["计数"])
print("找到 %i 个结果" % count)

batch_size = 10
out_handle = open("recent_orchid_papers.txt", "w")
从范围开始（0，计数，batch_size）：
    结束 = 分钟（计数，开始 + batch_size）
    print("要下载记录 %i 到 %i" % (start + 1, end))
    fetch_handle = Entrez.efetch(
        db =“pubmed”，
        rettype =“医学”，
        retmode="文本",
        重启=开始，
        retmax=batch_size,
        webenv=search_results["WebEnv"],
        query_key=search_results["QueryKey"],
    )
    数据 = fetch_handle.read()
    fetch_handle.close()
    out_handle.write(数据)
out_handle.close()
```

在撰写本文时，这给出了 28 个匹配项 - 但由于这是一个依赖于日期的搜索，因此这当然会有所不同。如上面[‍ 9.13.1](https://biopython-org.translate.goog/DIST/docs/tutorial/Tutorial.html?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN&_x_tr_pto=wapp&_x_tr_sch=http#sec%3Aentrez-and-medline)，您可以使用`Bio.Medline`来解析保存的记录。

### 9.16.3 搜索引文



回到第[9.7](https://biopython-org.translate.goog/DIST/docs/tutorial/Tutorial.html?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN&_x_tr_pto=wapp&_x_tr_sch=http#sec%3Aelink)我们提到 ELink 可用于搜索给定论文的引文。不幸的是，这只涵盖了为 PubMed Central 编入索引的期刊（为 PubMed 中的所有期刊都这样做意味着 NIH 需要做更多的工作）。让我们针对 Biopython PDB 解析器论文（PubMed ID 14630660）试试这个：

```
>>> 从 Bio 导入 Entrez
>>> Entrez.email = "ANOther@example.com" ## 总是告诉 NCBI 你是谁
>>> pmid = "14630660"
>>> 结果 = Entrez.read(
... Entrez.elink(dbfrom="pubmed", db="pmc", LinkName="pubmed_pmc_refs", id=pmid)
...）
>>> pmc_ids = [link["Id"] for link in results[0]["LinkSetDb"][0]["Link"]]
>>> pmc_ids
['2744707', '2705363', '2682512', ..., '1190160']
```

很棒 - 十一篇文章。但是为什么没有找到 Biopython 应用笔记（PubMed ID 19304878）？好吧，正如您可能已经从变量名称中猜到的那样，实际上并没有 PubMed ID，而是 PubMed Central ID。我们的应用说明是该列表中的第三篇施引论文，PMCID 2682512。

那么，如果（像我一样）您更愿意取回 PubMed ID 列表怎么办？那么我们可以再次调用 ELink 来翻译它们。这变成了一个两步过程，所以现在您应该期望使用历史功能来完成它（第[‍ 9.16](https://biopython-org.translate.goog/DIST/docs/tutorial/Tutorial.html?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN&_x_tr_pto=wapp&_x_tr_sch=http#sec%3Aentrez-webenv)）。

但首先，采用更直接的方法对 ELink 进行第二次（单独）调用：

```
>>> results2 = Entrez.read(
... Entrez.elink(dbfrom="pmc", db="pubmed", LinkName="pmc_pubmed", id=",".join(pmc_ids))
...）
>>> pubmed_ids = [link["Id"] for link in results2[0]["LinkSetDb"][0]["Link"]]
>>> pubmed_ids
['19698094', '19450287', '19304878', ..., '15985178']
```

这次您可以立即发现 Biopython 应用说明是第三个命中（PubMed ID 19304878）。

现在，让我们再做一次，但历史...... *TODO*。

最后，不要忘记在 Entrez 通话中包含您*自己的电子邮件地址。*